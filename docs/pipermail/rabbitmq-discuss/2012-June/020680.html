<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Application architecture question: queue	failure
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Application%20architecture%20question%3A%20queue%0A%09failure&In-Reply-To=%3C4FDF8FAF.5000007%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020674.html">
   <LINK REL="Next"  HREF="020508.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Application architecture question: queue	failure</H1>
    <B>Tim Watson</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Application%20architecture%20question%3A%20queue%0A%09failure&In-Reply-To=%3C4FDF8FAF.5000007%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] Application architecture question: queue	failure">tim at rabbitmq.com
       </A><BR>
    <I>Mon Jun 18 21:29:35 BST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="020674.html">[rabbitmq-discuss] Application architecture question: queue	failure
</A></li>
        <LI>Next message: <A HREF="020508.html">[rabbitmq-discuss] Specifying connection timeout in dotnet client
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20680">[ date ]</a>
              <a href="thread.html#20680">[ thread ]</a>
              <a href="subject.html#20680">[ subject ]</a>
              <a href="author.html#20680">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 18/06/2012 19:02, Bill Moseley wrote:
&gt;<i>
</I>&gt;<i> The idea is the worker picks up the job and atomically sets it from
</I>&gt;<i> &quot;pending&quot; to &quot;in process&quot; -- which means even if the job was queued
</I>&gt;<i> multiple times only one process would pick up the actual work.
</I>&gt;<i>
</I>&gt;<i> Then when the job is completed again the state is changed from &quot;in
</I>&gt;<i> process&quot; to &quot;completed&quot;.
</I>&gt;<i>
</I>
Ah ok, I get it now. Thanks for clarifying.

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Well, that's essentially my question.  Obviously, if I want the web app
</I>&gt;<i> to know that a report request was made so it can display to the user
</I>&gt;<i> that the report is in the process of being generated.  And I also want
</I>&gt;<i> to prevent multiple submissions by a user for the same thing.  So, the
</I>&gt;<i> database serves this function.
</I>&gt;<i>
</I>&gt;<i> The difficulty is when it gets stuck in pending.   At what point do we
</I>&gt;<i> give up or try again?
</I>&gt;<i>
</I>&gt;<i> Thans for your comments below.  I think the solution with the dead
</I>&gt;<i> letter is the way to go as it avoids using something like cron to handle
</I>&gt;<i> extra processing.   This way the task is always &quot;in the system&quot; in a
</I>&gt;<i> controlled way.
</I>&gt;<i>
</I>&gt;<i> Then not over engineer for the very rare chance of a failure.   May
</I>&gt;<i> don't even really need the durable queues if I can run a utility to
</I>&gt;<i> resubmit stuck &quot;pending&quot; jobs in those rare cases.
</I>&gt;<i>
</I>
Yes I do agree that keeping it simple is always best. A couple of points 
to bare in mind though. Durable queues are queue 'definitions' that will 
survive a restart or crash and have nothing to do with storing messages 
on disk. Persistent messages (sent with delivery_mode=2) are what causes 
things to hit the disk before they're confirmed. As these two factors 
are influenced merely by configuration (of the queue during the 
'declare' method) and header setting (on the client) I'd expect they add 
enough value for minimal design input not to be considered overhead, 
although there is obviously a cost in performance and disk use when 
fsync'ing everything to disk.

Without durable queues, your application startup code needs to handle 
queue declaration and setup. Doing without persistence is fine, but bare 
in mind that the broker could ack a message and crash moments later, 
causing the job to be completely lost if the messages aren't persistent 
and the queues are not HA/mirrored queues. Admittedly your database 
record of the job submission alleviates this risk to some extent, but 
your housekeeping utility will need to handle messages that are 
completely missing in this case, as well as re-submiting 'stuck' jobs. 
Producer confirms and persistence remove this risk, such that restarting 
the broker (after a crash or otherwise) will cause the queues to come up 
into their proper state and the producer will always know for sure 
whether or not the broker actually received a message due to the confirm 
being sent back. This pattern should simplify the rest of the 
application code somewhat.

&gt;<i>
</I>&gt;<i> Thanks very much for your input.
</I>&gt;<i>
</I>
My pleasure! :)
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020674.html">[rabbitmq-discuss] Application architecture question: queue	failure
</A></li>
	<LI>Next message: <A HREF="020508.html">[rabbitmq-discuss] Specifying connection timeout in dotnet client
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20680">[ date ]</a>
              <a href="thread.html#20680">[ thread ]</a>
              <a href="subject.html#20680">[ subject ]</a>
              <a href="author.html#20680">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
