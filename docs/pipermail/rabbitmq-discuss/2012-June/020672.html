<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Application architecture question: queue	failure
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Application%20architecture%20question%3A%20queue%0A%09failure&In-Reply-To=%3C4FDF657E.3030807%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020667.html">
   <LINK REL="Next"  HREF="020674.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Application architecture question: queue	failure</H1>
    <B>Tim Watson</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Application%20architecture%20question%3A%20queue%0A%09failure&In-Reply-To=%3C4FDF657E.3030807%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] Application architecture question: queue	failure">tim at rabbitmq.com
       </A><BR>
    <I>Mon Jun 18 18:29:34 BST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="020667.html">[rabbitmq-discuss] Application architecture question: queue	failure
</A></li>
        <LI>Next message: <A HREF="020674.html">[rabbitmq-discuss] Application architecture question: queue	failure
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20672">[ date ]</a>
              <a href="thread.html#20672">[ thread ]</a>
              <a href="subject.html#20672">[ subject ]</a>
              <a href="author.html#20672">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 18/06/2012 16:37, Bill Moseley wrote:
&gt;<i>
</I>&gt;<i> Let me give you an example -- which is an actual workflow we have.
</I>&gt;<i>
</I>&gt;<i> In our web app a user can select to receive a report.  In the web app we
</I>&gt;<i> want the user to see that the report is indeed queued, so in the
</I>&gt;<i> database we set a flag saying that the job was sent, and when.   This
</I>&gt;<i> allows us to display &quot;pending&quot; so the user doesn't submit the request
</I>&gt;<i> multiple times.
</I>&gt;<i>
</I>
So you already have some kind of identity, in order to uniquely identify 
the job in the database.

&gt;<i> The web app queues the message for the background report generation.
</I>&gt;<i> Anything is possible -- so imagine first that the message is somehow
</I>&gt;<i> lost.  The web app is still showing &quot;pending&quot; to the user.
</I>&gt;<i>
</I>
Well that's true, anything *is* possible. You're entire data centre and 
its resident rabbitmq cluster nodes could all disappear off the face of 
the earth, the hard drives no longer usable, etc. In order to deal with 
that kind of scenario, persistent messages and HA do you no good and 
from a disaster recovery standpoint, you definitely need a way to 
re-synchronise the database and figure out which jobs have actually been 
lost.

&gt;<i> But, we do want the task to complete -- it's a revenue generator, for
</I>&gt;<i> example.   So, one option is to use cron to look for stale &quot;pending&quot;
</I>&gt;<i> request on the web side and assume the message was lost and re-queue.
</I>&gt;<i> But, after X attempts maybe the cron job decides to give up.
</I>&gt;<i>
</I>
It *sounds* to me like you need the house keeping functions to set a 
different completion status on the database record depending on how the 
task was resolved.

&gt;<i> Now, this report generation actually uses a third-party web service, and
</I>&gt;<i> this web service has gone down for extended periods for maintenance.
</I>&gt;<i>   So, in this case the report request jobs stack up in the queue.
</I>&gt;<i>
</I>&gt;<i> So, if it's down long enough then cron might run again and re-queue the
</I>&gt;<i> same job that is already in the queue.   What I have done for this is
</I>&gt;<i> atomically change the state from &quot;pending&quot; to &quot;in process&quot; so that only
</I>&gt;<i> one message gets processed.  But, using some kind of UUID and a store is
</I>&gt;<i> another option, of course.
</I>&gt;<i>
</I>
I'm a bit confused now. Where do you set this 'in process' status - on 
the newly submitted message, or in the database record or in some field 
in the originally submitted message(s)?

&gt;<i> Maybe you are right that durable queues are the correct solution for
</I>&gt;<i> this -- I still need to track state on the web app side to show
</I>&gt;<i> &quot;pending&quot; or &quot;in process&quot;.   And maybe just use cron to report/clean up
</I>&gt;<i> any stale pending job on the web app side.
</I>&gt;<i>
</I>&gt;<i> I'm just curious if the above is a common design pattern when using
</I>&gt;<i> RabbitMQ in this way.  Obviously, depends on the specifics of the task,
</I>&gt;<i> but we seem to have quite a few situations like this.
</I>&gt;<i>
</I>
I still don't understand the difference between 'stale' and 'pending'. 
Whether you do this based on timestamp or uuid or whatever, you need 
*some* mechanism to avoid duplicating work. Because AMQP cannot reliably 
do 'only once' delivery without consumer intervention, I would expect 
that you need to track which jobs have been handled and which have not. 
What I don't understand is how this pending/stale flag helps you, nor 
why cron jobs are an attractive choice to deal with expiring messages.

It seems to me there are a few separate problem domains here, which are 
getting tangled up in our discussion. I would posit that you need to 
deal with

1. Making sure a job/task has definitely been 'registered' with the system.

2. Indicating the outcome of (1) to your users

3. Avoiding 're-submitting' the same job/task many times

4. Dealing with failures in external services

Please feel free to correct that list or add to it or whatever.

When it comes to (1), as I mentioned durable queues with persistent 
messages are the way to go. Once a message is 'on disk' then it is 
reasonable for you to assume that the job is safely 'in the system' now. 
I won't pretend that this represents a complete disaster recovery 
solution, because we both know it does not. I do feel, however, that 
such a solution involves *far* more technology that just your message 
broker, so I'm going to gently push it out of scope for the purposes of 
this discussion. :)

As for (2), in the absence of queue browsing, you are probably doing the 
right thing already in terms of storing a record in your web 
application's database to indicate that the job has indeed been 
submitted (and is now in a pending state).

Your problem with 'duplicate tasks' appears to happen mainly because 
your cron job 're-submits' the message. With a persistent queue, there 
would be no need to do this at all, as the message is on disk and will 
survive a broker crash (though it won't survive if your data centre 
slips off a cliff into the ocean).

What I'd suggest is a slightly different approach. Set up your durable 
task queue with a 'dead letter exchange' so that expiring messages (or 
those rejected with `requeue=false`) will be shoved into that exchange. 
Now set up the target (dead letter) exchange to publish to another 
(durable) queue, let's call it 'redelivery', and make sure this is 
configured to stay around even when there are no consumers.

Set up a 'permanent subscriber' to the 'redelivery' queue - i.e., have 
an always running thread consuming these messages and make sure it is 
restarted if it fails for any reason - and have this subscriber take 
each arriving message and re-submit it to the original task queue.

Finally, when submitting jobs to the task queue, set the TTL to a 
reasonable value (for your application's needs) and this is what will 
happen:

1. you submit the task
2. the task TTL expires after the correct time lapse
3. the broker sends the 'expired' message to the 'dead letter exchange'
4. the exchange routes the message to the 'redelivery' queue
5. the redelivery queue re-submits the message (as a new message!) to 
the task queue
6. a consumer (job) grabs the message before it expires this time
7. the job (process/thread/application) fails (due to an external 
service error or whatever)
8. the job (process/thread/application) rejects the job with `requeue=false`
9. steps 3, 4 and 5 run again
10. eventually something good happens!?

Actually to deal properly with 10, you probably want to keep some kind 
of timestamp with the message and in the consumer that is reading the 
'redelivery' queue and re-submitting jobs, allow the message to time out 
and set an error flag in the database (or something).

If you *do* have some kind of external identity that holds for the 
(conceptual) lifetime of the task, then you could store this original 
timestamp in the database and query that against the task id, but 
obviously you'll need to consider the potential performance (and 
architectural) implications of doing that for yourself.

Step (8) might also be problematic if your tasks take a long time to 
complete, so you may wish to rework that state in terms of re-submitting 
instead of rejecting the message. As long as you have heartbeats 
enabled, your consumer channel shouldn't be closed, but until you've 
ack'ed the message one way or another, other consumers could 'get' it 
and therefore you'll need to make them idempotent to deal with this.

What ever you choose to do, the database needs to be properly updated 
when a task does finally succeed. The fact that you *must* do this at 
some point already (in order for the UI to be consistent) means you 
already have a thread of identity, and therefore you should be able to 
use this to create idempotent consumers where duplicate tasks are 
potentially an issue.

&gt;<i> Oh, and with this example of the third-party web service another problem
</I>&gt;<i> is knowing if a failure of this service is permanent or temporary.  I
</I>&gt;<i> have not done this, but I'm tempted to have my workers pull the jobs off
</I>&gt;<i> the queue and if the job fails for an unclear reason then ack the
</I>&gt;<i> original job and then send it to a &quot;try again later&quot; queue and have
</I>&gt;<i> separate workers handle those.
</I>&gt;<i>
</I>
That sounds like a reasonable approach. It is somewhat similar to the 
approach I describe above.
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020667.html">[rabbitmq-discuss] Application architecture question: queue	failure
</A></li>
	<LI>Next message: <A HREF="020674.html">[rabbitmq-discuss] Application architecture question: queue	failure
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20672">[ date ]</a>
              <a href="thread.html#20672">[ thread ]</a>
              <a href="subject.html#20672">[ subject ]</a>
              <a href="author.html#20672">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
