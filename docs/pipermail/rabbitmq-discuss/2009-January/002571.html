<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Explicit ACKs - Timeout Algorithm? (related:	Net::Stomp)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Explicit%20ACKs%20-%20Timeout%20Algorithm%3F%20%28related%3A%0A%09Net%3A%3AStomp%29&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002589.html">
   <LINK REL="Next"  HREF="002714.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Explicit ACKs - Timeout Algorithm? (related:	Net::Stomp)</H1>
    <B>Darien Kindlund</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Explicit%20ACKs%20-%20Timeout%20Algorithm%3F%20%28related%3A%0A%09Net%3A%3AStomp%29&In-Reply-To="
       TITLE="[rabbitmq-discuss] Explicit ACKs - Timeout Algorithm? (related:	Net::Stomp)">darien at kindlund.com
       </A><BR>
    <I>Wed Jan 14 20:28:39 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002589.html">[rabbitmq-discuss] Message Priority &amp; 'Headers' Exchange Type (was: Net::AMQP Perl Client - Status?)
</A></li>
        <LI>Next message: <A HREF="002714.html">[rabbitmq-discuss] Explicit ACKs - Timeout Algorithm? (related: Net::Stomp)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2571">[ date ]</a>
              <a href="thread.html#2571">[ thread ]</a>
              <a href="subject.html#2571">[ subject ]</a>
              <a href="author.html#2571">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>One of the other questions I had centers around RabbitMQ's method (or
maybe the rabbitmq-stomp connector) of dealing with explicit ACKs.

Using Tony's example perl code (rabbitmq_stomp_recv.pl) as a basis:
1 #!/usr/bin/perl -w
2 # subscribe to messages from the queue 'foo'
3 use Net::Stomp;
4 my $stomp = Net::Stomp-&gt;new({hostname=&gt;'localhost', port=&gt;'61613'});
5 $stomp-&gt;connect({login=&gt;'guest', passcode=&gt;'guest'});
6 $stomp-&gt;subscribe({'destination'=&gt;'foo', 'ack'=&gt;'client'});
7 while (1) {
8     my $frame = $stomp-&gt;receive_frame;
9     print $frame-&gt;body . &quot;\n&quot;;
10     $stomp-&gt;ack({frame=&gt;$frame});
11     last if $frame-&gt;body eq 'QUIT';
12 }
13 $stomp-&gt;disconnect;

Specifically, assume you have two perl clients both running this code
and are both acting as consumers to a shared queue.  If one instance
of this code crashes (for whatever reason) after line 8 but before
line 10, then RabbitMQ will do the right thing and redeliver the
(previously acquired?) message to the other instance of the perl code
that is still running.

Now, what if both perl-based consumers were slightly different.
Meaning, one consumer behaves normally (equivalent to
rabbitmq_stomp_recv.pl), but the other consumer is poorly written, and
every once in awhile enters some sort of infinite loop after line 8
but before line 10.  Essentially, this consumer has acquired (?) the
message but not explicitly acknowledged the message.  In this case,
I'm thinking the &quot;right thing&quot; would be for RabbitMQ to create some
sort of timeout, where after X minutes(?), if the message doesn't get
acknowledged, then RabbitMQ will alter the message to be &quot;not
acquired&quot; so that some other (better behaving) consumer can process
this message.

1) So far, it seems that RabbitMQ will only alter messages that have
been previously been &quot;acquired&quot; back to &quot;not acquired&quot; ONLY when the
original consumer's *channel* has been terminated (for some reason;
i.e., network error).  I have not been able to get RabbitMQ to perform
this same type of &quot;recovery&quot; for any consumers that mimic the behavior
of poorly written applications (i.e., the channel stays alive, but a
fault in the underlying application logic of one consumer prevents
proper message delivery to properly functioning consumers).

2) Is there any reference in the AMQP specification for dealing with
these situations?  If RabbitMQ does implement some sort of timeout (as
previously stated), what is the default time delay?

3) Is it possible that in order to achieve this type of behavior, you
have to use transactions (tx) or distributed transactions (dtx) in
RabbitMQ?

Thanks for your help,
-- Darien


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002589.html">[rabbitmq-discuss] Message Priority &amp; 'Headers' Exchange Type (was: Net::AMQP Perl Client - Status?)
</A></li>
	<LI>Next message: <A HREF="002714.html">[rabbitmq-discuss] Explicit ACKs - Timeout Algorithm? (related: Net::Stomp)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2571">[ date ]</a>
              <a href="thread.html#2571">[ thread ]</a>
              <a href="subject.html#2571">[ subject ]</a>
              <a href="author.html#2571">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
