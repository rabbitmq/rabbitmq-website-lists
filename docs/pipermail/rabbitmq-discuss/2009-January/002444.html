<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Use%20of%20Java%201.4%20with%20the%20RabbitMQ%20Java%0A%09Client%20library&In-Reply-To=4964CB4D.60605%40wizards.de">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002443.html">
   <LINK REL="Next"  HREF="002628.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library</H1>
    <B>Kirk Wylie</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Use%20of%20Java%201.4%20with%20the%20RabbitMQ%20Java%0A%09Client%20library&In-Reply-To=4964CB4D.60605%40wizards.de"
       TITLE="[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library">kirk at kirkwylie.com
       </A><BR>
    <I>Wed Jan  7 16:46:08 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002443.html">[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library
</A></li>
        <LI>Next message: <A HREF="002628.html">[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2444">[ date ]</a>
              <a href="thread.html#2444">[ thread ]</a>
              <a href="subject.html#2444">[ subject ]</a>
              <a href="author.html#2444">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, Jan 7, 2009 at 3:33 PM, Holger Hoffst&#228;tte &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">holger at wizards.de</A>&gt; wrote:
&gt;<i> Kirk Wylie wrote:
</I>&gt;&gt;<i> One of the first things I wanted to do was to improve the current test
</I>&gt;&gt;<i> suite to add quite a few more &quot;pure&quot; unit tests (right now it's almost
</I>&gt;<i>
</I>&gt;<i> good - though not sure how much they are ultimately worth it, as much of
</I>&gt;<i> the functionality is in the autogenerated protocol. Other than that I
</I>&gt;<i> found the code to be very readable and understandable, especially
</I>&gt;<i> considering how much time could be spent on it.
</I>
Oh, yeah, the code is definitely in good shape, but it could always be
better. :-)

The primary reason I thought to add some pure &quot;unit&quot; tests is that in
conjunction with coverage tools (which you and I both have referenced)
you can get some pretty interesting optimization and bang-for-the-buck
test cases. It's also a lot easier to identify precisely WHERE you've
broken the code with low-level tests-in-isolation.

&gt;&gt;<i> Then the first crazy/mundane thing that I was going to attempt was a
</I>&gt;&gt;<i> connection pooling system. Because that'll be quite complex, I want to
</I>&gt;&gt;<i> tackle the test side first so that I'm confident that I'm not breaking
</I>&gt;&gt;<i> things in subtle ways.
</I>&gt;<i>
</I>&gt;<i> Oh dear. :) Got so many connections? I thought they were supposed to be
</I>&gt;<i> kept open.
</I>
They are. That's the point. :-)

The issue is one similar to JDBC-based systems. You may have an object
which is otherwise stateless that needs to just publish out a message
when certain things happen. Does that one object need its own
Connection? No. Does it need to really hold open a stateful socket? No
as well. So it's probably easiest conceptually for the block to:
- Acquire a Connection
- Publish Message
- Release the Connection
Given that you may want to have blocks like that, and you might NOT
want to actually have &quot;acquire a connection&quot; mean &quot;open a TCP socket&quot;,
you have a natural case for connection pools.

Admittedly, this is less useful than in JDBC, where a connection is
also a session, but I've come across cases where it would be useful in
the past, so no reason why we couldn't give it a shot! :-)

&gt;<i> Crazy German Alert!
</I>&gt;<i>
</I>&gt;<i> - define common org.amqp interfaces (ala JMS) so that client app code
</I>&gt;<i> doesn't rely on the client lib implementation. Would require some work
</I>&gt;<i> with the WG but as the spec, entities and semantics keep changing it would
</I>&gt;<i> be a moving target so I haven't really bothered yet. Not sure if anybody
</I>&gt;<i> would even care as soon as the JMS mapping has been wrangled into the spec.
</I>
I think JMS is quite possibly the better strategy for this, as you've
indicated. But the fact that your multiple client libraries are
implementing the same protocol means that you're probably not in as
bad a situation as you would be with JMS, and that locks everybody
into the same API at the code level. Perhaps one of the things that
AMQP brings to the table is that you can choose the protocol
implementation that most closely matches your desired API rather than
choosing your API based on the protocol that it needs to implement.

Once 0-9-1 reaches full interoperability, I don't expect for example
that there will even BE multiple AMQP Java client libraries that have
equivalent enough code APIs that you could do this. Why would there
be?

&gt;<i> - n:m mapping of channels to socket connections, based on either some
</I>&gt;<i> up-front fixed ratio/priority scheme or dynamically adjusted traffic per
</I>&gt;<i> channel (maybe grouping slow/mostly-idle periodic polling/ticker channels
</I>&gt;<i> together). This would allow to connect to multiple broker instances in
</I>&gt;<i> parallel.
</I>
Think of this in terms of a connection pool. That's what I'm talking about.

The connection pool concept here is more subtle than one for a
database (where connection == session/channel). In fact, rather than
having a &quot;locked out/locked in&quot; nature, you have a load factor on each
individual connection, which may be based on # channels, or something
even more sophisticated (load in messages or bytes/second, burst rate,
etc.).

&gt;<i> - maybe moving to NIO since it might nicely map to AMQP channels. A Netty
</I>&gt;<i> AMQP packet codec should be easy, and a consumer could register a payload
</I>&gt;<i> decoder on top of a channel for easy payload disassembly - Thrift,
</I>&gt;<i> Protobufs, XML (arrgh).
</I>
NIO does match well, but NIO in Java doesn't match thread-blocking
old-IO for performance yet. It's far more a server-side technology in
terms of performance these days, because you have to have a LOT of
sockets open for NIO to beat OldIO for performance by any metric.

But it would definitely be an interesting talking point for the
community, and an NIO-based client could be quite useful for people
trying to do big AMQP routing and relaying in Java (see my comment
above about letting a thousant client libraries bloom with different
code-level APIs). I think if you're working with pure asynch IO, you
might want a different client API entirely to take advantage of it.

BTW, thanks for the link to Netty. Hadn't run across it yet.

&gt;<i> - more concurreny all the way, decoupling fragment assembly/concurrent
</I>&gt;<i> consumer delivery and the reader thread, backed by an injectable Executor
</I>&gt;<i> (looking at you, WorkManager). Incidentally that's how Netty works too.
</I>&gt;<i> Also the channel map is pretty oversynchronized and used from multiple
</I>&gt;<i> paths..not so good for multiple connections.
</I>
&gt;<i> - no blocking queues and only concurrent dequeues where they cannot be
</I>&gt;<i> avoided. only blocking on condition objects, and always with timeouts.
</I>
Yep, there's definitely some places where concurrent performance could
be improved. And continuing to rely on backports-concurrent might
hinder that (which is why I started this trying to figure out whether
people are even using it in 1.4).

&gt;<i> - find a way towards as-zero-copy-as-possible fragment assembly. Each time
</I>&gt;<i> I see dozens of litte byte[]s being copied around 17 times for a single
</I>&gt;<i> message because of the !&quot;&#167;$ stream APIs my inner geek dies a little.
</I>&gt;<i>
</I>&gt;<i> - JMX beanz for stats
</I>&gt;<i>
</I>&gt;<i> - write a Spring-Integration transport because it happens to be based on
</I>&gt;<i> channel abstractions and will likely map nicely.
</I>&gt;<i>
</I>&gt;<i> like I said, crazy.. and probably totally useless.
</I>
I don't think any of those are crazy or probably useless. If nothing
else, it gives me some fodder to get going with!

Kirk


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002443.html">[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library
</A></li>
	<LI>Next message: <A HREF="002628.html">[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2444">[ date ]</a>
              <a href="thread.html#2444">[ thread ]</a>
              <a href="subject.html#2444">[ subject ]</a>
              <a href="author.html#2444">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
