<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java Client library
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Use%20of%20Java%201.4%20with%20the%20RabbitMQ%20Java%0A%20Client%20library&In-Reply-To=8f10a9e00901070630p1e924bf5v8ec4c4a9ccf8f555%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002438.html">
   <LINK REL="Next"  HREF="002442.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java Client library</H1>
    <B>Holger Hoffst&#228;tte</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Use%20of%20Java%201.4%20with%20the%20RabbitMQ%20Java%0A%20Client%20library&In-Reply-To=8f10a9e00901070630p1e924bf5v8ec4c4a9ccf8f555%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java Client library">holger at wizards.de
       </A><BR>
    <I>Wed Jan  7 15:33:33 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002438.html">[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library
</A></li>
        <LI>Next message: <A HREF="002442.html">[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java Client library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2441">[ date ]</a>
              <a href="thread.html#2441">[ thread ]</a>
              <a href="subject.html#2441">[ subject ]</a>
              <a href="author.html#2441">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Kirk Wylie wrote:
&gt;<i> On Wed, Jan 7, 2009 at 2:15 PM, Holger Hoffst&#228;tte &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">holger at wizards.de</A>&gt; wrote:
</I>&gt;&gt;<i> I've had many ideas flying around in my head (some crazy, some rather
</I>&gt;&gt;<i> mundane) but haven't really found the time to implement any yet. Can you
</I>&gt;&gt;<i> share what you're planning?
</I>&gt;<i> 
</I>&gt;<i> One of the first things I wanted to do was to improve the current test
</I>&gt;<i> suite to add quite a few more &quot;pure&quot; unit tests (right now it's almost
</I>
good - though not sure how much they are ultimately worth it, as much of
the functionality is in the autogenerated protocol. Other than that I
found the code to be very readable and understandable, especially
considering how much time could be spent on it.

&gt;<i> Then the first crazy/mundane thing that I was going to attempt was a
</I>&gt;<i> connection pooling system. Because that'll be quite complex, I want to
</I>&gt;<i> tackle the test side first so that I'm confident that I'm not breaking
</I>&gt;<i> things in subtle ways.
</I>
Oh dear. :) Got so many connections? I thought they were supposed to be
kept open.

&gt;<i> What ideas did you have?
</I>
Crazy German Alert!

- define common org.amqp interfaces (ala JMS) so that client app code
doesn't rely on the client lib implementation. Would require some work
with the WG but as the spec, entities and semantics keep changing it would
be a moving target so I haven't really bothered yet. Not sure if anybody
would even care as soon as the JMS mapping has been wrangled into the spec.

- n:m mapping of channels to socket connections, based on either some
up-front fixed ratio/priority scheme or dynamically adjusted traffic per
channel (maybe grouping slow/mostly-idle periodic polling/ticker channels
together). This would allow to connect to multiple broker instances in
parallel.

- maybe moving to NIO since it might nicely map to AMQP channels. A Netty
AMQP packet codec should be easy, and a consumer could register a payload
decoder on top of a channel for easy payload disassembly - Thrift,
Protobufs, XML (arrgh).

- more concurreny all the way, decoupling fragment assembly/concurrent
consumer delivery and the reader thread, backed by an injectable Executor
(looking at you, WorkManager). Incidentally that's how Netty works too.
Also the channel map is pretty oversynchronized and used from multiple
paths..not so good for multiple connections.

- the above would also accidentally slip in a JTA transaction thread boundary.

- no blocking queues and only concurrent dequeues where they cannot be
avoided. only blocking on condition objects, and always with timeouts.

- find a way towards as-zero-copy-as-possible fragment assembly. Each time
I see dozens of litte byte[]s being copied around 17 times for a single
message because of the !&quot;&#167;$ stream APIs my inner geek dies a little.

- JMX beanz for stats

- write a Spring-Integration transport because it happens to be based on
channel abstractions and will likely map nicely.

like I said, crazy.. and probably totally useless.

More JUnit tests, increased coverage or a proper maven build are probably
more helpful :-)

Holger



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002438.html">[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java	Client library
</A></li>
	<LI>Next message: <A HREF="002442.html">[rabbitmq-discuss] Use of Java 1.4 with the RabbitMQ Java Client library
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2441">[ date ]</a>
              <a href="thread.html#2441">[ thread ]</a>
              <a href="subject.html#2441">[ subject ]</a>
              <a href="author.html#2441">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
