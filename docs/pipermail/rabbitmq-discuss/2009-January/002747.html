<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] A new exchange type
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20A%20new%20exchange%20type&In-Reply-To=5A46D132C446C04B9EFE8AD14E7891065C49E4B4BB%40SVR-2K3-BH-EMC.tradition.int">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002750.html">
   <LINK REL="Next"  HREF="002753.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] A new exchange type</H1>
    <B>Tony Garnock-Jones</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20A%20new%20exchange%20type&In-Reply-To=5A46D132C446C04B9EFE8AD14E7891065C49E4B4BB%40SVR-2K3-BH-EMC.tradition.int"
       TITLE="[rabbitmq-discuss] A new exchange type">tonyg at lshift.net
       </A><BR>
    <I>Wed Jan 28 11:33:02 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002750.html">[rabbitmq-discuss] A new exchange type
</A></li>
        <LI>Next message: <A HREF="002753.html">[rabbitmq-discuss] A new exchange type
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2747">[ date ]</a>
              <a href="thread.html#2747">[ thread ]</a>
              <a href="subject.html#2747">[ subject ]</a>
              <a href="author.html#2747">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Alister,

That's a great insight. We've been puzzling over &quot;last-value caching&quot;
for a while now, and not made any great progress, largely I think
because we'd concentrated on putting it in to the *queues* rather than
the exchanges. Your observation that it's best placed in the *exchange*
is, I think, critical. Great stuff!

So given a stateful (!) exchange of the kind you describe, what could
some of the parameters be for its behaviour?

 - how entries in the cache are expired

 - how the cache is keyed

 - whether looser consistency than total across a cluster is
   worthwhile for each particular application

Anything else?

Off the top of my head, it'd be a straightforward enough implementation.
Presumably it would be activated by an argument in the exchange.declare
arguments table. A new shared mnesia table would be required, with the
same scope as the routing tables. It could either be disk- or
ram-resident. On binding creation, a scan of the cache table would be
done and the matching messages delivered to the queue before the binding
completes.

Tony



Alister Morton wrote:
&gt;<i> We have a use pattern in mind that I think would require development
</I>of a new exchange type, and a couple of conversations with Alexis would
seem to reinforce this view that, currently, the functionality we have
in mind doesn't exist in rabbitmq.
&gt;<i> 
</I>&gt;<i> What we'd like to do is have an exchange type which acted like a
</I>regular topic exchange, where messages are &quot;routed&quot; into queues based on
the topic, but in addition kept a copy of the last message sent to the
exchange for each topic. So the behaviour of the exchange would be
slightly different to how it is at the moment. Currently, if you create
a purely topic based exchange, and publish a message to it, then some
time alter attach a queue to that subject, no message is delivered until
the next message is published to that topic. With the new exchange the
newly connected queue would immediately receive a message that was a
copy of the last message published, however long ago it was. Clearly,
the timestamp on the message is important, but this architecture could,
I think, be very useful. One use would be as a replacement for the
proprietary &quot;market data feed&quot; type servers many institutions use to
share internal data records. Although there is clearly a distinction
between a &quot;record&quot; and a &quot;message&quot; it would be very simple, and for many
purposes perfectly adequate, to build a simple internal feed system
around a RabbitMQ message broker with this new, additional exchange type.
&gt;<i> 
</I>&gt;<i> Anyone else see a use for it? We're currently weighing up the pros
</I>&gt;<i> and
</I>cons of having such an exchange developed for rabbit, or continuing to
use our own, internally developed but proprietary message broker, which
/does/ implement last message persistence in this way.

-- 
 [][][] Tony Garnock-Jones     | Mob: +44 (0)7905 974 211
   [][] LShift Ltd             | Tel: +44 (0)20 7729 7060
 []  [] <A HREF="http://www.lshift.net/">http://www.lshift.net/</A> | Email: <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">tonyg at lshift.net</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002750.html">[rabbitmq-discuss] A new exchange type
</A></li>
	<LI>Next message: <A HREF="002753.html">[rabbitmq-discuss] A new exchange type
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2747">[ date ]</a>
              <a href="thread.html#2747">[ thread ]</a>
              <a href="subject.html#2747">[ subject ]</a>
              <a href="author.html#2747">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
