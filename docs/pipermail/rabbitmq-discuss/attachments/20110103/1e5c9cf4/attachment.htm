<tt>
Hi,&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I&amp;#39;m&nbsp;just&nbsp;starting&nbsp;out&nbsp;with&nbsp;RabbitMQ&nbsp;and&nbsp;trying&nbsp;to&nbsp;wrap&nbsp;my&nbsp;head&nbsp;around&nbsp;a&nbsp;few&nbsp;concepts.&nbsp; I&nbsp;apologize&nbsp;if&nbsp;I&nbsp;ask&nbsp;something&nbsp;that&nbsp;should&nbsp;be&nbsp;obvious&nbsp;or&nbsp;I&nbsp;missed&nbsp;in&nbsp;the&nbsp;docs&nbsp;and&nbsp;faq.&nbsp; I&amp;#39;m&nbsp;hoping&nbsp;someone&nbsp;can&nbsp;help&nbsp;with&nbsp;a&nbsp;few&nbsp;scenarios,&nbsp;and&nbsp;please&nbsp;point&nbsp;me&nbsp;to&nbsp;further&nbsp;reading&nbsp;as&nbsp;needed.&lt;/div&gt;<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;<br>
<br>
I&amp;#39;m&nbsp;curious&nbsp;about&nbsp;use-cases&nbsp;that&nbsp;are&nbsp;not&nbsp;directly&nbsp;related&nbsp;to&nbsp;RabbitMQ,&nbsp;but&nbsp;how&nbsp;to&nbsp;best&nbsp;use&nbsp;RabbitMQ&nbsp;in&nbsp;an&nbsp;web&nbsp;application&amp;#39;s architecture.&nbsp; Thes&nbsp;are&nbsp;probably&nbsp;very&nbsp;common&nbsp;situations.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1)&nbsp;Notification&nbsp;of&nbsp;job&nbsp;status&nbsp;and&nbsp;completion:&nbsp; If&nbsp;the&nbsp;web&nbsp;app&nbsp;produces&nbsp;a&nbsp;request&nbsp;to&nbsp;generate&nbsp;an&nbsp;expensive&nbsp;PDF&nbsp;is&nbsp;there&nbsp;a&nbsp;common&nbsp;approach&nbsp;to&nbsp;detecting&nbsp;when&nbsp;the&nbsp;consumer&nbsp;is&nbsp;completed&nbsp;and&nbsp;the&nbsp;pdf&nbsp;is&nbsp;ready&nbsp;for&nbsp;downloading?&nbsp; Should&nbsp;I&nbsp;create&nbsp;a&nbsp;single-use&nbsp;return&nbsp;queue&nbsp;with&nbsp;x-expires&nbsp;and/or&nbsp;x-message-ttl&nbsp;on&nbsp;the&nbsp;queue?&nbsp; &nbsp;In&nbsp;a&nbsp;web&nbsp;app&nbsp;the&nbsp;web&nbsp;user&nbsp;may&nbsp;never&nbsp;come&nbsp;back&nbsp;to&nbsp;pick&nbsp;up&nbsp;the&nbsp;PDF.&lt;/div&gt;<br>
<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2)&nbsp;Job&nbsp;sequencing:&nbsp; What&amp;#39;s&nbsp;a&nbsp;common&nbsp;approach&nbsp;to&nbsp;multiple&nbsp;step&nbsp;processing&nbsp;that&nbsp;must&nbsp;be&nbsp;done&nbsp;serially?&nbsp; I.e.&nbsp;queue&nbsp;job&nbsp;&amp;quot;A&amp;quot;&nbsp;and&nbsp;when&nbsp;it&amp;#39;s&nbsp;complete&nbsp;queue&nbsp;job&nbsp;&amp;quot;B&amp;quot;.&nbsp; Doesn&amp;#39;t&nbsp;really&nbsp;seem&nbsp;like&nbsp;consumer&nbsp;&amp;quot;A&amp;quot;&nbsp;should&nbsp;be&nbsp;responsible&nbsp;for&nbsp;submitting&nbsp;job&nbsp;&amp;quot;B&amp;quot;.&nbsp; Is&nbsp;it&nbsp;better&nbsp;to&nbsp;create&nbsp;a&nbsp;consumer&nbsp;&amp;quot;AB&amp;quot;&nbsp;that&nbsp;submits&nbsp;&amp;quot;A&amp;quot;&nbsp;and&nbsp;waits&nbsp;for&nbsp;a&nbsp;message&nbsp;that&nbsp;&amp;quot;A&amp;quot;&nbsp;is&nbsp;complete&nbsp;and&nbsp;then&nbsp;submits&nbsp;job&nbsp;&amp;quot;B&amp;quot;?&lt;/div&gt;<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3)&nbsp;Scheduling:&nbsp;I&nbsp;assume&nbsp;there&amp;#39;s&nbsp;no&nbsp;facility&nbsp;for&nbsp;scheduling&nbsp;jobs&nbsp;to&nbsp;be&nbsp;delivered&nbsp;to&nbsp;consumers&nbsp;at&nbsp;some&nbsp;future&nbsp;time.&nbsp; Is&nbsp;there&nbsp;a&nbsp;better&nbsp;approach&nbsp;than&nbsp;using&nbsp;cron&nbsp;to&nbsp;check&nbsp;the&nbsp;database&nbsp;for&nbsp;jobs&nbsp;that&nbsp;should&nbsp;be&nbsp;queued&nbsp;based&nbsp;on&nbsp;time?&lt;/div&gt;<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4)&nbsp;Cancel&nbsp;a&nbsp;request:&nbsp; We&nbsp;have&nbsp;some&nbsp;situations&nbsp;when&nbsp;a&nbsp;subsequent&nbsp;request&nbsp;should&nbsp;cancel&nbsp;processing&nbsp;of&nbsp;an&nbsp;earlier&nbsp;request.&nbsp; (Frankly,&nbsp;I&nbsp;think&nbsp;this&nbsp;is&nbsp;a&nbsp;design&nbsp;problem&nbsp;on&nbsp;our&nbsp;end.)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;<br>
<br>
5)&nbsp;Prevent&nbsp;duplicate&nbsp;job&nbsp;requests:&nbsp;In&nbsp;a&nbsp;web&nbsp;environment&nbsp;when&nbsp;things&nbsp;break&nbsp;problems&nbsp;often&nbsp;compound&nbsp;by&nbsp;users&nbsp;reloading&nbsp;requests&nbsp;that&nbsp;caused&nbsp;the&nbsp;problem&nbsp;in&nbsp;the&nbsp;first&nbsp;place.&nbsp; I&amp;#39;m&nbsp;not&nbsp;sure&nbsp;RabbitMQ&nbsp;would&nbsp;be&nbsp;involved&nbsp;at&nbsp;all&nbsp;in&nbsp;this&nbsp;scenario,&nbsp;but&nbsp;I&amp;#39;m&nbsp;asking&nbsp;just&nbsp;in&nbsp;case.&nbsp;;)&nbsp; &lt;/div&gt;<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Finally,&nbsp;it&amp;#39;s&nbsp;great&nbsp;that&nbsp;RabbitMQ&nbsp;will&nbsp;send&nbsp;a&nbsp;message&nbsp;again&nbsp;if&nbsp;is&nbsp;is&nbsp;not&nbsp;ACK&amp;#39;d&nbsp;and&nbsp;a&nbsp;consumer&nbsp;closes&nbsp;its&nbsp;connection.&nbsp; But,&nbsp;is&nbsp;there&nbsp;any&nbsp;kind&nbsp;of&nbsp;max&nbsp;retry&nbsp;count&nbsp;available?&nbsp; That&nbsp;is,&nbsp;what&amp;#39;s&nbsp;a&nbsp;good&nbsp;approach&nbsp;to&nbsp;prevent&nbsp;an&nbsp;errant&nbsp;job&nbsp;from&nbsp;killing&nbsp;all&nbsp;consumers&nbsp;one-by-one?&lt;/div&gt;<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Thanks,&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;--&nbsp;&lt;br&gt;Bill&nbsp;Moseley&lt;br&gt;&lt;a&nbsp;href=&quot;mailto:moseley@hank.org&quot;&nbsp;target=&quot;_blank&quot;&gt;moseley@hank.org&lt;/a&gt;&lt;br&gt;<br>
&lt;/div&gt;<br>

</tt>
