PHP_METHOD(amqp_queue_class, getMessages)
{
	zval *id;
    amqp_queue_object *queue;
	amqp_channel_object *channel;
	amqp_connection_object *connection;
	
	amqp_rpc_reply_t res;
	long min_messages = INI_INT("amqp.min_messages");
	long max_messages = INI_INT("amqp.max_messages");
	long flags = INI_INT("amqp.auto_ack") ? AMQP_AUTOACK : AMQP_NOPARAM;
	
	char *pbuf;

	int buf_max = FRAME_MAX;

	/* Parse out the method parameters */
	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O|lll", &id, amqp_queue_class_entry, &min_messages, &max_messages, &flags) == FAILURE) {
		return;
	}
	
	queue = (amqp_queue_object *)zend_object_store_get_object(id TSRMLS_CC);
	
	/* Check that the given connection has a channel, before trying to pull the connection off the stack */
	if (queue->is_connected != '\1') {
		zend_throw_exception(amqp_queue_exception_class_entry, "Could not get messages from queue. No connection available.", 0 TSRMLS_CC);
		return;
	}

	channel = AMQP_GET_CHANNEL(queue);
	AMQP_VERIFY_CHANNEL(channel, "Could not get messages from queue.");
	
	connection = AMQP_GET_CONNECTION(channel);
	AMQP_VERIFY_CONNECTION(connection, "Could not get messages from queue.");
	
	/* Set the QOS for this channel to match the max_messages */
	amqp_basic_qos(
		connection->connection_resource->connection_state,
		channel->channel_id,
		0,						/* prefetch window size */
		0,						/* prefetch message count */
		0						/* global flag */
	);
	
	/* Dont set the auto_ack flag. We are going to not acknowledge the message here, and then, when processed, we will check the  flag and acknowledge at the time. */
	amqp_basic_consume(
		connection->connection_resource->connection_state,
		channel->channel_id,
		amqp_cstring_bytes(queue->name),
		AMQP_EMPTY_BYTES,					/* Consume tag */
		(AMQP_NOLOCAL & flags) ? 1 : 0, 	/* No local */
		0,									/* no_ack, aka AUTOACK */
		queue->exclusive,
		AMQP_EMPTY_TABLE
	);
	
	/* verify there are no errors before grabbing the messages */
	res = (amqp_rpc_reply_t)amqp_get_rpc_reply(connection->connection_resource->connection_state);
	if (res.reply_type != AMQP_RESPONSE_NORMAL) {
		channel->is_connected = 0;
		char str[256];
		char ** pstr = (char **) &str;
		amqp_error(res, pstr);
		zend_throw_exception(amqp_queue_exception_class_entry, *pstr, 0 TSRMLS_CC);
		return;
	}
	
	amqp_basic_consume_ok_t *r = (amqp_basic_consume_ok_t *) res.reply.decoded;

	memcpy(queue->consumer_tag, r->consumer_tag.bytes, r->consumer_tag.len);
	queue->consumer_tag_len = r->consumer_tag.len;

	amqp_frame_t frame;
	int result;
	size_t body_received;
	size_t body_target;
	int i;
	array_init(return_value);
	char *buf = NULL;
	long last_delivery_tag;
	
	for (i = 0; i < max_messages; i++) {
	
		amqp_maybe_release_buffers(connection->connection_resource->connection_state);
			
		/* if we have met the minimum number of messages, check to see if there are messages left */
		if (i >= min_messages) {
			/* see if there are messages in the queue */ 
			amqp_bytes_t amqp_name;
			amqp_name = (amqp_bytes_t) {queue->name_len, queue->name};
			amqp_table_t *arguments = convert_zval_to_arguments(queue->arguments);

			amqp_queue_declare_ok_t *r = amqp_queue_declare(
				connection->connection_resource->connection_state,
				channel->channel_id,
				amqp_name,
				queue->passive,
				queue->durable,
				queue->exclusive,
				queue->auto_delete,
				*arguments
			);
			
			AMQP_EFREE_ARGUMENTS(arguments);
		
			/* Verify that we got a response: */
			if (!r) {
				zend_throw_exception(amqp_queue_exception_class_entry, "Could not get messages, failed to read from queue.", 0 TSRMLS_CC);
				return;
			}
			
			int messages_in_queue = r->message_count;
								
			/* see if there are frames enqueued */
			amqp_boolean_t frames = amqp_frames_enqueued(connection->connection_resource->connection_state);
			
			/* see if there is any unread data in the buffer */
			amqp_boolean_t buffer = amqp_data_in_buffer(connection->connection_resource->connection_state);
			
			if (!messages_in_queue && !frames && !buffer) {
				break;
			}
		}
	
		/* get next frame from the queue (blocks) */
		result = amqp_simple_wait_frame(connection->connection_resource->connection_state, &frame);
			
		/* check frame validity */
		if (result < 0) {
			return;
		}
		if (frame.frame_type != AMQP_FRAME_METHOD) {
			continue;
		}
		if (frame.payload.method.id != AMQP_BASIC_DELIVER_METHOD) {
			continue;
		}

		/* initialize message array */
		zval *message;
		MAKE_STD_ZVAL(message);
		array_init(message);

		/* get message metadata */
		amqp_basic_deliver_t * delivery = (amqp_basic_deliver_t *) frame.payload.method.decoded;
	
		add_assoc_stringl_ex(message,	"consumer_tag", 13, delivery->consumer_tag.bytes, 	delivery->consumer_tag.len, 1);
		add_assoc_long_ex(message,		"delivery_tag", 13, delivery->delivery_tag);
		add_assoc_bool_ex(message,		"redelivered", 	12, delivery->redelivered);
		add_assoc_stringl_ex(message,	"routing_key", 	12, delivery->routing_key.bytes, 	delivery->routing_key.len, 1);
		add_assoc_stringl_ex(message,	"exchange", 	9, 	delivery->exchange.bytes, 		delivery->exchange.len, 1);			
		
		/* Copy the delivery tag to our higher scoper storage layer so we can ack everything up to the last delivery tag */
		last_delivery_tag = delivery->delivery_tag;

		/* get header frame (blocks) */
		result = amqp_simple_wait_frame(connection->connection_resource->connection_state, &frame);
		if (result < 0) {
			zend_throw_exception(amqp_queue_exception_class_entry, "The returned read frame is invalid.", 0 TSRMLS_CC);
			return;
		}

		if (frame.frame_type != AMQP_FRAME_HEADER) {
			zend_throw_exception(amqp_queue_exception_class_entry, "The returned frame type is invalid.", 0 TSRMLS_CC);
			return;
		}
		
		amqp_basic_properties_t * p = (amqp_basic_properties_t *) frame.payload.properties.decoded;

		/*** REMOVED FLAG CHECKING ***/
	
		body_target = frame.payload.properties.body_size;
		body_received = 0;
		
		buf = (char*) emalloc(FRAME_MAX);
		if (!buf) {
			zend_throw_exception(zend_exception_get_default(TSRMLS_C), "Out of memory (malloc)" ,0 TSRMLS_CC);   
			return;
		}
	
		/* resize buffer if necessary */
		if (body_target > buf_max) {
			int count_buf = body_target / FRAME_MAX +1;
			int resize = count_buf * FRAME_MAX;
			buf_max = resize;
			pbuf = erealloc(buf, resize);
			if (!pbuf) {
				efree(buf);
				zend_throw_exception(zend_exception_get_default(TSRMLS_C), "The memory is out (realloc)", 0 TSRMLS_CC);
				return;
			}
			buf = pbuf; 
		}
	
		pbuf = buf;
		while (body_received < body_target) {
			result = amqp_simple_wait_frame(connection->connection_resource->connection_state, &frame);
			if (result < 0) {
				break;
			}

			if (frame.frame_type != AMQP_FRAME_BODY) {
				zend_throw_exception(amqp_queue_exception_class_entry, "The returned frame has no body.", 0 TSRMLS_CC);
				return;
			}

			memcpy(pbuf, frame.payload.body_fragment.bytes, frame.payload.body_fragment.len);
			body_received += frame.payload.body_fragment.len;
			pbuf += frame.payload.body_fragment.len;

		} /* end while	*/
	
		/* add message body to message */
		add_assoc_stringl_ex(message, "message_body", sizeof("message_body"), buf, body_target, 1);
			
		/* add message to return value */
		add_index_zval(return_value, i, message);
			
		efree(buf);
	}
	
	/* If we have chosen to auto_ack, meaning that we do not need to acknowledge at a later date, acknowledge now */
	if (flags & AMQP_AUTOACK) {
			amqp_basic_ack(
			connection->connection_resource->connection_state,
			channel->channel_id,
			last_delivery_tag,
			1						/* Multiple flag - Set to 1 will acknowledge up to and including the above delivery tag */
		);
	}
	
	/* Set the QOS back to what the user requested at the beginning */
	amqp_basic_qos(
		connection->connection_resource->connection_state,
		channel->channel_id,
		channel->prefetch_size,		/* prefetch window size */
		channel->prefetch_count,	/* prefetch message count */
		0							/* global flag */
	);
}
/* }}} */