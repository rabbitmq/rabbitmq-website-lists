diff --git a/src/rabbit_exchange.erl b/src/rabbit_exchange.erl
index 925c335..2271329 100644
--- a/src/rabbit_exchange.erl
+++ b/src/rabbit_exchange.erl
@@ -52,6 +52,7 @@
 -import(lists).
 -import(qlc).
 -import(regexp).
+-import(random).
 
 %%----------------------------------------------------------------------------
 
@@ -145,6 +146,8 @@ check_type(<<"direct">>) ->
     direct;
 check_type(<<"topic">>) ->
     topic;
+check_type(<<"srand">>) ->
+    srand;
 check_type(T) ->
     rabbit_misc:protocol_error(
       command_invalid, "invalid exchange type '~s'", [T]).
@@ -252,28 +255,54 @@ route(#exchange{name = Name, type = topic}, RoutingKey) ->
                         topic_matches(BindingKey, RoutingKey)]
       end);
 
+route(X = #exchange{type = srand}, RoutingKey) ->
+    F = fun () ->
+            Qs = case route_internal_with(X, RoutingKey, fun mnesia:select/2) of
+                     [] -> [select_queue(X, RoutingKey)];
+                     Queues -> Queues
+                 end,
+            lookup_qpids_with(Qs, fun mnesia:read/1)
+        end,
+    {atomic, QPid} = mnesia:transaction(F),
+    QPid;
+
 route(X = #exchange{type = fanout}, _) ->
-    route_internal(X, '_');
+    lookup_qpids(route_internal(X, '_'));
 
 route(X = #exchange{type = direct}, RoutingKey) ->
-    route_internal(X, RoutingKey).
+    lookup_qpids(route_internal(X, RoutingKey)).
+
+
+route_internal(Exchange, RoutingKey) ->
+    route_internal_with(Exchange, RoutingKey, fun mnesia:dirty_select/2).
 
-route_internal(#exchange{name = Name}, RoutingKey) ->
+route_internal_with(#exchange{name = Name}, RoutingKey, SelectFn) ->
     MatchHead = #route{binding = #binding{exchange_name = Name,
                                           queue_name = '$1',
                                           key = RoutingKey,
                                           _ = '_'}},
-    lookup_qpids(mnesia:dirty_select(route, [{MatchHead, [], ['$1']}])).
+    SelectFn(route, [{MatchHead, [], ['$1']}]).
 
 lookup_qpids(Queues) ->
+    lookup_qpids_with(Queues, fun mnesia:dirty_read/1).
+
+lookup_qpids_with(Queues, ReadFn) ->
     sets:fold(
       fun(Key, Acc) ->
-              case mnesia:dirty_read({amqqueue, Key}) of
+              case ReadFn({amqqueue, Key}) of
                   [#amqqueue{pid = QPid}] -> [QPid | Acc];
                   []                      -> Acc
               end
       end, [], sets:from_list(Queues)).
 
+select_queue(X = #exchange{name = Name}, RoutingKey) ->
+    case route_internal_with(X, '_', fun mnesia:select/2) of
+        [] -> [];
+        Queues -> Q = lists:nth(random:uniform(length(Queues)), Queues),
+                  add_binding(Name, Q, RoutingKey, []),
+                  Q
+    end.
+
 %% TODO: Should all of the route and binding management not be
 %% refactored to its own module, especially seeing as unbind will have
 %% to be implemented for 0.91 ?
