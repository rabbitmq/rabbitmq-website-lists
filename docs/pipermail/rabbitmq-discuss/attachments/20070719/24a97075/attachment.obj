diff -r af848798cc65 include/rabbit.hrl
--- a/include/rabbit.hrl	Sat Jun 16 13:12:20 2007 +0100
+++ b/include/rabbit.hrl	Thu Jul 19 23:11:19 2007 +0100
@@ -29,7 +29,7 @@
 -record(realm, {name, exchanges, queues}).
 -record(user_realm, {username, realm, ticket_pattern}).
 
--record(connection, {user, timeout_sec, heartbeat_sender_pid, frame_max, vhost}).
+-record(connection, {user, timeout_sec, heartbeat_sender_pid, frame_max, vhost, reader_pid}).
 
 -record(content, {class_id,
 		  properties, %% either 'none', or a decoded record/tuple
diff -r af848798cc65 src/amqp_client.erl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/amqp_client.erl	Thu Jul 19 23:11:19 2007 +0100
@@ -0,0 +1,195 @@
+-module(amqp_client).
+
+-include("rabbit.hrl").
+-include("rabbit_framing.hrl").
+
+-behaviour(gen_server).
+
+-export([start_link/0, stop/0]).
+-export([init/1, terminate/2, code_change/3, handle_call/3, handle_cast/2, handle_info/2]).
+-export([open_channel/2]).
+-export([access_request/2]).
+
+-define(Username, username).
+-define(Password, password).
+-define(VHostPath, vhostpath).
+-define(Ticket, ticket).
+
+-record(amq_channel, {number, pid}).
+
+%---------------------------------------------------------------------------
+% Start / Stop functions
+%---------------------------------------------------------------------------
+
+start_link() -> 
+	gen_server:start_link({local, ?MODULE}, ?MODULE, [<<"admin">>,<<"changeit">>, <<"localhost">>], []).
+
+stop() -> 
+    %% TODO implement
+    ok.
+
+%---------------------------------------------------------------------------
+% API Methods
+%---------------------------------------------------------------------------
+
+open_channel(Channel, OutOfBand) ->
+    gen_server:cast(?MODULE, {open_channel, Channel, OutOfBand}).
+
+access_request(Channel,Realm) ->
+    RealmNameBin =
+    	case is_binary(Realm) of
+            true ->
+                Realm;
+            _ ->
+                list_to_binary(Realm)
+        end,
+    Access = #'access.request'{	realm = RealmNameBin,
+					  			exclusive = false,
+								passive = true,
+								active = true,
+								write = true,
+								read = true},
+    gen_server:cast(?MODULE, {access_request, Access, Channel, Realm}).
+
+%---------------------------------------------------------------------------
+% Internal functions
+%---------------------------------------------------------------------------
+
+getVHostPath(Table) ->
+    [{_,VHostPath}] = ets:lookup(Table, ?VHostPath),
+    VHostPath.
+
+getUsername(Table) ->
+	[{_,User}] = ets:lookup(Table, ?Username),
+    User.
+
+getPassword(Table) ->
+	[{_,Password}] = ets:lookup(Table, ?Password),
+    Password.
+
+getChannel(Channel, Table) ->
+	[{_,Chan}] = ets:lookup(Table, Channel),
+    Chan.
+
+getTicket(Table) ->
+	[{_,Ticket}] = ets:lookup(Table, ?Ticket),
+    Ticket.
+
+%---------------------------------------------------------------------------
+% AMQP message handling
+%---------------------------------------------------------------------------
+
+%% connection.start
+amqp_handle(Peer, 
+                #'connection.start'{version_major = MajorVersion,
+									version_minor = MinorVersion,
+									server_properties = Properties,
+									mechanisms = Mechansims,
+									locales = Locales }, Table) ->                                    
+	StartOk = #'connection.start_ok'{
+		client_properties = [
+                            {<<"product">>,<<"Erlang-AMQC">>},
+                            {<<"version">>,<<"0.1">>},
+                            {<<"platform">>,<<"Erlang">>}                                                                               
+							], 
+        mechanism = <<"AMQPLAIN">>, 
+        response = [
+                    {<<"LOGIN">>, getUsername(Table) },
+                    {<<"PASSWORD">>, getPassword(Table) }
+                    ], 
+        locale = <<"en_US">>                                                       
+	},                                                       
+    Peer ! {self(), StartOk };
+
+%% connection.tune                                                                      
+amqp_handle(Peer, #'connection.tune'{channel_max = ChannelMax}, Table ) ->			     
+	TuneOk = #'connection.tune_ok'{channel_max = ChannelMax},                                                       
+    Peer ! {self(), TuneOk },
+    %% This is something where I don't understand the protocol,
+    %% What happens if the following command reaches the server before the tune ok?
+    %% Or doesn't get sent at all?       
+    ConnectionOpen = #'connection.open'{virtual_host = getVHostPath(Table) },        
+    Peer ! {self(), ConnectionOpen};                                
+
+%% connection.open_ok
+amqp_handle(Peer, {Channel, #'connection.open_ok'{known_hosts = KnownHosts} }, Table ) ->
+    ok;
+                                                                                     
+%% connection.close_ok    
+amqp_handle(Peer, {Channel, #'connection.close_ok'{} }, Table ) ->
+    ok;
+
+                                                                                                                 
+%% access.request_ok
+amqp_handle(Peer, #'access.request_ok'{ticket = NextTicket}, Table ) ->
+    ets:insert(Table, {?Ticket, NextTicket}),
+    io:format("Received ticket, ~p~n", [NextTicket] );                                                                                                                                                                                                                                                      
+         
+%% Anything else                                                                                                                  
+amqp_handle(Peer, Message, Table ) ->
+    exit({amqp_client, unhandled_message , Message}).
+
+%% Sends AMQP messages
+amqp_send(Method, Channel, Table) ->
+	Chan = getChannel(Channel, Table),
+    io:format("ch open Sending to ~p~n",[Chan#amq_channel.pid]),
+    Chan#amq_channel.pid ! { self(), Method }.
+
+amqp_send(Method, Content, Channel, Table) ->
+	Chan = getChannel(Channel, Table),
+    io:format("ch open Sending to ~p~n",[Chan#amq_channel.pid]),
+    Chan#amq_channel.pid ! { method, Method, Content }.    
+    
+
+%---------------------------------------------------------------------------
+% gen_server callbacks
+%---------------------------------------------------------------------------
+
+init([User,Pass, VHostPath]) ->
+	
+    %% This direct call to rabbit's API should be abstracted out or parameterized away
+    gen_server:call(rabbit, {handshake, <<"AMQP",1,1,?PROTOCOL_VERSION_MAJOR,?PROTOCOL_VERSION_MINOR>>} ),
+    
+    Table = ets:new(?MODULE,[]),
+    ets:insert(Table, {?Username, User} ),
+    ets:insert(Table, {?Password, Pass} ),
+    ets:insert(Table, {?VHostPath, VHostPath} ),
+    {ok, Table}.
+
+terminate(_Reason, State) ->
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    State.
+
+handle_call(_Request, _From, State) ->
+    {reply, ignored, State}.
+
+%% Access a realm                                                  
+handle_cast({ access_request, Method, Channel, Realm}, Table) ->
+    amqp_send(#'channel.open'{}, Channel, Table),
+    %% block on receiving a channel.open_ok to keep the serialize the call sequence
+    receive
+	{Sender, {Channel, #'channel.open_ok'{} } }	->
+        io:format("Received ch open ok~n"),
+     	ok
+    end,                                   
+	amqp_send(Method,<<>>,Channel, Table),	                                                     
+    {noreply, Table}; 
+                                                         
+%% Create and open a channel
+handle_cast( {open_channel, Channel, OutOfBand} , Table) ->
+    UserVHost = { getUsername(Table), getVHostPath(Table) },
+    %% This direct call to rabbit's API should be abstracted out or parameterized away
+    ChPid = gen_server:call(rabbit,{ open_channel, UserVHost , {Channel, OutOfBand} }),
+    Chan = #amq_channel{number = Channel, pid= ChPid},
+    ets:insert(Table, {Channel, Chan}),
+    {noreply, Table};                                                                                                           
+
+handle_cast(_Request, State) ->
+    {noreply, State}.
+
+handle_info( {Peer, Message}, Table) ->
+    io:format("Rec'd ---> ~p~n", [Message]),
+    amqp_handle(Peer, Message, Table),
+    {noreply, Table}.    
diff -r af848798cc65 src/rabbit.erl
--- a/src/rabbit.erl	Sat Jun 16 13:12:20 2007 +0100
+++ b/src/rabbit.erl	Thu Jul 19 23:11:19 2007 +0100
@@ -73,7 +73,7 @@ start(normal, []) ->
     end,
     {ok, Host} = application:get_env(listen_host),
     {ok, Port} = application:get_env(listen_port),
-    gen_server:start_link(?MODULE, [Host, Port], []).
+    gen_server:start_link({local, rabbit},?MODULE, [Host, Port], []).
 
 stop(_State) ->
     ok.
@@ -223,8 +223,14 @@ code_change(_OldVsn, State, _Extra) ->
 code_change(_OldVsn, State, _Extra) ->
     State.
 
-handle_call(_Request, _From, State) ->
-    {reply, ignored, State}.
+handle_call({Type, Request}, {Pid,Ref}, State) ->
+    spawn(rabbit_reader, handle_input, [Type, Request, Pid]),
+    {reply, ignored, State};
+
+handle_call({Type, {User,VHost}, Request}, {Pid,Ref}, State) ->
+    Connection = #connection{user = #user{username = User} , vhost = VHost, reader_pid = Pid},
+    ChPid = rabbit_reader:handle_input(Type, Request, Connection),           
+    {reply, ChPid, State}.
 
 handle_cast(_Request, State) ->
     {noreply, State}.
diff -r af848798cc65 src/rabbit_channel.erl
--- a/src/rabbit_channel.erl	Sat Jun 16 13:12:20 2007 +0100
+++ b/src/rabbit_channel.erl	Thu Jul 19 23:11:19 2007 +0100
@@ -25,7 +25,7 @@
 -include("rabbit.hrl").
 
 -export([read_frame/0, read_method/0, read_method/1]).
--export([start/4]).
+-export([start/3,start/4]).
 
 read_frame() ->
     receive
@@ -96,6 +96,28 @@ read_method(ExpectedMethodName) ->
 	     virtual_host,
 	     most_recently_declared_queue,
 	     next_ticket}).
+
+start(Connection, Channel, Timeout) ->
+    ReaderPid = Connection#connection.reader_pid,
+    receive
+	{Sender, #'channel.close_ok'{}} ->
+    	% We are required by the spec to ignore unsolicited close-ok messages.
+	    exit(normal);                                        
+    {Sender, #'channel.open'{}} ->
+        rabbit_log:info("~p: Opening channel ~p~n", [ReaderPid, Channel]),
+    	Sender ! {self(), {Channel, #'channel.open_ok'{} } },    
+        Tx0 = rabbit_transaction:start(),     
+        Tx1 = rabbit_transaction:set_writer_pid(Tx0, self()),
+        mainloop_without_framing(#ch{ channel = Channel,
+			  tx = Tx1,
+			  reader_pid = ReaderPid,
+			  writer_pid = ReaderPid,
+			  username = (Connection#connection.user)#user.username,
+			  virtual_host = Connection#connection.vhost,
+			  most_recently_declared_queue = <<>>,
+			  next_ticket = 101
+			 })                 
+    end.        	                                          
 
 start(ReaderPid, Channel, Sock, Connection) ->
     case read_method() of
@@ -124,8 +146,15 @@ send(#ch{ writer_pid = W }, MethodRecord
 send(#ch{ writer_pid = W }, MethodRecord) ->
     ok = rabbit_writer:send_command(W, MethodRecord).
 
-%%send(#ch{ writer_pid = W }, MethodRecord, Content) ->
-%%    ok = rabbit_writer:send_command(W, MethodRecord, Content).
+mainloop_without_framing(State) ->
+    receive
+	{method, MethodRecord, Content} ->
+	    State1 = handle_method(MethodRecord, Content, State),
+	    mainloop_without_framing(State1);
+	Other ->
+	    rabbit_log:error("Unexpected ch~p content: ~p~n", [State#ch.channel, Other]),
+	    mainloop_without_framing(State)
+    end.
 
 mainloop(State) ->
     case read_frame() of
diff -r af848798cc65 src/rabbit_channel0.erl
--- a/src/rabbit_channel0.erl	Sat Jun 16 13:12:20 2007 +0100
+++ b/src/rabbit_channel0.erl	Thu Jul 19 23:11:19 2007 +0100
@@ -24,7 +24,13 @@
 -include("rabbit_framing.hrl").
 -include("rabbit.hrl").
 
--export([start/4]).
+-export([start/3,start/4]).
+
+start(ReaderPid, ChannelNum, Timeout) ->
+    {ok, UserDetails} = do_connection_start(ReaderPid, Timeout),
+    ok = do_connection_tune(ReaderPid, Timeout),
+    {ok, VHostPath} = do_connection_open(ReaderPid, UserDetails, Timeout),
+    wait_for_close(ReaderPid).
 
 start(ReaderPid, _ChannelNum, Sock, InitialConnection) ->
     {ok, UserDetails} = do_connection_start(Sock),
@@ -61,6 +67,44 @@ read_method(Expected) ->
     ?LOGMESSAGE(in, 0, M, C),
     Result.
 
+connection_start_properties() ->
+    #'connection.start'{version_major = 8,
+				version_minor = 1,
+				server_properties =
+				[{<<"product">>, longstr, <<"RabbitMQ">>},
+				 {<<"version">>, longstr, <<"1.0">>},
+				 {<<"platform">>, longstr, <<"Erlang/OTP">>},
+				 {<<"copyright">>, longstr, <<"LShift Ltd">>}],
+				mechanisms = <<"PLAIN">>,
+				locales = <<"en_US">> }.
+
+connection_tune_properties() ->
+    #'connection.tune'{channel_max = 0,
+			       frame_max = 131072, %% set to zero once QPid fix their negotiation
+			       heartbeat = 0 }.
+
+connection_ok_properties() ->
+	#'connection.open_ok'{known_hosts = <<>>}.
+
+do_connection_start(Pid, Timeout) when is_pid(Pid) ->
+    Pid ! {self(), connection_start_properties()},
+	receive
+	{Sender, #'connection.start_ok'{mechanism = Mechanism, response = LoginTable}} ->
+        case {	lists:keysearch(<<"LOGIN">>, 1, LoginTable),
+	  			lists:keysearch(<<"PASSWORD">>, 1, LoginTable)} of
+			{{value, {_, UsernameBin}},
+	 		{value, {_, PasswordBin}}} ->
+	    		{ok, _U} = rabbit_access_control:user_pass_login(UsernameBin, PasswordBin);
+			_ ->
+	    		rabbit_misc:die(access_refused)
+    	end;
+    _ ->
+        rabbit_misc:die(protocol_mismatch)
+    after Timeout ->
+        ?LOGDEBUG("Connection start: Pid ~p timing out~n",[Pid]),
+        rabbit_misc:die(client_timeout)  
+    end.
+
 do_connection_start(Sock) ->
     ok = rabbit_writer:internal_send_command
 	   (Sock, 0,
@@ -76,7 +120,20 @@ do_connection_start(Sock) ->
     {ok, #'connection.start_ok'{mechanism = Mechanism, response = Response}, _} =
 	read_method('connection.start_ok'),
     {ok, _U} = rabbit_access_control:check_login(Mechanism, Response).
-
+                                    
+do_connection_tune(Pid, Timeout) when is_pid(Pid) ->
+    Pid ! { self(), connection_tune_properties() } ,
+    receive
+	{Sender, #'connection.tune_ok'{channel_max = ChannelMax} } ->
+    	rabbit_log:info("Tuned channel_max = ~p.~n", [ChannelMax]);    
+    _ ->
+        rabbit_misc:die(protocol_mismatch)
+    after Timeout ->
+        ?LOGDEBUG("Connection start: Pid ~p timing out~n",[Pid]),
+        rabbit_misc:die(client_timeout)  
+    end,
+    ok.           
+                                                                             
 do_connection_tune(Sock) ->
     ok = rabbit_writer:internal_send_command
 	   (Sock, 0,
@@ -99,6 +156,25 @@ do_connection_open(Sock, UserDetails) ->
     ok = rabbit_writer:internal_send_command(Sock, 0, #'connection.open_ok'{known_hosts = <<>>}),
     {ok, VHostPath}.
 
+do_connection_open(Pid, UserDetails, Timeout) when is_pid(Pid) ->
+    receive
+	{Sender, #'connection.open'{virtual_host = VHostPath} } ->
+    	rabbit_access_control:check_vhost_access(UserDetails, VHostPath),
+        Pid ! { self(), {0, connection_ok_properties() } },
+        {ok, VHostPath};
+    _ ->
+    	rabbit_misc:die(protocol_mismatch)            
+    after Timeout ->
+    	?LOGDEBUG("Connection start: Pid ~p timing out~n",[Pid]),
+        rabbit_misc:die(client_timeout)   
+    end.
+
+wait_for_close(Pid) when is_pid(Pid) ->
+    receive
+    {Sender,'connection.close'} ->
+        Sender ! { self(), {0 , #'connection.close_ok'{} } }
+	end;
+
 wait_for_close(Sock) ->
     {ok, _, _} = read_method('connection.close'),
-    ok = rabbit_writer:internal_send_command(Sock, 0, #'connection.close_ok'{}).
+    ok = rabbit_writer:internal_send_command(Sock, {0, #'connection.close_ok'{}}).
diff -r af848798cc65 src/rabbit_reader.erl
--- a/src/rabbit_reader.erl	Sat Jun 16 13:12:20 2007 +0100
+++ b/src/rabbit_reader.erl	Thu Jul 19 23:11:19 2007 +0100
@@ -26,6 +26,7 @@
 
 -export([accept_and_start/1]).
 -export([init/1, start_connection/1]).
+-export([handle_input/3]).
 -export([lookup_amqp_exception/1]).
 
 -import(gen_tcp).
@@ -225,18 +226,30 @@ handle_input({frame_payload, Type, Chann
     end;
 
 handle_input(handshake,
+	     	<<"AMQP",1,1,?PROTOCOL_VERSION_MAJOR,?PROTOCOL_VERSION_MINOR>>,                                                                    
+          	Pid) when is_pid(Pid)-> 
+    {State, ChPid} = open_channel(0, rabbit_channel0, start, Pid);
+                                                                                        
+handle_input(handshake,
 	     <<"AMQP",1,1,?PROTOCOL_VERSION_MAJOR,?PROTOCOL_VERSION_MINOR>>,
 	     State) ->
     {State1, _ChPid} = open_channel(0, rabbit_channel0, start, State),
     switch_callback(State1#v1{connection =
 			        (State1#v1.connection)#connection{timeout_sec = ?NORMAL_TIMEOUT},
-			      connection_state = starting}, frame_header, 7);
-
+			      connection_state = starting}, frame_header, 7);              
+
+handle_input(open_channel, {Channel, OutOfBand}, Connection)->
+    {State, ChPid} = open_channel(Connection, Channel, rabbit_channel, start),
+    ChPid;
+
+handle_input(access_request, {Channel, Realm}, Connection)->
+    {State, ChPid} = open_channel(Connection, Channel, rabbit_channel, start);                                                                 
+              
 handle_input(handshake, Other, #v1{sock = Sock}) ->
     rabbit_log:error("Bad header received: ~p~n", [Other]),
     ok = gen_tcp:send(Sock, <<"AMQP",1,1,?PROTOCOL_VERSION_MAJOR,?PROTOCOL_VERSION_MINOR>>),
     exit(reader_bad_header);
-
+                                                                                            
 handle_input(Callback, timeout,
 	     #v1{connection = #connection{timeout_sec = TimeoutSec}}) ->
     rabbit_log:error("Reader timeout (~p s) in state ~p~n", [TimeoutSec, Callback]),
@@ -247,11 +260,24 @@ handle_input(Callback, Data, _State) ->
     rabbit_log:error("Bad input to reader in state ~p: ~p~n", [Callback, Data]),
     exit(reader_bad_input).
 
+open_channel(Channel, Mod, Fun, State) when is_pid(State) ->
+    ChPid = spawn_link(Mod, Fun, [State, Channel, ?NORMAL_TIMEOUT]),
+    open_channel_internal(Channel,ChPid),
+    {State, ChPid};
+
+open_channel(Connection, Channel, Mod, Fun) when is_integer(Channel) ->
+    ChPid = spawn_link(Mod, Fun, [Connection, Channel, ?NORMAL_TIMEOUT]),
+    open_channel_internal(Channel,ChPid),
+    {Connection, ChPid};
+
 open_channel(Channel, Mod, Fun, State) ->
     ChPid = spawn_link(Mod, Fun, [self(), Channel, State#v1.sock, State#v1.connection]),
+    open_channel_internal(Channel,ChPid),
+    {State,ChPid}.                                     
+                                     
+open_channel_internal(Channel, ChPid) ->
     put({channel, Channel}, {chpid, ChPid}),
-    put({chpid, ChPid}, {channel, Channel}),
-    {State, ChPid}.
+    put({chpid, ChPid}, {channel, Channel}).
 
 %---------------------------------------------------------------------------
 