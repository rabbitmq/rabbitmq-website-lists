diff -r 277ec3f5b631 librabbitmq/amqp.h
--- a/librabbitmq/amqp.h	Mon Oct 19 15:17:15 2009 +0100
+++ b/librabbitmq/amqp.h	Sat Nov 14 13:36:22 2009 -0500
@@ -223,8 +223,6 @@
 				   int heartbeat,
 				   amqp_sasl_method_enum sasl_method, ...);
 
-extern amqp_rpc_reply_t amqp_rpc_reply;
-
 extern struct amqp_channel_open_ok_t_ *amqp_channel_open(amqp_connection_state_t state,
 							 amqp_channel_t channel);
 
@@ -311,7 +309,7 @@
 /*
  * Expose amqp_rpc_reply to libraries.
  */
-extern amqp_rpc_reply_t amqp_get_rpc_reply(void);
+extern amqp_rpc_reply_t *amqp_get_rpc_reply(void);
 
 #ifdef __cplusplus
 }
diff -r 277ec3f5b631 librabbitmq/amqp_api.c
--- a/librabbitmq/amqp_api.c	Mon Oct 19 15:17:15 2009 +0100
+++ b/librabbitmq/amqp_api.c	Sat Nov 14 13:36:22 2009 -0500
@@ -3,6 +3,9 @@
 #include <string.h>
 #include <stdint.h>
 #include <errno.h>
+#ifndef DISABLE_THREADS
+#include <pthread.h>
+#endif
 
 #include "amqp.h"
 #include "amqp_framing.h"
@@ -10,17 +13,17 @@
 
 #include <assert.h>
 
-amqp_rpc_reply_t amqp_rpc_reply;
-
 #define RPC_REPLY(replytype)					\
-  (amqp_rpc_reply.reply_type == AMQP_RESPONSE_NORMAL		\
-   ? (replytype *) amqp_rpc_reply.reply.decoded	\
+  (amqp_rpc_reply->reply_type == AMQP_RESPONSE_NORMAL		\
+   ? (replytype *) amqp_rpc_reply->reply.decoded	\
    : NULL)
 
 amqp_channel_open_ok_t *amqp_channel_open(amqp_connection_state_t state,
 					  amqp_channel_t channel)
 {
-  amqp_rpc_reply =
+  amqp_rpc_reply_t *amqp_rpc_reply;
+  amqp_rpc_reply = amqp_get_rpc_reply();
+  *amqp_rpc_reply =
     AMQP_SIMPLE_RPC(state, channel, CHANNEL, OPEN, OPEN_OK,
 		    amqp_channel_open_t,
 		    AMQP_EMPTY_BYTES);
@@ -118,7 +121,9 @@
 						  amqp_boolean_t auto_delete,
 						  amqp_table_t arguments)
 {
-  amqp_rpc_reply =
+  amqp_rpc_reply_t *amqp_rpc_reply;
+  amqp_rpc_reply = amqp_get_rpc_reply();
+  *amqp_rpc_reply =
     AMQP_SIMPLE_RPC(state, channel, EXCHANGE, DECLARE, DECLARE_OK,
 		    amqp_exchange_declare_t,
 		    0, exchange, type, passive, durable, auto_delete, 0, 0, arguments);
@@ -134,7 +139,9 @@
 					    amqp_boolean_t auto_delete,
 					    amqp_table_t arguments)
 {
-  amqp_rpc_reply =
+  amqp_rpc_reply_t *amqp_rpc_reply;
+  amqp_rpc_reply = amqp_get_rpc_reply();
+  *amqp_rpc_reply =
     AMQP_SIMPLE_RPC(state, channel, QUEUE, DECLARE, DECLARE_OK,
 		    amqp_queue_declare_t,
 		    0, queue, passive, durable, exclusive, auto_delete, 0, arguments);
@@ -148,7 +155,9 @@
 				      amqp_bytes_t routing_key,
 				      amqp_table_t arguments)
 {
-  amqp_rpc_reply =
+  amqp_rpc_reply_t *amqp_rpc_reply;
+  amqp_rpc_reply = amqp_get_rpc_reply();
+  *amqp_rpc_reply =
     AMQP_SIMPLE_RPC(state, channel, QUEUE, BIND, BIND_OK,
 		    amqp_queue_bind_t,
 		    0, queue, exchange, routing_key, 0, arguments);
@@ -162,7 +171,9 @@
 					  amqp_bytes_t binding_key,
 					  amqp_table_t arguments)
 {
-  amqp_rpc_reply =
+  amqp_rpc_reply_t *amqp_rpc_reply;
+  amqp_rpc_reply = amqp_get_rpc_reply();
+  *amqp_rpc_reply =
     AMQP_SIMPLE_RPC(state, channel, QUEUE, UNBIND, UNBIND_OK,
 		    amqp_queue_unbind_t,
 		    0, queue, exchange, binding_key, arguments);
@@ -177,7 +188,9 @@
 					    amqp_boolean_t no_ack,
 					    amqp_boolean_t exclusive)
 {
-  amqp_rpc_reply =
+  amqp_rpc_reply_t *amqp_rpc_reply;
+  amqp_rpc_reply = amqp_get_rpc_reply();
+  *amqp_rpc_reply =
     AMQP_SIMPLE_RPC(state, channel, BASIC, CONSUME, CONSUME_OK,
 		    amqp_basic_consume_t,
 		    0, queue, consumer_tag, no_local, no_ack, exclusive, 0);
@@ -203,7 +216,9 @@
 						amqp_bytes_t queue,
 						amqp_boolean_t no_wait)
 {
-  amqp_rpc_reply = AMQP_SIMPLE_RPC(state, channel, QUEUE, PURGE, PURGE_OK,
+  amqp_rpc_reply_t *amqp_rpc_reply;
+  amqp_rpc_reply = amqp_get_rpc_reply();
+  *amqp_rpc_reply = AMQP_SIMPLE_RPC(state, channel, QUEUE, PURGE, PURGE_OK,
 			amqp_queue_purge_t, channel, queue, no_wait);
   return RPC_REPLY(amqp_queue_purge_ok_t);
 }
@@ -216,17 +231,41 @@
 	amqp_method_number_t replies[] = { AMQP_BASIC_GET_OK_METHOD,
 					   AMQP_BASIC_GET_EMPTY_METHOD,
 					   0 };
-	amqp_rpc_reply =
+	amqp_rpc_reply_t *amqp_rpc_reply;
+	amqp_rpc_reply = amqp_get_rpc_reply();
+	*amqp_rpc_reply =
 		AMQP_MULTIPLE_RESPONSE_RPC(state, channel, BASIC, GET, replies,
 			amqp_basic_get_t,
 			channel, queue, no_ack);
-	return amqp_rpc_reply;
+	return *amqp_rpc_reply;
 }
 
 /*
  * Expose amqp_rpc_reply to dynamically linked libraries
  */
-amqp_rpc_reply_t amqp_get_rpc_reply(void)
+amqp_rpc_reply_t *amqp_get_rpc_reply(void)
 {
-	return amqp_rpc_reply;
+#ifndef DISABLE_THREADS
+  static int initialized = 0;
+  static pthread_key_t reply_key;
+  static pthread_mutex_t init_mutex = PTHREAD_MUTEX_INITIALIZER;
+  amqp_rpc_reply_t *amqp_rpc_reply;
+  if(!initialized) {
+    pthread_mutex_lock(&init_mutex);
+    if(!initialized) {
+      pthread_key_create(&reply_key, free);
+      initialized = 1;
+    }
+    pthread_mutex_unlock(&init_mutex);
+  }
+  amqp_rpc_reply = (amqp_rpc_reply_t *)pthread_getspecific(reply_key);
+  if(!amqp_rpc_reply) {
+    amqp_rpc_reply = calloc(1, sizeof(*amqp_rpc_reply));
+    pthread_setspecific(reply_key, (void *)amqp_rpc_reply);
+  }
+  return amqp_rpc_reply;
+#else
+  static amqp_rpc_reply_t amqp_rpc_reply;
+  return &amqp_rpc_reply;
+#endif
 }
