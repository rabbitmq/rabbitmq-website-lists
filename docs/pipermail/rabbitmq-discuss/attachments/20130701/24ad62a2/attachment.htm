<tt>
&lt;div&nbsp;dir=&quot;ltr&quot;&gt;I&nbsp;am&nbsp;trying&nbsp;to&nbsp;implement&nbsp;the&nbsp;active-active&nbsp;High&nbsp;availability&nbsp;Queue&nbsp;and&nbsp;i&nbsp;have&nbsp;some&nbsp;issues&nbsp;in&nbsp;the&nbsp;implementation.&nbsp;The&nbsp;problem&nbsp;is&nbsp;when&nbsp;we&nbsp;consume&nbsp;messages&nbsp;from&nbsp;the&nbsp;Mirrored&nbsp;queue&nbsp;if&nbsp;any&nbsp;one&nbsp;of&nbsp;the&nbsp;node&nbsp;is&nbsp;down,&nbsp;we&nbsp;can&nbsp;able&nbsp;to&nbsp;consume&nbsp;the&nbsp;messages&nbsp;after&nbsp;the&nbsp;node&nbsp;failure.&nbsp;But&nbsp;the&nbsp;consumed&nbsp;messages&nbsp;after&nbsp;the&nbsp;node&nbsp;failure&nbsp;are&nbsp;still&nbsp;available&nbsp;in&nbsp;the&nbsp;rabbitmq&nbsp;console&nbsp;even&nbsp;after&nbsp;acking&nbsp;all&nbsp;of&nbsp;the&nbsp;messages.&lt;br&gt;<br>
&lt;br&gt;Some&nbsp;information&nbsp;about&nbsp;the&nbsp;overview&nbsp;of&nbsp;the&nbsp;configuration&nbsp;to&nbsp;test&nbsp;active-active&nbsp;queues&lt;br&gt;&lt;br&gt;I&nbsp;have&nbsp;NODE1&nbsp;in&nbsp;Host1&nbsp;and&nbsp;NODE2&nbsp;in&nbsp;Host2.&nbsp;Both&nbsp;of&nbsp;the&nbsp;nodes&nbsp;are&nbsp;in&nbsp;cluster.&nbsp;I&nbsp;have&nbsp;a&nbsp;Queue&nbsp;named&nbsp;TestQ&nbsp;in&nbsp;NODE1,&nbsp;since&nbsp;i&nbsp;have&nbsp;made&nbsp;this&nbsp;queue&nbsp;(TestQ)&nbsp;as&nbsp;Mirrored&nbsp;Queue&nbsp;through&nbsp;the&nbsp;policies&nbsp;it&nbsp;is&nbsp;available&nbsp;in&nbsp;Node2&nbsp;which&nbsp;is&nbsp;running&nbsp;in&nbsp;Host2.&lt;br&gt;<br>
&lt;br&gt;I&nbsp;am&nbsp;passing&nbsp;the&nbsp;array&nbsp;of&nbsp;Address(Host1,&nbsp;Host2)&nbsp;to&nbsp;get&nbsp;the&nbsp;connection&nbsp;in&nbsp;my&nbsp;consumer.&nbsp;the&nbsp;code&nbsp;snippet&nbsp;is&lt;br&gt;&lt;br&gt;Address&nbsp;address1&nbsp;=&nbsp;new&nbsp;Address(Host1,&nbsp;5672);&lt;br&gt;Address&nbsp;address2&nbsp;=&nbsp;new&nbsp;Address(Host2,&nbsp;5672);&lt;br&gt;&lt;br&gt;RabbitmqConsumer&nbsp;consumer&nbsp;=&nbsp;new&nbsp;RabbitmqConsumer(new&nbsp;Address[]{address1,&nbsp;address2},&nbsp;queue);&lt;br&gt;<br>
&lt;br&gt;While&nbsp;getting&nbsp;the&nbsp;connection,&nbsp;&lt;br&gt;Connection&nbsp;conn&nbsp;=&nbsp;connectionFactory.newConnection(addresses);&lt;br&gt;&lt;br&gt;My&nbsp;use&nbsp;case&nbsp;is&nbsp;as&nbsp;below.&lt;br&gt;&lt;br&gt;I&nbsp;have&nbsp;30&nbsp;messages&nbsp;in&nbsp;TestQ&nbsp;and&nbsp;i&nbsp;can&nbsp;see&nbsp;it&nbsp;in&nbsp;the&nbsp;RabbitMQ&nbsp;console&nbsp;of&nbsp;Host1,Host2&nbsp;looks&nbsp;like&nbsp;below&lt;br&gt;<br>
&lt;br&gt;Host1:&lt;br&gt;Name   &nbsp;Node&lt;br&gt;TestQ   &nbsp;rabbit@Node2&lt;br&gt;&lt;br&gt;Host2:&lt;br&gt;Name   &nbsp;Node&lt;br&gt;TestQ   &nbsp;rabbit@Node2&lt;br&gt;&lt;br&gt;In&nbsp;my&nbsp;consumer,&nbsp;I&nbsp;have&nbsp;implemented&nbsp;my&nbsp;own&nbsp;consumer&nbsp;as&nbsp;below.&lt;br&gt;&lt;br&gt;class&nbsp;MyConsumer&nbsp;extends&nbsp;QueueingConsumer{&lt;br&gt;<br>
&lt;br&gt;   &nbsp;Channel&nbsp;channel;&lt;br&gt;   &nbsp;public&nbsp;MyConsumer(Channel&nbsp;ch)&nbsp;{&lt;br&gt;   &nbsp;   &nbsp;super(ch);&lt;br&gt;   &nbsp;   &nbsp;this.channel&nbsp;=&nbsp;ch;&lt;br&gt;   &nbsp;}&lt;br&gt;   &nbsp;&lt;br&gt;   &nbsp;@Override&lt;br&gt;   &nbsp;public&nbsp;void&nbsp;handleCancel(String&nbsp;consumerTag) &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;System.out.println(&amp;quot;handleCancel&nbsp;::&nbsp;consumertag&nbsp;&amp;quot;+consumerTag+&amp;quot;&nbsp;channel&nbsp;opened&nbsp;&amp;quot;+channel.isOpen()+&amp;quot;,channel&nbsp;&amp;quot;+channel+&amp;quot;,&nbsp;rabbitmq&nbsp;consumer&nbsp;ch&nbsp;&amp;quot;+RabbitmqConsumer.ch);&lt;br&gt;<br>
   &nbsp;&lt;br&gt;   &nbsp;}&lt;br&gt;}&lt;br&gt;&lt;br&gt;If&nbsp;i&nbsp;run&nbsp;my&nbsp;consumer,&nbsp;it&nbsp;creates&nbsp;a&nbsp;channel&nbsp;with&nbsp;the&nbsp;reference&nbsp;of&nbsp;AMQChannel(amqp://guest@Host1:5672/,1)&nbsp;and&nbsp;it&nbsp;consumes&nbsp;the&nbsp;messasges&nbsp;from&nbsp;the&nbsp;TestQ.&nbsp;I&nbsp;have&nbsp;checked&nbsp;the&nbsp;consumer&nbsp;tag&nbsp;of&nbsp;the&nbsp;channel&nbsp;in&nbsp;both&nbsp;of&nbsp;the&nbsp;host&nbsp;and&nbsp;both&nbsp;are&nbsp;same.&lt;br&gt;<br>
&lt;br&gt;After&nbsp;some&nbsp;of&nbsp;the&nbsp;messages&nbsp;(assume&nbsp;10&nbsp;messages)&nbsp;are&nbsp;consumed,&nbsp;i&nbsp;explicitly&nbsp;down&nbsp;the&nbsp;Node2&nbsp;by&nbsp;giving&nbsp;the&nbsp;below&nbsp;command&lt;br&gt;&lt;br&gt;node2$&nbsp;./rabbitmqctl&nbsp;stop_app&lt;br&gt;&lt;br&gt;After&nbsp;the&nbsp;failure&nbsp;of&nbsp;Node2,&nbsp;i&nbsp;can&nbsp;see&nbsp;the&nbsp;print&nbsp;statements&nbsp;which&nbsp;i&nbsp;added&nbsp;in&nbsp;the&nbsp;handleCancel()&nbsp;method&nbsp;and&nbsp;consumer&nbsp;consumes&nbsp;all&nbsp;of&nbsp;the&nbsp;messages&nbsp;with&nbsp;out&nbsp;any&nbsp;error.&nbsp;The&nbsp;problem&nbsp;is&nbsp;the&nbsp;even&nbsp;though&nbsp;the&nbsp;remaining&nbsp;20&nbsp;messages&nbsp;are&nbsp;consumed&nbsp;and&nbsp;acked&nbsp;in&nbsp;the&nbsp;consumer,&nbsp;but&nbsp;if&nbsp;i&nbsp;check&nbsp;it&nbsp;in&nbsp;the&nbsp;rabbitmq&nbsp;console,&nbsp;the&nbsp;20&nbsp;messages&nbsp;are&nbsp;still&nbsp;exists&nbsp;in&nbsp;the&nbsp;TestQ.&lt;br&gt;<br>
&lt;br&gt;What&nbsp;i&nbsp;have&nbsp;to&nbsp;do&nbsp;in&nbsp;this&nbsp;scenario&nbsp;to&nbsp;overcome&nbsp;this&nbsp;issue.&lt;br&gt;&lt;/div&gt;<br>

</tt>
