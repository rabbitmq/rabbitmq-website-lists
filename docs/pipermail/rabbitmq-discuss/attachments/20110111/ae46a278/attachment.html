<tt>
Hi,&lt;br&gt;I&amp;#39;m&nbsp;developing&nbsp;a&nbsp;stress&nbsp;test&nbsp;to&nbsp;compare&nbsp;and&nbsp;measure&nbsp;the&nbsp;performance&nbsp;between&nbsp;RabbitMQ&nbsp;and&nbsp;ActiveMQ.&nbsp;Also&nbsp;the&nbsp;objective&nbsp;was&nbsp;to&nbsp;compare&nbsp;the&nbsp;standard&nbsp;AMQP&nbsp;with&nbsp;the&nbsp;JMS&nbsp;specifications.&nbsp;There&nbsp;is&nbsp;something&nbsp;that&nbsp;I&nbsp;would&nbsp;like&nbsp;to&nbsp;share&nbsp;with&nbsp;the&nbsp;community&nbsp;since&nbsp;I&nbsp;think&nbsp;in&nbsp;could&nbsp;be&nbsp;a&nbsp;possible&nbsp;bug&nbsp;or&nbsp;a&nbsp;memory&nbsp;leak&nbsp;problem.&nbsp;The&nbsp;stress&nbsp;test&nbsp;is&nbsp;very&nbsp;easy;&nbsp;there&nbsp;are&nbsp;no&nbsp;exponential&nbsp;ore&nbsp;base&nbsp;variables,&nbsp;just&nbsp;a&nbsp;linear&nbsp;test&nbsp;case.&nbsp;I&amp;#39;m&nbsp;going&nbsp;to&nbsp;describe&nbsp;the&nbsp;scenario.&nbsp;&lt;br&gt;<br>
The&nbsp;scenario&nbsp;is&nbsp;composed&nbsp;by&nbsp;two&nbsp;JAVA&nbsp;clients:&nbsp;a&nbsp;publisher&nbsp;and&nbsp;a&nbsp;subscriber,&nbsp;and&nbsp;one&nbsp;instance&nbsp;of&nbsp;RabbitMQ&nbsp;(V.&nbsp;2.2.0)&nbsp;running&nbsp;over&nbsp;a&nbsp;virtual&nbsp;machine&nbsp;2GB&nbsp;RAM.&nbsp;The&nbsp;clients,&nbsp;both&nbsp;publisher&nbsp;and&nbsp;subscriber&nbsp;are&nbsp;placed&nbsp;in&nbsp;two&nbsp;different&nbsp;physical&nbsp;machines.&nbsp;The&nbsp;messages&nbsp;to&nbsp;be&nbsp;sent&nbsp;by&nbsp;the&nbsp;publisher&nbsp;and&nbsp;received&nbsp;by&nbsp;the&nbsp;subscriber&nbsp;are&nbsp;described&nbsp;within&nbsp;a&nbsp;cluster.&nbsp;A&nbsp;cluster&nbsp;specifies&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;body&nbsp;message&nbsp;(in&nbsp;byte)&nbsp;and&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;messages&nbsp;to&nbsp;send&nbsp;and&nbsp;receive&nbsp;for&nbsp;that&nbsp;dimension.&nbsp;Ex:&nbsp;C1&nbsp;=&nbsp;(512::10000).&nbsp;The&nbsp;publisher&nbsp;uses&nbsp;a&nbsp;list&nbsp;of&nbsp;clusters,&nbsp;and&nbsp;for&nbsp;each&nbsp;one&nbsp;of&nbsp;them&nbsp;it&nbsp;starts&nbsp;a&nbsp;new&nbsp;loop&nbsp;in&nbsp;which&nbsp;messages&nbsp;are&nbsp;sent.&nbsp;Es:&nbsp;C1&nbsp;=&nbsp;(512::500000);&nbsp;C2&nbsp;=&nbsp;(1024::100000);&nbsp;C3&nbsp;=&nbsp;(2048::10000).&nbsp;&lt;br&gt;<br>
At&nbsp;begin&nbsp;and&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;each&nbsp;cluster,&nbsp;the&nbsp;publisher&nbsp;sends&nbsp;a&nbsp;special&nbsp;message&nbsp;used&nbsp;to&nbsp;inform&nbsp;the&nbsp;subscriber&nbsp;that&nbsp;a&nbsp;new&nbsp;cluster&nbsp;is&nbsp;started&nbsp;or&nbsp;is&nbsp;just&nbsp;finished.&nbsp;Also&nbsp;a&nbsp;special&nbsp;message&nbsp;is&nbsp;sent&nbsp;to&nbsp;the&nbsp;subscriber&nbsp;when&nbsp;all&nbsp;the&nbsp;clusters&nbsp;have&nbsp;been&nbsp;elaborated.&nbsp;The&nbsp;subscriber&nbsp;does&nbsp;nothing&nbsp;more&nbsp;than&nbsp;receiving&nbsp;messages&nbsp;and&nbsp;calculates&nbsp;the&nbsp;elapsed&nbsp;time&nbsp;(in&nbsp;seconds)&nbsp;between&nbsp;the&nbsp;start&nbsp;and&nbsp;the&nbsp;end&nbsp;message&nbsp;for&nbsp;each&nbsp;cluster.&nbsp;The&nbsp;Publisher&nbsp;uses&nbsp;a&nbsp;&amp;quot;direct&amp;quot;&nbsp;exchange&nbsp;(non-durable,&nbsp;non&nbsp;auto-delete)&nbsp;to&nbsp;publish&nbsp;the&nbsp;messages&nbsp;while&nbsp;the&nbsp;subscriber&nbsp;creates&nbsp;and&nbsp;binds&nbsp;a&nbsp;new&nbsp;queue&nbsp;over&nbsp;the&nbsp;same&nbsp;&amp;quot;direct&amp;quot;&nbsp;exchange.&lt;br&gt;<br>
&lt;br&gt;This&nbsp;is&nbsp;the&nbsp;code&nbsp;used&nbsp;to&nbsp;initialize&nbsp;the&nbsp;publisher:&lt;br&gt;&lt;br&gt;ConnectionFactory&nbsp;factory&nbsp;=&nbsp;new&nbsp;ConnectionFactory();&lt;br&gt;factory.setUsername(&amp;quot;guest&amp;quot;);&lt;br&gt;factory.setPassword(&amp;quot;guest&amp;quot;);&lt;br&gt;factory.setVirtualHost(&amp;quot;/&amp;quot;);&lt;br&gt;<br>
factory.setHost(&amp;quot;RabbitMQ_Srv_01&amp;quot;);&lt;br&gt;factory.setPort(5672);&lt;br&gt;conn&nbsp;=&nbsp;factory.newConnection();&lt;br&gt;channel&nbsp;=&nbsp;conn.createChannel();&lt;br&gt;boolean&nbsp;durable&nbsp;=&nbsp;false;&lt;br&gt;boolean&nbsp;autoDelete&nbsp;=&nbsp;false;&lt;br&gt;channel.exchangeDeclare(&amp;quot;linearTest&amp;quot;,&nbsp;&amp;quot;direct&amp;quot;,&nbsp;durable,&nbsp;autoDelete,&nbsp;null);&lt;br&gt;<br>
...&lt;br&gt;//Define&nbsp;some&nbsp;properties&lt;br&gt;AMQP.BasicProperties&nbsp;props&nbsp;=&nbsp;MessageProperties.PERSISTENT_TEXT_PLAIN;&lt;br&gt;Map&amp;lt;String,&nbsp;Object&amp;gt;&nbsp;headers&nbsp;=&nbsp;new&nbsp;HashMap&amp;lt;String,&nbsp;Object&amp;gt;();&lt;br&gt;headers.put(&amp;quot;TestCommand&amp;quot;,&nbsp;CURRENT_COMMAND);&lt;br&gt;<br>
...&lt;br&gt;props.setHeaders(headers);&lt;br&gt;//Basic&nbsp;publish&lt;br&gt;channel.basicPublish(&amp;quot;linearExch&amp;quot;,&nbsp;&amp;quot;linearKey&amp;quot;,&nbsp;props,&nbsp;CLUSTER[i].messageBodyBytes);&lt;br&gt;...&lt;br&gt;&lt;br&gt;This&nbsp;is&nbsp;the&nbsp;code&nbsp;used&nbsp;to&nbsp;initialize&nbsp;the&nbsp;subscriber:&lt;br&gt;<br>
 &lt;br&gt;ConnectionFactory&nbsp;factory&nbsp;=&nbsp;new&nbsp;ConnectionFactory();&lt;br&gt;factory.setUsername(&amp;quot;guest&amp;quot;);&lt;br&gt;factory.setPassword(&amp;quot;guest&amp;quot;);&lt;br&gt;factory.setVirtualHost(&amp;quot;/&amp;quot;);&lt;br&gt;factory.setHost(&amp;quot;RabbitMQ_Srv_01&amp;quot;);&lt;br&gt;<br>
factory.setPort(5672);&lt;br&gt;Connection&nbsp;conn&nbsp;=&nbsp;factory.newConnection();&lt;br&gt;Channel&nbsp;channel&nbsp;=&nbsp;conn.createChannel();&lt;br&gt;boolean&nbsp;durable&nbsp;=&nbsp;false;&lt;br&gt;boolean&nbsp;autoDelete&nbsp;=&nbsp;false;&lt;br&gt;boolean&nbsp;exclusive&nbsp;=&nbsp;false;&lt;br&gt;channel.exchangeDeclare(&amp;quot;linearExch&amp;quot;,&nbsp;&amp;quot;direct&amp;quot;,&nbsp;durable,&nbsp;autoDelete,&nbsp;null);&lt;br&gt;<br>
channel.queueDeclare(&amp;quot;linearQueue&amp;quot;,&nbsp;durable,&nbsp;exclusive,&nbsp;autoDelete,&nbsp;null);&lt;br&gt;channel.queueBind(&amp;quot;linearQueue&amp;quot;,&nbsp;&amp;quot;linearExch&amp;quot;,&nbsp;&amp;quot;linearKey&amp;quot;,&nbsp;null);&lt;br&gt;QueueingConsumer&nbsp;consumer&nbsp;=&nbsp;new&nbsp;QueueingConsumer(channel);&lt;br&gt;<br>
boolean&nbsp;autoAck&nbsp;=&nbsp;false;&lt;br&gt;channel.basicConsume(&amp;quot;linearQueue&amp;quot;,&nbsp;autoAck,&nbsp;consumer);&lt;br&gt; &lt;br&gt;while&nbsp;(true)&nbsp;{&lt;br&gt;try&nbsp;{&lt;br&gt;QueueingConsumer.Delivery&nbsp;delivery&nbsp;=&nbsp;consumer.nextDelivery();&lt;br&gt;onMessage(delivery);&lt;br&gt;channel.basicAck(delivery.getEnvelope().getDeliveryTag(),&nbsp;false);&lt;br&gt;<br>
//If&nbsp;shutdown&nbsp;from&nbsp;the&nbsp;publisher&nbsp;is&nbsp;received&lt;br&gt;if&nbsp;(shutdown)&nbsp;{&lt;br&gt;channel.close();&lt;br&gt;conn.close();&lt;br&gt;break;&lt;br&gt;}&lt;br&gt;}&lt;br&gt;catch&nbsp;(InterruptedException&nbsp;ie)&nbsp;{&lt;br&gt;continue;&lt;br&gt;}&lt;br&gt;}&lt;br&gt;&lt;br&gt;This&nbsp;is&nbsp;how&nbsp;I&amp;#39;ve&nbsp;set&nbsp;up&nbsp;the&nbsp;test&nbsp;case:&lt;br&gt;<br>
&lt;br&gt;1.  &nbsp; Started&nbsp;the&nbsp;RabbitMQ&nbsp;broker&nbsp;by&nbsp;using&nbsp;the&nbsp;.bat&nbsp;&amp;quot;rubbitmq-server.bat&amp;quot;&nbsp;(NO&nbsp;extra&nbsp;configuration&nbsp;used).&lt;br&gt;2.  &nbsp; Open&nbsp;the&nbsp;task&nbsp;manager&nbsp;to&nbsp;view&nbsp;the&nbsp;RabbitMQ&nbsp;(.erl&nbsp;process)&nbsp;memory&nbsp;usage.&lt;br&gt;3.  &nbsp; Started&nbsp;the&nbsp;subscriber.&lt;br&gt;<br>
4.  &nbsp; Started&nbsp;the&nbsp;publisher.&lt;br&gt;5.  &nbsp; Defined&nbsp;Clusters&nbsp;As:&nbsp;{C1(512:10000);&nbsp;C2(512:10000);&nbsp;C3(512:10000);&nbsp;C4(512:100000);&nbsp;C5(512:100000);&nbsp;C6(512:100000);&nbsp;C7(1024:10000);&nbsp;C8(1024:10000);&nbsp;C9(1024:10000);&nbsp;C10(1024:100000);&nbsp;C11(1024:100000);&nbsp;C12(1024:100000);&nbsp;C13(2048:10000);&nbsp;C14(2048:10000);&nbsp;C15(2048:10000);&nbsp;C16(2048:100000);&nbsp;C17(2048:100000);&nbsp;C18(2048:100000)&nbsp;}&lt;br&gt;<br>
&lt;br&gt;These&nbsp;are&nbsp;some&nbsp;results&nbsp;and&nbsp;notifications:&lt;br&gt;&lt;br&gt;.&nbsp;I&amp;#39;ve&nbsp;started&nbsp;a&nbsp;first&nbsp;test&nbsp;case,&nbsp;I&amp;#39;ve&nbsp;noticed&nbsp;that&nbsp;RabbitMQ&nbsp;uses&nbsp;lots&nbsp;of&nbsp;memory&nbsp;during&nbsp;the&nbsp;test.&nbsp;At&nbsp;the&nbsp;first&nbsp;step,&nbsp;where&nbsp;only&nbsp;the&nbsp;broker&nbsp;was&nbsp;running,&nbsp;just&nbsp;19&nbsp;KB&nbsp;of&nbsp;memory&nbsp;were&nbsp;used.&nbsp;At&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;process&nbsp;the&nbsp;memory&nbsp;usage&nbsp;increases&nbsp;up&nbsp;to&nbsp;more&nbsp;than&nbsp;850&nbsp;KB.&nbsp;After&nbsp;stopping&nbsp;the&nbsp;publisher&nbsp;and&nbsp;the&nbsp;subscriber,&nbsp;the&nbsp;memory&nbsp;usage&nbsp;was&nbsp;very&nbsp;slowly&nbsp;decreasing&nbsp;from&nbsp;850-800KB&nbsp;down&nbsp;to&nbsp;50-20&nbsp;KB.&nbsp;&lt;br&gt;<br>
&lt;br&gt;.&nbsp;I&amp;#39;ve&nbsp;started&nbsp;a&nbsp;second&nbsp;test&nbsp;case&nbsp;but&nbsp;this&nbsp;time&nbsp;using&nbsp;the&nbsp;publisher&nbsp;and&nbsp;the&nbsp;subscriber&nbsp;over&nbsp;the&nbsp;same&nbsp;physical&nbsp;machine.&nbsp;After&nbsp;a&nbsp;few&nbsp;minutes&nbsp;the&nbsp;broker&nbsp;crashed&nbsp;down&nbsp;showing&nbsp;the&nbsp;following&nbsp;message:&nbsp;&amp;quot;eheap_alloc:&nbsp;Cannot&nbsp;allocate&nbsp;373662860&nbsp;bytes&nbsp;of&nbsp;memory&nbsp;(of&nbsp;type&nbsp;&amp;quot;heap&amp;quot;)&amp;quot;.&nbsp;I&amp;#39;ve&nbsp;repeated&nbsp;the&nbsp;same&nbsp;test&nbsp;more&nbsp;and&nbsp;more&nbsp;but&nbsp;every&nbsp;time&nbsp;the&nbsp;broker&nbsp;crashed&nbsp;down.&lt;br&gt;<br>
&lt;br&gt;.&nbsp;I’ve&nbsp;started&nbsp;a&nbsp;third&nbsp;test&nbsp;case,&nbsp;similar&nbsp;to&nbsp;the&nbsp;first&nbsp;one&nbsp;(publisher&nbsp;and&nbsp;subscriber&nbsp;placed&nbsp;in&nbsp;two&nbsp;different&nbsp;machines)&nbsp;but&nbsp;this&nbsp;time&nbsp;using&nbsp;the&nbsp;following&nbsp;cluster&nbsp;list: &nbsp;{C1(512:10000);&nbsp;C2(512:10000);&nbsp;C3(512:10000);&nbsp;C4(512:100000);&nbsp;C5(512:100000);&nbsp;C6(512:100000);&nbsp;C7(512:500000);&nbsp;C8(512:500000);&nbsp;C9(512:500000)}.&nbsp;At&nbsp;the&nbsp;time&nbsp;of&nbsp;elaborating&nbsp;the&nbsp;last&nbsp;element&nbsp;(C9)&nbsp;the&nbsp;broker&nbsp;crashed&nbsp;down&nbsp;showing&nbsp;the&nbsp;same&nbsp;message&nbsp;as&nbsp;the&nbsp;one&nbsp;in&nbsp;the&nbsp;previous&nbsp;test.&nbsp;&lt;br&gt;<br>
&lt;br&gt;I&nbsp;think&nbsp;that&nbsp;the&nbsp;reason&nbsp;for&nbsp;the&nbsp;second&nbsp;test&nbsp;case&nbsp;can&nbsp;be&nbsp;found&nbsp;in&nbsp;the&nbsp;network&nbsp;usage,&nbsp;which&nbsp;causes&nbsp;the&nbsp;broker&nbsp;to&nbsp;store&nbsp;in&nbsp;the&nbsp;memory&nbsp;a&nbsp;lots&nbsp;of&nbsp;message&nbsp;because&nbsp;publisher&nbsp;and&nbsp;subscriber&nbsp;are&nbsp;placed&nbsp;in&nbsp;the&nbsp;same&nbsp;machine&nbsp;and,&nbsp;it’s&nbsp;clearly&nbsp;that&nbsp;the&nbsp;subscriber&nbsp;leads&nbsp;substantially&nbsp;the&nbsp;usage&nbsp;and&nbsp;the&nbsp;performance&nbsp;of&nbsp;the&nbsp;process&nbsp;(maybe&nbsp;because&nbsp;of&nbsp;the&nbsp;acknowledgements).&nbsp;But&nbsp;I&nbsp;don’t&nbsp;have&nbsp;a&nbsp;good&nbsp;idea&nbsp;for&nbsp;the&nbsp;third&nbsp;test&nbsp;case,&nbsp;which&nbsp;causes&nbsp;the&nbsp;same&nbsp;error.&lt;br&gt;<br>
&lt;br&gt;Now&nbsp;I’m&nbsp;facing&nbsp;with&nbsp;the&nbsp;fact&nbsp;that,&nbsp;comparing&nbsp;to&nbsp;ActiveMQ,&nbsp;the&nbsp;second&nbsp;test&nbsp;and&nbsp;the&nbsp;third&nbsp;test&nbsp;are&nbsp;successfully&nbsp;done,&nbsp;in&nbsp;fact,&nbsp;even&nbsp;if&nbsp;the&nbsp;subscriber&nbsp;and&nbsp;the&nbsp;publisher&nbsp;are&nbsp;placed&nbsp;in&nbsp;the&nbsp;same&nbsp;machine&nbsp;(the&nbsp;ActiveMQ&nbsp;broker&nbsp;runs&nbsp;in&nbsp;the&nbsp;same&nbsp;virtual&nbsp;machine&nbsp;as&nbsp;the&nbsp;one&nbsp;used&nbsp;for&nbsp;the&nbsp;RabbitMQ)&nbsp;the&nbsp;test&nbsp;case&nbsp;comes&nbsp;successfully&nbsp;to&nbsp;the&nbsp;end,&nbsp;and&nbsp;the&nbsp;broke&nbsp;doesn’t&nbsp;crash&nbsp;down.&nbsp;However,&nbsp;the&nbsp;first&nbsp;test&nbsp;case&nbsp;(described&nbsp;in&nbsp;the&nbsp;first&nbsp;point)&nbsp;seems&nbsp;to&nbsp;be&nbsp;more&nbsp;efficient,&nbsp;in&nbsp;terms&nbsp;of&nbsp;seconds,&nbsp;by&nbsp;using&nbsp;RabbitMQ.&nbsp;&lt;br&gt;<br>
&lt;br&gt;Here&nbsp;some&nbsp;questions:&lt;br&gt;&lt;br&gt;.&nbsp;In&nbsp;general,&nbsp;what&nbsp;do&nbsp;you&nbsp;think&nbsp;about&nbsp;the&nbsp;test?&nbsp;&lt;br&gt;.&nbsp;Am&nbsp;I&nbsp;adopting&nbsp;a&nbsp;very&nbsp;strange&nbsp;test&nbsp;case&nbsp;which&nbsp;is&nbsp;not&nbsp;well&nbsp;handled&nbsp;by&nbsp;RabbitMQ?&nbsp;&lt;br&gt;.&nbsp;Is&nbsp;there&nbsp;any&nbsp;connection&nbsp;with&nbsp;the&nbsp;solved&nbsp;bug&nbsp;described&nbsp;in&nbsp;the&nbsp;RabbitMQ&nbsp;2.2&nbsp;release&nbsp;notes&nbsp;(“fix&nbsp;memory&nbsp;leak&nbsp;when&nbsp;long-running&nbsp;channels&nbsp;consume&nbsp;and&nbsp;cancel&nbsp;on&nbsp;many&nbsp;queues”)?&lt;br&gt;<br>
.&nbsp;How&nbsp;does&nbsp;RabbitMQ&nbsp;handle&nbsp;message&nbsp;flooding?&nbsp;As&nbsp;stated&nbsp;in&nbsp;ActiveMQ&nbsp;official&nbsp;page,&nbsp;the&nbsp;flow&nbsp;control,&nbsp;in&nbsp;the&nbsp;current&nbsp;version&nbsp;means&nbsp;that:&nbsp;“if&nbsp;the&nbsp;broker&nbsp;detects&nbsp;that&nbsp;the&nbsp;memory&nbsp;limit&nbsp;for&nbsp;the&nbsp;destination,&nbsp;or&nbsp;the&nbsp;temp-&nbsp;or&nbsp;file-store&nbsp;limits&nbsp;for&nbsp;the&nbsp;broker,&nbsp;have&nbsp;been&nbsp;exceeded,&nbsp;then&nbsp;the&nbsp;flow&nbsp;of&nbsp;messages&nbsp;can&nbsp;be&nbsp;slowed&nbsp;down.&nbsp;The&nbsp;producer&nbsp;will&nbsp;be&nbsp;either&nbsp;blocked&nbsp;until&nbsp;resources&nbsp;are&nbsp;available&nbsp;or&nbsp;will&nbsp;receive&nbsp;a&nbsp;JMSException”.&lt;br&gt;<br>
&lt;br&gt;Thanks&nbsp;for&nbsp;any&nbsp;response.&nbsp;&lt;br&gt;<br>

</tt>
