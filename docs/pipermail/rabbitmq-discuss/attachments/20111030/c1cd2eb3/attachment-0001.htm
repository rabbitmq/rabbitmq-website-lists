<tt>
&lt;div&gt;&lt;div&gt;I&nbsp;have&nbsp;two&nbsp;usage&nbsp;questions;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;First,&nbsp;we&nbsp;have&nbsp;customers&nbsp;submitting&nbsp;jobs&nbsp;(via&nbsp;a&nbsp;web&nbsp;app)&nbsp;at&nbsp;a pretty&nbsp;even&nbsp;rate,&nbsp;and&nbsp;as&nbsp;such&nbsp;any&nbsp;individual&nbsp;customer&amp;#39;s&nbsp;job&nbsp;gets&nbsp;done&nbsp;on&nbsp;a&nbsp;pretty&nbsp;regular&nbsp;basis.&nbsp; But,&nbsp;it&amp;#39;s&nbsp;possible&nbsp;for&nbsp;a&nbsp;single&nbsp;customer&nbsp;to&nbsp;flood&nbsp;the&nbsp;queue&nbsp;with&nbsp;requests,&nbsp;which&nbsp;leads&nbsp;to&nbsp;everyone&nbsp;else&nbsp;waiting&nbsp;on&nbsp;that&nbsp;one&nbsp;customer&amp;#39;s&nbsp;jobs&nbsp;to&nbsp;complete.&nbsp; I&nbsp;would&nbsp;like&nbsp;it&nbsp;to&nbsp;reduce&nbsp;the&nbsp;effect&nbsp;of&nbsp;one&nbsp;customer&amp;#39;s&nbsp;actions&nbsp;on&nbsp;everyone&nbsp;else.&lt;/div&gt;<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;My&nbsp;plan&nbsp;was&nbsp;to&nbsp;use&nbsp;Memcached&nbsp;to&nbsp;track&nbsp;submission&nbsp;rates&nbsp;per&nbsp;customer&nbsp;and&nbsp;when&nbsp;they&nbsp;exceed&nbsp;some&nbsp;rate&nbsp;publish&nbsp;their&nbsp;jobs&nbsp;to&nbsp;a&nbsp;secondary&nbsp;(low&nbsp;priority)&nbsp;queue.&nbsp; Then&nbsp;assign&nbsp;fewer&nbsp;workers&nbsp;to&nbsp;the&nbsp;low&nbsp;priority&nbsp;queue.&lt;/div&gt;<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Is&nbsp;this&nbsp;a&nbsp;good&nbsp;approach?&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Second,&nbsp;when&nbsp;the&nbsp;web&nbsp;app&nbsp;queues&nbsp;a&nbsp;message&nbsp;(to&nbsp;process&nbsp;some&nbsp;&amp;quot;backend&amp;quot;&nbsp;job)&nbsp;the&nbsp;web&nbsp;app&nbsp;sets&nbsp;a&nbsp;&amp;quot;pending&amp;quot;&nbsp;state&nbsp;in&nbsp;the&nbsp;database.&nbsp; What&nbsp;normally&nbsp;happens&nbsp;is&nbsp;one&nbsp;worker&nbsp;processes&nbsp;the&nbsp;job,&nbsp;then&nbsp;this&nbsp;worker&nbsp;sends&nbsp;a&nbsp;new&nbsp;message&nbsp;that&nbsp;a&nbsp;second&nbsp;worker&nbsp;picks&nbsp;up&nbsp;and&nbsp;completes&nbsp;the&nbsp;job&nbsp;on&nbsp;the&nbsp;web&nbsp;app&nbsp;side.&nbsp; In&nbsp;the&nbsp;most&nbsp;simple&nbsp;case&nbsp;&amp;quot;completing&amp;quot;&nbsp;the&nbsp;job&nbsp;means&nbsp;the&nbsp;state&nbsp;in&nbsp;the&nbsp;database&nbsp;is&nbsp;changed&nbsp;from&nbsp;&amp;quot;pending&amp;quot;&nbsp;to&nbsp;&amp;quot;complete&amp;quot;.&lt;/div&gt;<br>
<br>
&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Is&nbsp;this&nbsp;a&nbsp;common&nbsp;use&nbsp;pattern?&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;My&nbsp;question&nbsp;is&nbsp;how&nbsp;to&nbsp;handle&nbsp;failures&nbsp;and&nbsp;detect&nbsp;stale&nbsp;jobs.&nbsp; For&nbsp;example,&nbsp;what&nbsp;if&nbsp;the&nbsp;first&nbsp;worker&nbsp;dies&nbsp;and&nbsp;never&nbsp;sends&nbsp;the&nbsp;completed&nbsp;(or&nbsp;failed)&nbsp;message&nbsp;to&nbsp;the&nbsp;second&nbsp;worker?&nbsp; The&nbsp;database&nbsp;is&nbsp;then&nbsp;left&nbsp;indicating&nbsp;&amp;quot;pending&amp;quot;.&nbsp; &nbsp;I&nbsp;would&nbsp;tend&nbsp;to&nbsp;use&nbsp;cron&nbsp;for&nbsp;this.&nbsp;That&nbsp;is,&nbsp;have&nbsp;cron&nbsp;look&nbsp;for&nbsp;old&nbsp;&amp;quot;pending&amp;quot;&nbsp;states&nbsp;and&nbsp;either&nbsp;re-queue&nbsp;the&nbsp;request&nbsp;or&nbsp;mark&nbsp;it&nbsp;as&nbsp;failed&nbsp;(say&nbsp;after&nbsp;a&nbsp;few&nbsp;failed&nbsp;retry&nbsp;attempts).&lt;/div&gt;<br>
<br>
&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Are&nbsp;there&nbsp;other&nbsp;approaches&nbsp;I&nbsp;should&nbsp;consider?&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Thanks,&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;--&nbsp;&lt;br&gt;Bill&nbsp;Moseley&lt;br&gt;&lt;a&nbsp;href=&quot;mailto:moseley@hank.org&quot;&nbsp;target=&quot;_blank&quot;&gt;moseley@hank.org&lt;/a&gt;&lt;br&gt;<br>
<br>
<br>
&lt;/div&gt;<br>

</tt>
