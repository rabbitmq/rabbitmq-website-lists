
/** This is the method that converts a PHP zval into the appropriate amqp_table structure **/
amqp_table_t *convert_zval_to_arguments(zval *zvalArguments)
{
	HashTable *argumentHash;
	HashPosition pos;
	zval **data;
	
	argumentHash = Z_ARRVAL_P(zvalArguments);
	
	/* In setArguments, we are overwriting all the existing values */
	amqp_table_t *arguments = (amqp_table_t *)emalloc(sizeof(amqp_table_t));

	/* Allocate all the memory necessary for storing the arguments */
	arguments->entries = (amqp_table_entry_t *)ecalloc(zend_hash_num_elements(argumentHash), sizeof(amqp_table_entry_t));
	arguments->num_entries = 0;

	for (zend_hash_internal_pointer_reset_ex(argumentHash, &pos);
		zend_hash_get_current_data_ex(argumentHash, (void**) &data, &pos) == SUCCESS;
		zend_hash_move_forward_ex(argumentHash, &pos)) {
	
		/* Make a copy of the value: */
		zval value;
		value = **data;
		zval_copy_ctor(&value);
	
		/* Now pull the key */
		char *key;
		uint key_len;
		ulong index;
	
		if (zend_hash_get_current_key_ex(argumentHash, &key, &key_len, &index, 0, &pos) != HASH_KEY_IS_STRING) {
			/* Skip things that are not strings */
			continue;
		}
	
		/* Build the value */
		amqp_table_entry_t *table = &arguments->entries[arguments->num_entries++];
		amqp_field_value_t *field = &table->value;
		char *strKey = estrndup(key, key_len);
		table->key = amqp_cstring_bytes(strKey);
	
		switch (Z_TYPE_P(&value)) {
			case IS_BOOL:
				field->kind = AMQP_FIELD_KIND_BOOLEAN;
				field->value.boolean = (amqp_boolean_t)Z_LVAL_P(&value);
				break;
			case IS_DOUBLE:
				field->kind = AMQP_FIELD_KIND_F64;
				field->value.f64 = Z_DVAL_P(&value);
				break;
			case IS_LONG:
				field->kind = AMQP_FIELD_KIND_I64;
				field->value.i64 = Z_LVAL_P(&value);
				break;
			case IS_STRING:
				field->kind = AMQP_FIELD_KIND_BYTES;
				char *strValue = estrndup(Z_STRVAL_P(&value), Z_STRLEN_P(&value));
				field->value.bytes = amqp_cstring_bytes(strValue);
				break;
			default:
				continue;
		}
			
		/* Clean up the zval */
		zval_dtor(&value);
	}

	return arguments;
}

/** This is me using the above function **/
amqp_table_t *arguments = convert_zval_to_arguments(queue->arguments);

char *key = (char *)arguments->entries[0].key.bytes;
char kind = arguments->entries[0].value.kind;
char *value = (char *)arguments->entries[0].value.value.bytes.bytes;

printf("Arg 0: %s => (%c)%s\n", key, kind, value);
/* Prints: Arg 0: x-ha-policy => (x)all */

r = amqp_queue_declare(
	connection->connection_resource->connection_state,
	channel->channel_id,
	amqp_cstring_bytes(queue->name),
	queue->passive,
	queue->durable,
	queue->exclusive,
	queue->auto_delete,
	*arguments
);

res = amqp_get_rpc_reply(connection->connection_resource->connection_state); 

AMQP_EFREE_ARGUMENTS(arguments);

/* handle any errors that occurred outside of signals */
if (res.reply_type != AMQP_RESPONSE_NORMAL) {
	char str[256];
	char ** pstr = (char **) &str;
	amqp_error(res, pstr);
	channel->is_connected = '\0';
	zend_throw_exception(amqp_queue_exception_class_entry, *pstr, 0 TSRMLS_CC);
	return;
}

/*
Then I get: Server channel error: 406, message: PRECONDITION_FAILED - invalid arg 'x-ha-policy' for queue 'testqueue1321498212' in vhost '/': {unacceptable_type,binary}
*/

