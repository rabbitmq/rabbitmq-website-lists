<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] acks from temporary queues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20acks%20from%20temporary%20queues&In-Reply-To=%3C748f48cc-75d0-43d9-a794-bd521fee39de%40k1g2000vbz.googlegroups.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015245.html">
   <LINK REL="Next"  HREF="015253.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] acks from temporary queues</H1>
    <B>gneeri</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20acks%20from%20temporary%20queues&In-Reply-To=%3C748f48cc-75d0-43d9-a794-bd521fee39de%40k1g2000vbz.googlegroups.com%3E"
       TITLE="[rabbitmq-discuss] acks from temporary queues">gneeri at gmail.com
       </A><BR>
    <I>Fri Sep 23 21:26:45 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="015245.html">[rabbitmq-discuss] acks from temporary queues
</A></li>
        <LI>Next message: <A HREF="015253.html">[rabbitmq-discuss] acks from temporary queues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15250">[ date ]</a>
              <a href="thread.html#15250">[ thread ]</a>
              <a href="subject.html#15250">[ subject ]</a>
              <a href="author.html#15250">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Alex,

So to follow up, I have run some tests with durable queues and
waitForConfirms, which are not giving me the results I would expect.

The test is set up as follows:

1. I have a producer publishing with confirmSelect and waitForConfirms
to a fanout exchange

2. I have 2 consumers, attached to durable queues bound to the fanout
exchange

3. both consumers have autoAck set to false and use manual basicAck
after processing

4. I have put a delay (via Thread.sleep()) into one of the consumers

My expectation, then, is that producer would publish its message and
then be blocked until the delayed consumer returns an ack to queue
which would in turn send an ack to the fanout exchange, followed by an
ack to the producer. This, however, does not appear to be the case and
the producer appears to be executing code below the waitForConfirms()
call, well before the delayed consumer sends back its ack. For good
measure, I have also tried placing the sleep() call before the
consumer calls nextDelivery() in case the simple acceptance of the
payload from the queue would be enough to pass acks back up the chain
to the producer. This too, did not appear to work.

Ultimately, then, my sense is that I have misconstrued your earlier
remarks. Earlier (below), I passed along the intended functionality.
My hope is that I will not have to aggregate a list of servers and
pass along a single message to each server, but perhaps that is what
will be required. In any case, if you could let me know what I am
missing in this test (i.e., if there is a correctable way of making
this work) or if I need to attempt an implementation based on one
message per server, I would very much appreciate it.

Thanks in advance,
Jonathan

On Sep 23, 12:19&#160;pm, gneeri &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">gne... at gmail.com</A>&gt; wrote:
&gt;<i> Hi Alex,
</I>&gt;<i>
</I>&gt;<i> Thank you very much for your detailed reply. It is quite helpful and I
</I>&gt;<i> do have one specific question with respect to your notes, but think it
</I>&gt;<i> might be most useful if I briefly respond to your question about the
</I>&gt;<i> intended system before inquiring further:
</I>&gt;<i>
</I>&gt;<i> The system is composed of a dynamic array of servers, each of which
</I>&gt;<i> support user logins. In order to prevent data corruption (i.e.,
</I>&gt;<i> concurrency problems), my intent is that, upon login to any of the
</I>&gt;<i> servers, the server logged into broadcasts a message out to the other
</I>&gt;<i> servers, telling them to revoke control over the logging in user's
</I>&gt;<i> data. Then, and only once all of the other servers (subscribed to the
</I>&gt;<i> login exchange at startup) have ack'd the request to relinquish
</I>&gt;<i> control, do I want the login server to proceed and take control of the
</I>&gt;<i> user's data.
</I>&gt;<i>
</I>&gt;<i> From there, I expect the blocking requirement is pretty clear. Also,
</I>&gt;<i> insofar as the array of servers is dynamic, I'm hoping my desire to
</I>&gt;<i> use a single message over a &quot;fanout&quot; exchange will make some sense (as
</I>&gt;<i> opposed to having to send a single message to each server via a named
</I>&gt;<i> queue (or perhaps routing key) that would require me to have a list of
</I>&gt;<i> all of the servers in advance of publishing).
</I>&gt;<i>
</I>&gt;<i> Which brings me to my question(s): when you say: &quot;The broker, in turn,
</I>&gt;<i> will only acknowledge the message if . . . 2) it has been delivered to
</I>&gt;<i> a consumer on each of the queues it had reached&quot;--does this mean that
</I>&gt;<i> the broker (in this case, fanout exchange) will only send an ack to
</I>&gt;<i> the publisher after a consumer on each of the attached queues has been
</I>&gt;<i> reached? After some very rough testing with multiple consumers
</I>&gt;<i> attached to the same fanout exchange, it has appeared to me that the
</I>&gt;<i> publisher may get an ack prior to one of the consumers sending its ack
</I>&gt;<i> back to the broker. This may just be the result of bad test code (on
</I>&gt;<i> my part) *or* it may relate the fact that I am using temporary queues
</I>&gt;<i> (e.g., channel.queueDeclare().getQueue()) rather than durable queues,
</I>&gt;<i> as you suggest below. If that latter is the case, are you suggesting
</I>&gt;<i> that using durable queues would make the broker wait on all consumers
</I>&gt;<i> for all of the queues before returning an ack to the publisher? If so,
</I>&gt;<i> that sounds like it would do the trick.
</I>&gt;<i>
</I>&gt;<i> Sorry again, for being so verbose and thanks very much for your help.
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> Jonathan
</I>&gt;<i>
</I>&gt;<i> On Sep 23, 5:58&#160;am, Alexandru Scvor&#355;ov &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">alexan... at rabbitmq.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; Hi Jonathan,
</I>&gt;<i>
</I>&gt;<i> &gt; &gt; I apologize if this is an ill-informed question: In a nutshell, the
</I>&gt;<i> &gt; &gt; thing I am trying to accomplish is blocking a producer until it has
</I>&gt;<i> &gt; &gt; received acks (or even nacks) from all consumers on temporary queues
</I>&gt;<i> &gt; &gt; bound to a given (fanout) exchange for a single message. From the
</I>&gt;<i> &gt; &gt; docs, my sense is that using confirms and waitForConfirms would be
</I>&gt;<i> &gt; &gt; preferable to full on transactions,
</I>&gt;<i>
</I>&gt;<i> &gt; Confirms are usually the way to go.
</I>&gt;<i>
</I>&gt;<i> &gt; With confirms enabled, calling waitForConfirms would block the producer
</I>&gt;<i> &gt; until all published messages on that channel are acknowledged *by the
</I>&gt;<i> &gt; broker*. &#160;The broker, in turn, will only acknowledge the message if 1)
</I>&gt;<i> &gt; it has been persisted to disk; *or* if 2) it has been delivered to a
</I>&gt;<i> &gt; consumer on each of the queues it had reached.
</I>&gt;<i>
</I>&gt;<i> &gt; You can't really specify that you only want the acknowledgement if the
</I>&gt;<i> &gt; messages are delivered and not if they're persisted.
</I>&gt;<i>
</I>&gt;<i> &gt; Also, you said &quot;temporary queues&quot;. &#160;Confirms will only work as described
</I>&gt;<i> &gt; above if the message is persistent and if the queues it lands on are
</I>&gt;<i> &gt; durable. &#160;A message that lands on a non-durable queue is considered
</I>&gt;<i> &gt; acknowledged on that queue immediately (of course, the broker will still
</I>&gt;<i> &gt; wait for it to be persisted or acknowledged on all the other queues it
</I>&gt;<i> &gt; reached, before acknowledging it to the producer).
</I>&gt;<i>
</I>&gt;<i> &gt; &gt; but as each instance of the
</I>&gt;<i> &gt; &gt; producer will be on its own thread,
</I>&gt;<i>
</I>&gt;<i> &gt; That's fine. &#160;Just make sure to use a separate channel for each
</I>&gt;<i> &gt; producer (calling waitForConfirms on the same channel from multiple
</I>&gt;<i> &gt; threads will almost certainly not do what you want it to).
</I>&gt;<i>
</I>&gt;<i> &gt; &gt; The main point of confusion for me here is whether I can get multiple
</I>&gt;<i> &gt; &gt; acks (from all consumers) for one message without having any prior
</I>&gt;<i> &gt; &gt; information about the number of queues attached to the exchange. That
</I>&gt;<i> &gt; &gt; is, I don't just want to know that one queue has received the message,
</I>&gt;<i> &gt; &gt; but that all queues bound to the exchange have done so. It seems clear
</I>&gt;<i>
</I>&gt;<i> &gt; Not quite sure what you mean. &#160;A published message, even if it gets sent
</I>&gt;<i> &gt; to multiple queues, is still *one* message with a certain sequence
</I>&gt;<i> &gt; number. &#160;A published message will be acknowledged by the broker only
</I>&gt;<i> &gt; once, when it has been written to disk or when it has been successfully
</I>&gt;<i> &gt; sent to a consumer from each queue.
</I>&gt;<i>
</I>&gt;<i> &gt; Consumer acks and publisher acks are completely different things. &#160;A
</I>&gt;<i> &gt; consumer acks a message to tell *the broker* (not the publisher) that it
</I>&gt;<i> &gt; has taken responsibility for the message (by using it up, by forwarding
</I>&gt;<i> &gt; it, by doing something with it). &#160;The broker acks a message to tell *the
</I>&gt;<i> &gt; publisher* that it has taken responsibility for the message (by saving
</I>&gt;<i> &gt; it to disk, or by handing it over to consumers).
</I>&gt;<i>
</I>&gt;<i> &gt; When a message reaches a queue, and is then delivered to a consumer, the
</I>&gt;<i> &gt; broker will consider the message delivered only when the consumer
</I>&gt;<i> &gt; acknowledges it. &#160;So, if it weren't for the &quot;writing the message to
</I>&gt;<i> &gt; disk&quot; part, it would work exactly the way you're expecting it to.
</I>&gt;<i>
</I>&gt;<i> &gt; What sort of system are you designing?
</I>&gt;<i>
</I>&gt;<i> &gt; Hope this helps.
</I>&gt;<i>
</I>&gt;<i> &gt; Cheers,
</I>&gt;<i> &gt; Alex
</I>&gt;<i>
</I>&gt;<i> &gt; On Thu, Sep 22, 2011 at 12:22:50PM -0700, gneeri wrote:
</I>&gt;<i> &gt; &gt; I apologize if this is an ill-informed question: In a nutshell, the
</I>&gt;<i> &gt; &gt; thing I am trying to accomplish is blocking a producer until it has
</I>&gt;<i> &gt; &gt; received acks (or even nacks) from all consumers on temporary queues
</I>&gt;<i> &gt; &gt; bound to a given (fanout) exchange for a single message. From the
</I>&gt;<i> &gt; &gt; docs, my sense is that using confirms and waitForConfirms would be
</I>&gt;<i> &gt; &gt; preferable to full on transactions, but as each instance of the
</I>&gt;<i> &gt; &gt; producer will be on its own thread, I am open to using transactions.
</I>&gt;<i> &gt; &gt; The main point of confusion for me here is whether I can get multiple
</I>&gt;<i> &gt; &gt; acks (from all consumers) for one message without having any prior
</I>&gt;<i> &gt; &gt; information about the number of queues attached to the exchange. That
</I>&gt;<i> &gt; &gt; is, I don't just want to know that one queue has received the message,
</I>&gt;<i> &gt; &gt; but that all queues bound to the exchange have done so. It seems clear
</I>&gt;<i> &gt; &gt; that if I send one message per attached queue, I could create a set of
</I>&gt;<i> &gt; &gt; seqNos and check against that to verify acks for all of the messages,
</I>&gt;<i> &gt; &gt; but without a list of bound queues (which I cannot see how to get),
</I>&gt;<i> &gt; &gt; that does not seem like an option. In any case, it seems likely that
</I>&gt;<i> &gt; &gt; there is something that I am missing here. That said, I would
</I>&gt;<i> &gt; &gt; appreciate any thoughts (or even clarifying questions) on this.
</I>&gt;<i>
</I>&gt;<i> &gt; &gt; Thanks,
</I>&gt;<i> &gt; &gt; Jonathan
</I>&gt;<i> &gt; &gt; _______________________________________________
</I>&gt;<i> &gt; &gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt; &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-disc... at lists.rabbitmq.com</A>
</I>&gt;<i> &gt; &gt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-disc... at lists.rabbitmq.comhttps</A>://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-disc... at lists.rabbitmq.comhttps</A>://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss
</I></PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015245.html">[rabbitmq-discuss] acks from temporary queues
</A></li>
	<LI>Next message: <A HREF="015253.html">[rabbitmq-discuss] acks from temporary queues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15250">[ date ]</a>
              <a href="thread.html#15250">[ thread ]</a>
              <a href="subject.html#15250">[ subject ]</a>
              <a href="author.html#15250">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
