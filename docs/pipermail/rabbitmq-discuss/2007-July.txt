From 0x6e6562 at gmail.com  Mon Jul  2 08:12:18 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 2 Jul 2007 08:12:18 +0100
Subject: [rabbitmq-discuss] Message expiry in topics
Message-ID: <269388e30707020012jcbf1244k2dfd63ac07cdeac7@mail.gmail.com>

Hi,

I was wondering how topic messages get expired. When publishing a
basic message you can get the expiration field in the BasicProperties
but it's a String so I don't know what the syntax or the value should
be. Is this maybe listed in the spec somewhere?

Thanks,

Ben



From 0x6e6562 at gmail.com  Mon Jul  2 08:27:42 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 2 Jul 2007 08:27:42 +0100
Subject: [rabbitmq-discuss] Binding queues on a topic exchange
Message-ID: <269388e30707020027q369f40f5ya424d41bec12b49a@mail.gmail.com>

Hi,

I was wondering the difference is when a topic listener:

a) Declares a well known queue name within an exchange to consume
from. It is assumed that a routing key has already been bound to this
queue (e.g. by a producer or an admin).

b) Declares a privately named queue and binds a routing key to that
queue that the consumer is interested in listening to.

My assumption would be that in scenario (a), each consumer gets
notified using the same shared data whereas in (b) a copy of each
message is enqueued in the buffer of the consumer's private queue,
thus making this queue not really a pub/sub, but more really P2P.

Is this assumption correct?

Thanks,

Ben



From matthias at lshift.net  Mon Jul  2 20:25:34 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 02 Jul 2007 20:25:34 +0100
Subject: [rabbitmq-discuss] Binding queues on a topic exchange
In-Reply-To: <269388e30707020027q369f40f5ya424d41bec12b49a@mail.gmail.com>
	(Ben Hood's message of "Mon, 2 Jul 2007 08:27:42 +0100")
References: <269388e30707020027q369f40f5ya424d41bec12b49a@mail.gmail.com>
Message-ID: <lyzm2ewqtt.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> I was wondering the difference is when a topic listener:
>
> a) Declares a well known queue name within an exchange to consume
> from. It is assumed that a routing key has already been bound to this
> queue (e.g. by a producer or an admin).

Let me rephrase that slightly: You have declared a topic exchange and a
queue bound to that exchange with a particular pattern. Your consumers
all consume messages from that queue. Correct?

> b) Declares a privately named queue and binds a routing key to that
> queue that the consumer is interested in listening to.

Let me rephrase that slightly: You have declared a topic exchange (as
before). Each consumer creates a private queue that it binds to the
topic exchange with a particular pattern. Correct?

> My assumption would be that in scenario (a), each consumer gets
> notified using the same shared data whereas in (b) a copy of each
> message is enqueued in the buffer of the consumer's private queue,
> thus making this queue not really a pub/sub, but more really P2P.
>
> Is this assumption correct?

For a topic exchange, a message gets delivered to all queues that match
the message's routing key with their binding pattern.

When you have multiple consumers on one queue, every message gets
delivered to *one* of the consumers.

So, taking your above cases, in the first example every message with a
matching routing key will be delivered to *one* of the consumers, and in
the second case every message with a given routing key is delivered to
*all* queues that match the routing key with their pattern, and then in
turn to the consumer(s) hanging off those queues (one per queue in this
example).


Regards,


Matthias



From matthias at lshift.net  Mon Jul  2 20:33:33 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 02 Jul 2007 20:33:33 +0100
Subject: [rabbitmq-discuss] Message expiry in topics
In-Reply-To: <269388e30707020012jcbf1244k2dfd63ac07cdeac7@mail.gmail.com> (Ben
	Hood's message of "Mon, 2 Jul 2007 08:12:18 +0100")
References: <269388e30707020012jcbf1244k2dfd63ac07cdeac7@mail.gmail.com>
Message-ID: <lyved2wqgi.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> I was wondering how topic messages get expired. When publishing a
> basic message you can get the expiration field in the BasicProperties
> but it's a String so I don't know what the syntax or the value should
> be. Is this maybe listed in the spec somewhere?

The spec is silent on this.

RabbitMQ treats 'expiration' as an opaque field - we pass it along but
don't do anything with it.


Regards,


Matthias.



From 0x6e6562 at gmail.com  Tue Jul  3 07:15:29 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Tue, 3 Jul 2007 07:15:29 +0100
Subject: [rabbitmq-discuss] Binding queues on a topic exchange
In-Reply-To: <lyzm2ewqtt.fsf@tanto.lshift.net>
References: <269388e30707020027q369f40f5ya424d41bec12b49a@mail.gmail.com>
	<lyzm2ewqtt.fsf@tanto.lshift.net>
Message-ID: <269388e30707022315gbf601b4nb9cdd1f97b24e692@mail.gmail.com>

Matthias,

> Let me rephrase that slightly: You have declared a topic exchange and a
> queue bound to that exchange with a particular pattern. Your consumers
> all consume messages from that queue. Correct?

Correct.

>
> > b) Declares a privately named queue and binds a routing key to that
> > queue that the consumer is interested in listening to.
>
> Let me rephrase that slightly: You have declared a topic exchange (as
> before). Each consumer creates a private queue that it binds to the
> topic exchange with a particular pattern. Correct?

Correct.

>
> > My assumption would be that in scenario (a), each consumer gets
> > notified using the same shared data whereas in (b) a copy of each
> > message is enqueued in the buffer of the consumer's private queue,
> > thus making this queue not really a pub/sub, but more really P2P.
> >
> > Is this assumption correct?
>
> For a topic exchange, a message gets delivered to all queues that match
> the message's routing key with their binding pattern.
>
> When you have multiple consumers on one queue, every message gets
> delivered to *one* of the consumers.
>
> So, taking your above cases, in the first example every message with a
> matching routing key will be delivered to *one* of the consumers, and in
> the second case every message with a given routing key is delivered to
> *all* queues that match the routing key with their pattern, and then in
> turn to the consumer(s) hanging off those queues (one per queue in this
> example).

So in order to have all consumers receive a copy of every piece of
published data (e.g. for a price feed) you would have to go for option
(b). Is this correct?

BTW, the clarity of your answers is appreciated,

Ben



From matthias at lshift.net  Wed Jul  4 18:46:39 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Wed, 04 Jul 2007 18:46:39 +0100
Subject: [rabbitmq-discuss] Binding queues on a topic exchange
In-Reply-To: <269388e30707022315gbf601b4nb9cdd1f97b24e692@mail.gmail.com> (Ben
	Hood's message of "Tue, 3 Jul 2007 07:15:29 +0100")
References: <269388e30707020027q369f40f5ya424d41bec12b49a@mail.gmail.com>
	<lyzm2ewqtt.fsf@tanto.lshift.net>
	<269388e30707022315gbf601b4nb9cdd1f97b24e692@mail.gmail.com>
Message-ID: <lyzm2cukn4.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> For a topic exchange, a message gets delivered to all queues that match
>> the message's routing key with their binding pattern.
>>
>> When you have multiple consumers on one queue, every message gets
>> delivered to *one* of the consumers.
>>
>> So, taking your above cases, in the first example every message with a
>> matching routing key will be delivered to *one* of the consumers, and in
>> the second case every message with a given routing key is delivered to
>> *all* queues that match the routing key with their pattern, and then in
>> turn to the consumer(s) hanging off those queues (one per queue in this
>> example).
>
> So in order to have all consumers receive a copy of every piece of
> published data (e.g. for a price feed) you would have to go for option
> (b). Is this correct?


Indeed.


Matthias.



From 0x6e6562 at gmail.com  Thu Jul  5 15:29:12 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Thu, 5 Jul 2007 15:29:12 +0100
Subject: [rabbitmq-discuss] Fwd:  Message expiry in topics
In-Reply-To: <269388e30707022328u37e4837fja6853ba9fa15fd7b@mail.gmail.com>
References: <269388e30707020012jcbf1244k2dfd63ac07cdeac7@mail.gmail.com>
	<lyved2wqgi.fsf@tanto.lshift.net>
	<269388e30707022328u37e4837fja6853ba9fa15fd7b@mail.gmail.com>
Message-ID: <269388e30707050729x2f3937e9rf8a2b954a50e9082@mail.gmail.com>

(Forwarding to the list)

> The spec is silent on this.
>
> RabbitMQ treats 'expiration' as an opaque field - we pass it along but
> don't do anything with it.

The scenario where I was thinking about this has been covered by the
other post, because I was imagining a topic with many readers that
each get each message delivered to them once. So for example with a
price feed, you set up a queue per consumer and the queue could
persumeably be cleaned up when the consumer dies. You would not need
to have messages expire or manually purge the queue, if the cleanup
were automatic. Does this work with rabbitmq?

Also, if you publish to an exchange with a routing key for which there
is no bound queue, then what happens to those messages (this is a
scenario where there is a producer but no interested consumers)?



From matthias at lshift.net  Thu Jul  5 15:36:34 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Thu, 05 Jul 2007 15:36:34 +0100
Subject: [rabbitmq-discuss] Fwd:  Message expiry in topics
In-Reply-To: <269388e30707050729x2f3937e9rf8a2b954a50e9082@mail.gmail.com>
	(Ben Hood's message of "Thu, 5 Jul 2007 15:29:12 +0100")
References: <269388e30707020012jcbf1244k2dfd63ac07cdeac7@mail.gmail.com>
	<lyved2wqgi.fsf@tanto.lshift.net>
	<269388e30707022328u37e4837fja6853ba9fa15fd7b@mail.gmail.com>
	<269388e30707050729x2f3937e9rf8a2b954a50e9082@mail.gmail.com>
Message-ID: <lyps36syrx.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> RabbitMQ treats 'expiration' as an opaque field - we pass it along but
>> don't do anything with it.
>
> The scenario where I was thinking about this has been covered by the
> other post, because I was imagining a topic with many readers that
> each get each message delivered to them once. So for example with a
> price feed, you set up a queue per consumer and the queue could
> persumeably be cleaned up when the consumer dies. You would not need
> to have messages expire or manually purge the queue, if the cleanup
> were automatic. Does this work with rabbitmq?

Yes, as required by the spec, auto-delete queues are deleted when the
consumer disappears, and any messages they held at the time are
purged. There is one exception: in our current implementation persistent
messages that are present at queue deletion time are not removed from
the persistent store. We will implement that in a future release.

> Also, if you publish to an exchange with a routing key for which there
> is no bound queue, then what happens to those messages (this is a
> scenario where there is a producer but no interested consumers)?

That depends on the settings of the 'mandatory' flag in basic.publish.
<quote>
      This flag tells the server how to react if the message cannot be
      routed to a queue.  If this flag is set, the server will return an
      unroutable message with a Return method.  If this flag is zero, the
      server silently drops the message.
</quote>


Regards,

Matthias.



From 0x6e6562 at gmail.com  Sat Jul  7 19:47:20 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sat, 7 Jul 2007 19:47:20 +0100
Subject: [rabbitmq-discuss] Calls to management functions
Message-ID: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>

Hi,

I've been trying to execute the JSON based Manager which makes an RPC
to "amq.rabbitmq.management". After the basicPublish call returns, the
client blocks on a BlockingCell indefineately. Do you have to turn
some management function on in the rabbitmq server (I just started
rabbit out of the erl shell with application:start(rabbit) )?

Thanks,

Ben



From 0x6e6562 at gmail.com  Sat Jul  7 21:09:32 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sat, 7 Jul 2007 21:09:32 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
Message-ID: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>

Hi,

I'm trying to implement a RPC backend to handle client calls. So I
thought I could create a consumer that consumes from the RPC queue and
sends the reply back to the replyTo address. This is the delivery
callback of my consumer:

@Override
public void handleDelivery(AMQP.Basic.Deliver method,
AMQP.BasicProperties properties, byte[] body) throws IOException {

            channel.basicPublish(ticket, "foo", properties.replyTo,
ChannelN.BASIC_PROPERTIES, "bar".getBytes());

}

However, the RPC client still blocks on it's own consumption of the
reply, indicating that the reply wasn't published correctly.

Are there any examples of how this is done using the java API?

Thanks,

Ben



From 0x6e6562 at gmail.com  Sat Jul  7 21:34:57 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sat, 7 Jul 2007 21:34:57 +0100
Subject: [rabbitmq-discuss] Fwd: Implementing an RPC backend
In-Reply-To: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
Message-ID: <269388e30707071334p28565f12q3384061f5328bd36@mail.gmail.com>

I've made a further discovery which may help: I've implemented the
return listener on the RPC backend which returns a BasicReturn method
(312,unroutable). I've now just got to investigate where this comes
from.



From matthias at lshift.net  Sun Jul  8 07:22:05 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 08 Jul 2007 07:22:05 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	(Ben Hood's message of "Sat, 7 Jul 2007 21:09:32 +0100")
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
Message-ID: <lyejjjqusy.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> @Override
> public void handleDelivery(AMQP.Basic.Deliver method,
> AMQP.BasicProperties properties, byte[] body) throws IOException {
>
>             channel.basicPublish(ticket, "foo", properties.replyTo,
> ChannelN.BASIC_PROPERTIES, "bar".getBytes());
>
> }
>
> However, the RPC client still blocks on it's own consumption of the
> reply, indicating that the reply wasn't published correctly.

I suspect that in the 1.0.0-alpha client the above results in a
deadlock. A thread dump should tell you whether that is the case.

One way to get around the deadlock is to let handleDelivery push
requests onto a Java queue, and process that from a different
thread. The next version of the client API has a QueuingConsumer class
for that purpose, and is generally less prone to deadlocks.


Matthias.



From matthias at lshift.net  Sun Jul  8 07:41:57 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 08 Jul 2007 07:41:57 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com> (Ben
	Hood's message of "Sat, 7 Jul 2007 19:47:20 +0100")
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
Message-ID: <lyabu7qtvu.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> I've been trying to execute the JSON based Manager which makes an RPC
> to "amq.rabbitmq.management". After the basicPublish call returns, the
> client blocks on a BlockingCell indefineately.

Can you supply more details, so I can try reproducing this?

> Do you have to turn some management function on in the rabbitmq server

It should be enabled by default.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul  8 10:13:16 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 8 Jul 2007 10:13:16 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <lyejjjqusy.fsf@tanto.lshift.net>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
Message-ID: <269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>

Matthias,


> I suspect that in the 1.0.0-alpha client the above results in a
> deadlock. A thread dump should tell you whether that is the case.
>
> One way to get around the deadlock is to let handleDelivery push
> requests onto a Java queue, and process that from a different
> thread.

OK, I'll have a look.

I debugged the route method in rabbit_exchange, which does a mnesia
lookup of the replyTo routing key:

Handlers = case rabbit_misc:clean_read({binding, BindingKey}) of
		   {error, not_found} ->
		       handlers_for_missing_binding_record(X, RoutingKey);
		   {ok, #binding{handlers = H}} ->
		       H
	       end,

This returns [], so it seems to be at that point that the message is
unroutable. I found this last night, so I'll have a look to see what
the contents of the binding table in mnesia is. I tried initially with
TV, but it's difficult to see the actual content with that. I'll try
using the API.

> The next version of the client API has a QueuingConsumer class
> for that purpose, and is generally less prone to deadlocks.

Is any of this code available in a repository?

Thanks,

Ben



From matthias at lshift.net  Sun Jul  8 10:22:23 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 08 Jul 2007 10:22:23 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	(Ben Hood's message of "Sun, 8 Jul 2007 10:13:16 +0100")
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
Message-ID: <ly1wfjqmgg.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> I suspect that in the 1.0.0-alpha client the above results in a
>> deadlock. A thread dump should tell you whether that is the case.
>>
>> One way to get around the deadlock is to let handleDelivery push
>> requests onto a Java queue, and process that from a different
>> thread.
>
> OK, I'll have a look.

This may be a red herring. I think it's only RPCs that should be avoided
inside handleDelivery, and basicPublish isn't an RPC. Also, your tests
seem to indicate that the reply does actually reach the server, and
fails at the routing stage.

> I debugged the route method in rabbit_exchange, which does a mnesia
> lookup of the replyTo routing key:
>
> Handlers = case rabbit_misc:clean_read({binding, BindingKey}) of
> 		   {error, not_found} ->
> 		       handlers_for_missing_binding_record(X, RoutingKey);
> 		   {ok, #binding{handlers = H}} ->
> 		       H
> 	       end,
>
> This returns [], so it seems to be at that point that the message is
> unroutable. I found this last night, so I'll have a look to see what
> the contents of the binding table in mnesia is. I tried initially with
> TV, but it's difficult to see the actual content with that. I'll try
> using the API.

I find mnesia:dump_to_textfile/1 quite useful in debugging this sort of
problem.

>> The next version of the client API has a QueuingConsumer class
>> for that purpose, and is generally less prone to deadlocks.
>
> Is any of this code available in a repository?

No, but the new release will be out soon.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul  8 10:25:23 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 8 Jul 2007 10:25:23 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <lyabu7qtvu.fsf@tanto.lshift.net>
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
Message-ID: <269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>

> Can you supply more details, so I can try reproducing this?

Server side: I'm running rabbit without a node name from an erlang
shell using application:start(rabbit). Only the erlang compiled code
is in the path, i.e. I ran erl -pa rabbitmq/ebin

Client side: I ran the main method of the Manager utility:
com.rabbitmq.tools.Manager localhost 5672 without changing anything.

It just blocks at line 173 in RpcClient:

Object reply = k.uninterruptibleGet();

which is where my other test client was blocking as well.

I'll try a thread dump, but it doesn't look like this because I can
see that the main loop of the client is running and is still reading
and writing frames in the background (presumeably heartbeats).

The server is not outputing any error logs for this.



From 0x6e6562 at gmail.com  Sun Jul  8 10:30:44 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 8 Jul 2007 10:30:44 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <ly1wfjqmgg.fsf@tanto.lshift.net>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	<ly1wfjqmgg.fsf@tanto.lshift.net>
Message-ID: <269388e30707080230r4b1b4910x8273649fb42d2ebb@mail.gmail.com>

> This may be a red herring. I think it's only RPCs that should be avoided
> inside handleDelivery, and basicPublish isn't an RPC. Also, your tests
> seem to indicate that the reply does actually reach the server, and
> fails at the routing stage.

Do you mean to say that what I am doing is the wrong way to implement
the server side of an RPC using the rabbitmq API? Is there a better
way to achieve this?

[Just to clarify: I am listening on a queue that an RPC client
publishes to and then I publish a response using the replyTo
destination the client supplied as a routing key]



From matthias at lshift.net  Sun Jul  8 10:49:36 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 08 Jul 2007 10:49:36 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <269388e30707080230r4b1b4910x8273649fb42d2ebb@mail.gmail.com>
	(Ben Hood's message of "Sun, 8 Jul 2007 10:30:44 +0100")
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	<ly1wfjqmgg.fsf@tanto.lshift.net>
	<269388e30707080230r4b1b4910x8273649fb42d2ebb@mail.gmail.com>
Message-ID: <lywsxbp6mn.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> This may be a red herring. I think it's only RPCs that should be
>> avoided inside handleDelivery, and basicPublish isn't an RPC. Also,
>> your tests seem to indicate that the reply does actually reach the
>> server, and fails at the routing stage.
>
> Do you mean to say that what I am doing is the wrong way to implement
> the server side of an RPC using the rabbitmq API?

No, I was just pointing out that I was probably wrong in suggesting that
the problem you are seeing is due to a deadlock on the client API.


Matthias.



From matthias at lshift.net  Sun Jul  8 11:01:26 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 08 Jul 2007 11:01:26 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com> (Ben
	Hood's message of "Sun, 8 Jul 2007 10:25:23 +0100")
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
	<269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>
Message-ID: <lysl7zp62x.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> Server side: I'm running rabbit without a node name from an erlang
> shell using application:start(rabbit).

iirc running the server without a nodename is ok in 1.0.0-alpha, but it
is not something we recommend.

> Only the erlang compiled code is in the path, i.e. I ran erl -pa
> rabbitmq/ebin

Are the rfc4627 libs on your erlang load path?

> Client side: I ran the main method of the Manager utility:
> com.rabbitmq.tools.Manager localhost 5672 without changing anything.
>
> It just blocks at line 173 in RpcClient:

This works fine for me, running against our latest dev snapshot. I may
give it a try against 1.0.0-alpha later, if I find the time.

I should point out that the JSON-RPC interface and any tools built on
top of it, e.g. com.rabbitmq.tools.Manager, are highly experimental.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul  8 11:49:25 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 8 Jul 2007 11:49:25 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
Message-ID: <269388e30707080349p7bd3c39egfda41a67c36a846e@mail.gmail.com>

> I debugged the route method in rabbit_exchange, which does a mnesia
> lookup of the replyTo routing key:
>
> Handlers = case rabbit_misc:clean_read({binding, BindingKey}) of
>                    {error, not_found} ->
>                        handlers_for_missing_binding_record(X, RoutingKey);
>                    {ok, #binding{handlers = H}} ->
>                        H
>                end,
>
> This returns [], so it seems to be at that point that the message is
> unroutable. I found this last night, so I'll have a look to see what
> the contents of the binding table in mnesia is. I tried initially with
> TV, but it's difficult to see the actual content with that. I'll try
> using the API.

I've found the problem why the mnesia lookup wasn't returning anything
although the there was a binding for the reply queue that the RPC set.

Because I called

@Override public void handleDelivery(AMQP.Basic.Deliver method,
AMQP.BasicProperties properties, byte[] body) throws IOException {

            channel.basicPublish(ticket,method.exchange,
properties.replyTo, true, true,properties,"bar".getBytes());

}

The resulting mnesia lookup was:

{binding_spec,{resource,<<"localhost">>,exchange,<<x2>>},
                                 <<"amq.q.gen5_nonode at nohost_20070708102701_">>,
                                 []}

where x2 = method.exchange.

But the actual record in the database is

{binding_spec,{resource,<<"localhost">>,exchange,<<>>},
                                 <<"amq.q.gen5_nonode at nohost_20070708102701_">>,
                                 []}

i.e. with no named exchange. Therefore the solution was to use an
empty string for the exchange property when called the publish method:

@Override public void handleDelivery(AMQP.Basic.Deliver method,
AMQP.BasicProperties properties, byte[] body) throws IOException {

            channel.basicPublish(ticket,"", properties.replyTo, true,
true,properties,"bar".getBytes());

}

I imagine this behaviour is described in the spec to some extent as well.



From 0x6e6562 at gmail.com  Sun Jul  8 12:05:06 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 8 Jul 2007 12:05:06 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <lysl7zp62x.fsf@tanto.lshift.net>
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
	<269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>
	<lysl7zp62x.fsf@tanto.lshift.net>
Message-ID: <269388e30707080405k560868cdtdc8179359cd39166@mail.gmail.com>

>
> > Only the erlang compiled code is in the path, i.e. I ran erl -pa
> > rabbitmq/ebin
>
> Are the rfc4627 libs on your erlang load path?

No, I don't think that they are. I assume that if it was, then

6> code:load_file(rfc4627).
{error,nofile}

would not return a nofile.

> I should point out that the JSON-RPC interface and any tools built on
> top of it, e.g. com.rabbitmq.tools.Manager, are highly experimental.

Actually I am thinking of restating my problem. What I would like to
achieve is to invoke:

a) RPC calls against my own application API
b) Management calls to administer users on the exchange

I would also prefer to just use AMQP as a transport rather than bring
in HTTP on the side (isn't that the whole point of having an AMQP
client?).

To achieve (a) I think I can use the binary RPC mechanism (that I've
just got to work) and I can use Hessian as a wireformat  (which is my
preferred encoding). This actually seems to work.

To achieve (b), maybe I can use the same as (a), but implement my own
listener that invokes the rabbit internal API (don't know whether this
is re-inventing the wheel).



From 0x6e6562 at gmail.com  Sun Jul  8 12:20:50 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 8 Jul 2007 12:20:50 +0100
Subject: [rabbitmq-discuss] Multiple consumers
Message-ID: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com>

When I start a consumer, I assume that the amount of concurrency you
can get on consumption is the amount of consumer threads that you
start to listen on a queue.

That is, if I am using the java client, if I only register one
consumer, then the consumption of messages to a topic is going to be
single threaded.

Is this

a) because the client doesn't execute the handleDelivery callback in a
worker thread,

b) this is a concern of the consumer, and so it should spawn new
threads if it wants to consume messages concurrenly

c) basic consume is the wrong mechanism for a competing consumer
design pattern, i.e. you should try polling using a basic get, for
example

?

I assume also that the same logic applies if you implement your
consumers using the native erlang API.

BTW, what things do you have to consider when using the native API, if
you want to program your application in erlang. As far as I can tell,
it's pretty straightforward with the semantics being the same as the
java API except that you don't have the framing in the middle.



From matthias at lshift.net  Sun Jul  8 16:52:30 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 08 Jul 2007 16:52:30 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <269388e30707080349p7bd3c39egfda41a67c36a846e@mail.gmail.com>
	(Ben Hood's message of "Sun, 8 Jul 2007 11:49:25 +0100")
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	<269388e30707080349p7bd3c39egfda41a67c36a846e@mail.gmail.com>
Message-ID: <lyodimq4e9.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> Therefore the solution was to use an empty string for the exchange
> property when called the publish method:
>
> @Override public void handleDelivery(AMQP.Basic.Deliver method,
> AMQP.BasicProperties properties, byte[] body) throws IOException {
>
>             channel.basicPublish(ticket,"", properties.replyTo, true,
> true,properties,"bar".getBytes());
>
> }
>
> I imagine this behaviour is described in the spec to some extent as
> well.

The format of the reply-to field is not specified in AMQP 0-8 or
0-9. This will be addressed in AMQP 0-10. See
  https://wiki.108.redhat.com/jira/browse/AMQP-58


Regards,

Matthias.



From matthias at lshift.net  Mon Jul  9 09:56:49 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 09 Jul 2007 09:56:49 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <269388e30707080405k560868cdtdc8179359cd39166@mail.gmail.com>
	(Ben Hood's message of "Sun, 8 Jul 2007 12:05:06 +0100")
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
	<269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>
	<lysl7zp62x.fsf@tanto.lshift.net>
	<269388e30707080405k560868cdtdc8179359cd39166@mail.gmail.com>
Message-ID: <lyfy3yosz2.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> Are the rfc4627 libs on your erlang load path?
>
> No, I don't think that they are. I assume that if it was, then
>
> 6> code:load_file(rfc4627).
> {error,nofile}
>
> would not return a nofile.

Correct. In that case com.rabbitmq.tools.Manager will definitely fail,
since RabbitMQ needs the rfc4627 libs for marshalling/unmarshalling.

You can download the rfc4627 libs from
  http://www.lshift.net/~tonyg/rfc4627-1.0.3.tar.gz
or get them via darcs from
  http://www.lshift.net/~tonyg/erlang-rfc4627/

> Actually I am thinking of restating my problem. What I would like to
> achieve is to invoke:
>
> a) RPC calls against my own application API
> b) Management calls to administer users on the exchange
>
> I would also prefer to just use AMQP as a transport rather than bring
> in HTTP on the side (isn't that the whole point of having an AMQP
> client?).
>
> To achieve (a) I think I can use the binary RPC mechanism (that I've
> just got to work) and I can use Hessian as a wireformat  (which is my
> preferred encoding). This actually seems to work.

The above approach seems reasonable.

> To achieve (b), maybe I can use the same as (a), but implement my own
> listener that invokes the rabbit internal API (don't know whether this
> is re-inventing the wheel).

Indeed that would be re-inventing the wheel. I prefer your original
approach of using RabbitMQ's management service. Yes it is experimental
and incomplete, but it is a reasonable foundation you can build on. We'd
be happy to incorporate your enhancements into the main code base.


Matthias.



From 0x6e6562 at gmail.com  Mon Jul  9 10:39:03 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 9 Jul 2007 10:39:03 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <lyfy3yosz2.fsf@tanto.lshift.net>
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
	<269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>
	<lysl7zp62x.fsf@tanto.lshift.net>
	<269388e30707080405k560868cdtdc8179359cd39166@mail.gmail.com>
	<lyfy3yosz2.fsf@tanto.lshift.net>
Message-ID: <269388e30707090239x24218d8eo39a1139fcee2800b@mail.gmail.com>

> > To achieve (b), maybe I can use the same as (a), but implement my own
> > listener that invokes the rabbit internal API (don't know whether this
> > is re-inventing the wheel).
>
> Indeed that would be re-inventing the wheel. I prefer your original
> approach of using RabbitMQ's management service. Yes it is experimental
> and incomplete, but it is a reasonable foundation you can build on. We'd
> be happy to incorporate your enhancements into the main code base.

Speaking of re-inventing the wheel, I based my RPC handler on the
rabbit_management module, which included a fair amount of copy and
paste. Since rabbit_management is an implementation of the gen_server
behaviour, I was wondering if there is any merit in abstracting out
the template callbacks (i.e. handle_management_message() and reply()
), so that this could be more reuseable with different (a) server
functionality and (b) different wireformats. At the moment, this
module can only invoke rabbitmq management calls ( point (a) ) and
only works with JSON ( point (b) ). I don't whether you can have a
behaviour within a behaviour or whether you can have a parameterizable
gen_server implementation.



From alexis.richardson at cohesiveft.com  Mon Jul  9 13:02:10 2007
From: alexis.richardson at cohesiveft.com (Alexis Richardson)
Date: Mon, 9 Jul 2007 13:02:10 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <lyodimq4e9.fsf@tanto.lshift.net>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	<269388e30707080349p7bd3c39egfda41a67c36a846e@mail.gmail.com>
	<lyodimq4e9.fsf@tanto.lshift.net>
Message-ID: <167204d20707090502i458831f9j99319f3ce6f7f668@mail.gmail.com>

Ben,

How are you getting on with RPC?  Along with 'reply to', it's a hot
topic for the AMQP 0-10 spec, so your thoughts on this would be very
useful.  What use cases do you think are interesting here?

alexis




On 7/8/07, Matthias Radestock <matthias at lshift.net> wrote:
> Ben,
>
> "Ben Hood" <0x6e6562 at gmail.com> writes:
>
> > Therefore the solution was to use an empty string for the exchange
> > property when called the publish method:
> >
> > @Override public void handleDelivery(AMQP.Basic.Deliver method,
> > AMQP.BasicProperties properties, byte[] body) throws IOException {
> >
> >             channel.basicPublish(ticket,"", properties.replyTo, true,
> > true,properties,"bar".getBytes());
> >
> > }
> >
> > I imagine this behaviour is described in the spec to some extent as
> > well.
>
> The format of the reply-to field is not specified in AMQP 0-8 or
> 0-9. This will be addressed in AMQP 0-10. See
>   https://wiki.108.redhat.com/jira/browse/AMQP-58
>
>
> Regards,
>
> Matthias.
>
> _______________________________________________
> rabbitmq-discuss mailing list
> rabbitmq-discuss at lists.rabbitmq.com
> http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss
>


-- 
Alexis Richardson
+44 20 7617 7339 (UK)
+44 77 9865 2911 (cell)
+1 650 206 2517 (US)



From 0x6e6562 at gmail.com  Mon Jul  9 15:07:08 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 9 Jul 2007 15:07:08 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <167204d20707090502i458831f9j99319f3ce6f7f668@mail.gmail.com>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	<269388e30707080349p7bd3c39egfda41a67c36a846e@mail.gmail.com>
	<lyodimq4e9.fsf@tanto.lshift.net>
	<167204d20707090502i458831f9j99319f3ce6f7f668@mail.gmail.com>
Message-ID: <269388e30707090707x4e6d54a2x13a1b30db8071a31@mail.gmail.com>

> How are you getting on with RPC?  Along with 'reply to', it's a hot
> topic for the AMQP 0-10 spec, so your thoughts on this would be very
> useful.  What use cases do you think are interesting here?

I've got a complete RPC end to end working using Hessian as a
serialization mechanism. The client is the RpcClient taking a hessian
encoded byte array to the primitiveCall method. On the server side
what I did was to adapt the rabbit_management module to implement my
own gen_server module. The server is started by an OTP supervisor
(I've created an OTP app using rabbit as dependency) and the module
just contains the bare bones gen_server behaviour callbacks as well as
the business logic. I refactored the exchange initialization, message
parsing, hessian decoding, function invocation, reply encoding and
sending to an external rpc utility module for more generic reuse (for
example if I want to have other servers that implement different
business logic).

As for the spec, I think that using the replyTo field as a routing key
is quite inituitive, so for my part, I think that rabbit's behaviour
is the correct one in this case. I don't know if I can think of any
funky use cases, because what I am currently doing in this use case is
plain old RPC, with the benefit that it's executed asynchronously. If
I understand you correctly, whether or not the RPC mechanism should be
more explicity defined in the spec is a matter of convenience on the
client side, IMHO. When it comes to spec design, I think it's a matter
of opinion as to whether you have a reduced instruction set or not. I
would opt for a reduced instruction set to keep the spec as small as
possible, ease uptake, ease version upgrades and to keep the server
side implementations as simple as possible.

HTH,

Ben



From matthias at lshift.net  Mon Jul  9 15:13:22 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 09 Jul 2007 15:13:22 +0100
Subject: [rabbitmq-discuss] Multiple consumers
In-Reply-To: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com> (Ben
	Hood's message of "Sun, 8 Jul 2007 12:20:50 +0100")
References: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com>
Message-ID: <lyir8tmzr1.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> When I start a consumer, I assume that the amount of concurrency you
> can get on consumption is the amount of consumer threads that you
> start to listen on a queue.
>
> That is, if I am using the java client, if I only register one
> consumer, then the consumption of messages to a topic is going to be
> single threaded.
>
> Is this
>
> a) because the client doesn't execute the handleDelivery callback in a
> worker thread,
>
> b) this is a concern of the consumer, and so it should spawn new
> threads if it wants to consume messages concurrenly
>
> c) basic consume is the wrong mechanism for a competing consumer
> design pattern, i.e. you should try polling using a basic get, for
> example

I gather that what you are trying to accomplish is to pull items off a
queue and process them concurrently, correct?

The Java client libraries use one thread per connection, and the
handleDelivery callback is executed in that. So in order to process
messages concurrently you need to do one of the following:

- use multiple connections

- spawn a thread, perhaps from a pool, in handleDelivery

- introduce some Java queuing / synchronisation to let handleDelivery
pass messages to a pool of worker threads.

There is some support for the last method in the next version of the
client libraries, which introduces a QueuingConsumer class that places a
deliveries into a Java queue from where they can be removed by worker
threads. There are many possible alternative designs though. For
example, you may want to use a bounded queue in order to get some flow
control.

> I assume also that the same logic applies if you implement your
> consumers using the native erlang API.

Are you referring to the queue API that is used by the management
service? In that case, yes, in essence you have similar design choices
there on how to process the 'deliver' messages sent to the native queue
process. Be aware though that with this API you are implementing a
*queue*, not a *client*. So, for example, you end up blocking the
channel process through which the message was sent until you return from
the 'deliver' call.

> BTW, what things do you have to consider when using the native API, if
> you want to program your application in erlang. As far as I can tell,
> it's pretty straightforward with the semantics being the same as the
> java API except that you don't have the framing in the middle.

That depends on what APIs you are using. Much of the AMQP semantics is
concerned with notions of connections and channels, and much of the that
is tied up with networking code in the rabbit_{reader,writer,channel}
modules. Also, many aspects of the protocol, such as access control, are
dealt with in rabbit_channel, since they are closely tied to the notion
of a channel. So if you are bypassing all that and instead are directly
calling into the modules for exchange, queue etc, then quite a big chunk
of AMQP is cut out, though you are still left with the "essence" of
routing and queuing.

A should also point out that none of the Erlang APIs are official, and
they *will* change.

Several people have asked whether there is an Erlang client for AMQP,
i.e. an Erlang API that implements the client portion of the
protocol. There currently isn't, but it is definitely something we'd
like to see developed. Contributions are welcome. Such a client would
present a relatively stable and interoperable API for Erlang code
wanting to use AMQP. It could also be designed in a way that allows the
framing to be bypassed when talking to RabbitMQ.


Matthias.



From 0x6e6562 at gmail.com  Mon Jul  9 15:13:32 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 9 Jul 2007 15:13:32 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <167204d20707090502i458831f9j99319f3ce6f7f668@mail.gmail.com>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	<269388e30707080349p7bd3c39egfda41a67c36a846e@mail.gmail.com>
	<lyodimq4e9.fsf@tanto.lshift.net>
	<167204d20707090502i458831f9j99319f3ce6f7f668@mail.gmail.com>
Message-ID: <269388e30707090713h71622ab4pb52da899283f34a0@mail.gmail.com>

> How are you getting on with RPC?  Along with 'reply to', it's a hot
> topic for the AMQP 0-10 spec, so your thoughts on this would be very
> useful.  What use cases do you think are interesting here?

BTW, is there a mailing list for spec specific topics at all? I've
noticed that you can send messages via the wiki on amqp.org and that
there's a spec related JIRA at redhat. Is this the main forum?



From matthias at lshift.net  Mon Jul  9 15:23:22 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 09 Jul 2007 15:23:22 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <269388e30707090239x24218d8eo39a1139fcee2800b@mail.gmail.com>
	(Ben Hood's message of "Mon, 9 Jul 2007 10:39:03 +0100")
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
	<269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>
	<lysl7zp62x.fsf@tanto.lshift.net>
	<269388e30707080405k560868cdtdc8179359cd39166@mail.gmail.com>
	<lyfy3yosz2.fsf@tanto.lshift.net>
	<269388e30707090239x24218d8eo39a1139fcee2800b@mail.gmail.com>
Message-ID: <lyejjhmzad.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> Speaking of re-inventing the wheel, I based my RPC handler on the
> rabbit_management module, which included a fair amount of copy and
> paste. Since rabbit_management is an implementation of the gen_server
> behaviour, I was wondering if there is any merit in abstracting out
> the template callbacks (i.e. handle_management_message() and reply()
> ), so that this could be more reuseable with different (a) server
> functionality and (b) different wireformats. At the moment, this
> module can only invoke rabbitmq management calls ( point (a) ) and
> only works with JSON ( point (b) ). I don't whether you can have a
> behaviour within a behaviour or whether you can have a parameterizable
> gen_server implementation.

There two ways to do this in general:

1) make the particular gen_server implementation higher-order. In the
above case we would pass handle_management_message etc functions as
arguments on initialisation.

2) create a custom behaviour


Matthias.



From 0x6e6562 at gmail.com  Mon Jul  9 15:47:51 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 9 Jul 2007 15:47:51 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <lyejjhmzad.fsf@tanto.lshift.net>
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
	<269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>
	<lysl7zp62x.fsf@tanto.lshift.net>
	<269388e30707080405k560868cdtdc8179359cd39166@mail.gmail.com>
	<lyfy3yosz2.fsf@tanto.lshift.net>
	<269388e30707090239x24218d8eo39a1139fcee2800b@mail.gmail.com>
	<lyejjhmzad.fsf@tanto.lshift.net>
Message-ID: <269388e30707090747p580e8e32ja4cc8f2f20974a1e@mail.gmail.com>

> There two ways to do this in general:
>
> 1) make the particular gen_server implementation higher-order. In the
> above case we would pass handle_management_message etc functions as
> arguments on initialisation.

I looked into this by trying to parameterize the server with a
callback module. However, I was starting the server in a supervision
tree and the child specification calls apply/3 on the server under the
hood which doesn't allow to parameterize the server. I couldn't see
how to do by passing a function to the init() method, because I would
need to register this in the handle_call() callback. I suppose you
could save it to a database in the init method and then query it in
the handle_call() method, but this seems a bit complicated to me.

>
> 2) create a custom behaviour

Looked into that as well. However, extending the gen_server behaviour
only adds extra callbacks that you would have implement in each
implementation in addition to the standard callback, hence not saving
you any code.

What I ended up doing (I don't know if this is the most elegant
solution, but it seemed to be pragmatic) was to adapt the
rabbit_management module to implement my
own gen_server module. The server is started by an OTP supervisor
(I've created an OTP app using rabbit as dependency) and the module
just contains the bare bones gen_server behaviour callbacks as well as
the business logic. I refactored the exchange initialization, message
parsing, hessian decoding, function invocation, reply encoding and
sending to an external rpc utility module for more generic reuse (for
example if I want to have other servers that implement different
business logic).



From matthias at lshift.net  Mon Jul  9 16:11:38 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 09 Jul 2007 16:11:38 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <269388e30707090747p580e8e32ja4cc8f2f20974a1e@mail.gmail.com>
	(Ben Hood's message of "Mon, 9 Jul 2007 15:47:51 +0100")
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
	<269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>
	<lysl7zp62x.fsf@tanto.lshift.net>
	<269388e30707080405k560868cdtdc8179359cd39166@mail.gmail.com>
	<lyfy3yosz2.fsf@tanto.lshift.net>
	<269388e30707090239x24218d8eo39a1139fcee2800b@mail.gmail.com>
	<lyejjhmzad.fsf@tanto.lshift.net>
	<269388e30707090747p580e8e32ja4cc8f2f20974a1e@mail.gmail.com>
Message-ID: <lytzsdlihh.fsf@tanto.lshift.net>

"Ben Hood" <0x6e6562 at gmail.com> writes:

> I looked into this by trying to parameterize the server with a
> callback module. However, I was starting the server in a supervision
> tree and the child specification calls apply/3 on the server under the
> hood which doesn't allow to parameterize the server. I couldn't see
> how to do by passing a function to the init() method, because I would
> need to register this in the handle_call() callback. I suppose you
> could save it to a database in the init method and then query it in
> the handle_call() method, but this seems a bit complicated to me.

This is really an Erlang question, so perhaps we should move over to
erlang-questions. ...

Anyway, say you want to delegate all handle_call() invocations of a
particular gen_server instance to a particular function. You'd make that
function part of the gen_server's state, initialised as part of init(),
and call it in handle_call(). If the process is part of a supervision
tree then the function needs to be passed in as part of the child_spec.

>> 2) create a custom behaviour
>
> Looked into that as well. However, extending the gen_server behaviour
> only adds extra callbacks that you would have implement in each
> implementation in addition to the standard callback, hence not saving
> you any code.

Right. The difficulty here is that we don't just want to implement some
custom behaviour, but want our implementation to be compatible with
the gen_server behaviour. IIRC this issue has been brought up before on
erlang-questions, so it's probably worth checking the archives.


Matthias.



From 0x6e6562 at gmail.com  Mon Jul  9 16:13:38 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 9 Jul 2007 16:13:38 +0100
Subject: [rabbitmq-discuss] Multiple consumers
In-Reply-To: <lyir8tmzr1.fsf@tanto.lshift.net>
References: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com>
	<lyir8tmzr1.fsf@tanto.lshift.net>
Message-ID: <269388e30707090813ld16c239rbc1a8e1f90a155ce@mail.gmail.com>

Matthias,

> I gather that what you are trying to accomplish is to pull items off a
> queue and process them concurrently, correct?

Correct.

>
> The Java client libraries use one thread per connection, and the
> handleDelivery callback is executed in that. So in order to process
> messages concurrently you need to do one of the following:
>
> - use multiple connections
>
> - spawn a thread, perhaps from a pool, in handleDelivery
>
> - introduce some Java queuing / synchronisation to let handleDelivery
> pass messages to a pool of worker threads.
>
> There is some support for the last method in the next version of the
> client libraries, which introduces a QueuingConsumer class that places a
> deliveries into a Java queue from where they can be removed by worker
> threads. There are many possible alternative designs though. For
> example, you may want to use a bounded queue in order to get some flow
> control.

Understood.

>
> > I assume also that the same logic applies if you implement your
> > consumers using the native erlang API.
>
> Are you referring to the queue API that is used by the management
> service? In that case, yes, in essence you have similar design choices
> there on how to process the 'deliver' messages sent to the native queue
> process. Be aware though that with this API you are implementing a
> *queue*, not a *client*. So, for example, you end up blocking the
> channel process through which the message was sent until you return from
> the 'deliver' call.

Thanks for pointing this out. When you say that, do you mean the
defining a queue using the pseudo_queue method is implementing a queue
rather than a client, e.g.

Queue = rabbit_amqqueue:pseudo_queue(RealmName, QueueName, self())

Can I avoid this blocking by using the rabbit_amqqueue:basic_consume()
method instead?

>
> > BTW, what things do you have to consider when using the native API, if
> > you want to program your application in erlang. As far as I can tell,
> > it's pretty straightforward with the semantics being the same as the
> > java API except that you don't have the framing in the middle.
>
> That depends on what APIs you are using. Much of the AMQP semantics is
> concerned with notions of connections and channels, and much of the that
> is tied up with networking code in the rabbit_{reader,writer,channel}
> modules. Also, many aspects of the protocol, such as access control, are
> dealt with in rabbit_channel, since they are closely tied to the notion
> of a channel. So if you are bypassing all that and instead are directly
> calling into the modules for exchange, queue etc, then quite a big chunk
> of AMQP is cut out, though you are still left with the "essence" of
> routing and queuing.

Basically I have a remote consumers using the Java API and I have
implemented business services in Erlang, which has the *luxury* of
being able to call the API without having to frame methods and send
stuff over a wire. So I think it quite good to just be able to use the
asynchronous processing capabilities of the actual exchange.
Furthermore, if use Erlang on the server side, I don't need to worry
about concurrency issues and limitations that you would do in Java
(please correct me if I'm wrong).

>
> A should also point out that none of the Erlang APIs are official, and
> they *will* change.
>
> Several people have asked whether there is an Erlang client for AMQP,
> i.e. an Erlang API that implements the client portion of the
> protocol. There currently isn't, but it is definitely something we'd
> like to see developed. Contributions are welcome. Such a client would
> present a relatively stable and interoperable API for Erlang code
> wanting to use AMQP. It could also be designed in a way that allows the
> framing to be bypassed when talking to RabbitMQ.

Have you got any pointers as to how to go about this? I mean, would
you just define

a) The data structures as part of the interface spec (i.e. the
rabbit.hrl header file)
b) Methods to be exposed to client, e.g. openChannel0, openChannelN,
accessRequest, basicConsume, basicPublish, etc
c) Then implement these exported functions by sending the appropriate
messages to the appropriate internal servers?


Ben



From alexis.richardson at cohesiveft.com  Mon Jul  9 16:39:34 2007
From: alexis.richardson at cohesiveft.com (Alexis Richardson)
Date: Mon, 9 Jul 2007 16:39:34 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <269388e30707090713h71622ab4pb52da899283f34a0@mail.gmail.com>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	<269388e30707080349p7bd3c39egfda41a67c36a846e@mail.gmail.com>
	<lyodimq4e9.fsf@tanto.lshift.net>
	<167204d20707090502i458831f9j99319f3ce6f7f668@mail.gmail.com>
	<269388e30707090713h71622ab4pb52da899283f34a0@mail.gmail.com>
Message-ID: <167204d20707090839l2436514dscd898967c91ad18e@mail.gmail.com>

Ben

We are working with colleagues in the AMQP Working Group to 'open that
up' more.  Currently it is just a bit too painful to get a good
dialogue across 'users of the spec'.  I think this will change when:

a) the Wiki and JIRA are moved to amqp.org from redhat (this is in process)
b) AMQP 0-10 is out (this is soon)

For now people are discussing the spec through product centric lists
like this one for RabbitMQ.

alexis


On 7/9/07, Ben Hood <0x6e6562 at gmail.com> wrote:
> > How are you getting on with RPC?  Along with 'reply to', it's a hot
> > topic for the AMQP 0-10 spec, so your thoughts on this would be very
> > useful.  What use cases do you think are interesting here?
>
> BTW, is there a mailing list for spec specific topics at all? I've
> noticed that you can send messages via the wiki on amqp.org and that
> there's a spec related JIRA at redhat. Is this the main forum?
>
> _______________________________________________
> rabbitmq-discuss mailing list
> rabbitmq-discuss at lists.rabbitmq.com
> http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss
>


-- 
Alexis Richardson
+44 20 7617 7339 (UK)
+44 77 9865 2911 (cell)
+1 650 206 2517 (US)



From alexis.richardson at cohesiveft.com  Mon Jul  9 16:43:44 2007
From: alexis.richardson at cohesiveft.com (Alexis Richardson)
Date: Mon, 9 Jul 2007 16:43:44 +0100
Subject: [rabbitmq-discuss] Implementing an RPC backend
In-Reply-To: <269388e30707090707x4e6d54a2x13a1b30db8071a31@mail.gmail.com>
References: <269388e30707071309r7a446cd1j23583d5d417ab92f@mail.gmail.com>
	<lyejjjqusy.fsf@tanto.lshift.net>
	<269388e30707080213x65f3ef1cl28bf27c045915caf@mail.gmail.com>
	<269388e30707080349p7bd3c39egfda41a67c36a846e@mail.gmail.com>
	<lyodimq4e9.fsf@tanto.lshift.net>
	<167204d20707090502i458831f9j99319f3ce6f7f668@mail.gmail.com>
	<269388e30707090707x4e6d54a2x13a1b30db8071a31@mail.gmail.com>
Message-ID: <167204d20707090843p13d7bfb4s1b533d84d86c6673@mail.gmail.com>

Ben

It does help thanks.

A reduced instruction set is seen as essential by the AMQP Working
Group, because not everyone needs to use more than a few base cases.
Watch this space over the next few months for some ideas on that.

ReplyTo is where things are heading as a core enabler for RPC.  I was
in fact curious as to whether you might be trying to replicate some of
what goes on with JMS, since that is a requirement driving some of the
RPC and addressing work in AMQP - we want to get interop right
obviously.

alexis


On 7/9/07, Ben Hood <0x6e6562 at gmail.com> wrote:
> > How are you getting on with RPC?  Along with 'reply to', it's a hot
> > topic for the AMQP 0-10 spec, so your thoughts on this would be very
> > useful.  What use cases do you think are interesting here?
>
> I've got a complete RPC end to end working using Hessian as a
> serialization mechanism. The client is the RpcClient taking a hessian
> encoded byte array to the primitiveCall method. On the server side
> what I did was to adapt the rabbit_management module to implement my
> own gen_server module. The server is started by an OTP supervisor
> (I've created an OTP app using rabbit as dependency) and the module
> just contains the bare bones gen_server behaviour callbacks as well as
> the business logic. I refactored the exchange initialization, message
> parsing, hessian decoding, function invocation, reply encoding and
> sending to an external rpc utility module for more generic reuse (for
> example if I want to have other servers that implement different
> business logic).
>
> As for the spec, I think that using the replyTo field as a routing key
> is quite inituitive, so for my part, I think that rabbit's behaviour
> is the correct one in this case. I don't know if I can think of any
> funky use cases, because what I am currently doing in this use case is
> plain old RPC, with the benefit that it's executed asynchronously. If
> I understand you correctly, whether or not the RPC mechanism should be
> more explicity defined in the spec is a matter of convenience on the
> client side, IMHO. When it comes to spec design, I think it's a matter
> of opinion as to whether you have a reduced instruction set or not. I
> would opt for a reduced instruction set to keep the spec as small as
> possible, ease uptake, ease version upgrades and to keep the server
> side implementations as simple as possible.
>
> HTH,
>
> Ben
>
> _______________________________________________
> rabbitmq-discuss mailing list
> rabbitmq-discuss at lists.rabbitmq.com
> http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss
>


-- 
Alexis Richardson
+44 20 7617 7339 (UK)
+44 77 9865 2911 (cell)
+1 650 206 2517 (US)



From 0x6e6562 at gmail.com  Mon Jul  9 16:46:12 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 9 Jul 2007 16:46:12 +0100
Subject: [rabbitmq-discuss] Calls to management functions
In-Reply-To: <lytzsdlihh.fsf@tanto.lshift.net>
References: <269388e30707071147n5b2d86ecg124acb71a2b8af0@mail.gmail.com>
	<lyabu7qtvu.fsf@tanto.lshift.net>
	<269388e30707080225y148b17beg4d30cb397f6a260@mail.gmail.com>
	<lysl7zp62x.fsf@tanto.lshift.net>
	<269388e30707080405k560868cdtdc8179359cd39166@mail.gmail.com>
	<lyfy3yosz2.fsf@tanto.lshift.net>
	<269388e30707090239x24218d8eo39a1139fcee2800b@mail.gmail.com>
	<lyejjhmzad.fsf@tanto.lshift.net>
	<269388e30707090747p580e8e32ja4cc8f2f20974a1e@mail.gmail.com>
	<lytzsdlihh.fsf@tanto.lshift.net>
Message-ID: <269388e30707090846p46360b22l4e97c69ef6695176@mail.gmail.com>

> This is really an Erlang question, so perhaps we should move over to
> erlang-questions. ...
>
> Anyway, say you want to delegate all handle_call() invocations of a
> particular gen_server instance to a particular function. You'd make that
> function part of the gen_server's state, initialised as part of init(),
> and call it in handle_call(). If the process is part of a supervision
> tree then the function needs to be passed in as part of the child_spec.

Thanks for your patience Matthias, as this is actually a schoolboy
question about Erlang and a case of me not RTFM of gen_server. The
manual actually says, the init method returns the internal state of
the server which is passed to the handle_* callbacks. So I just passed
the module that implements the business logic via the supervisor to
the init method and the whole thing is *much* simpler. I'll consult
erlang-questions next time.

Ben



From matthias at lshift.net  Mon Jul  9 16:56:26 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 09 Jul 2007 16:56:26 +0100
Subject: [rabbitmq-discuss] Multiple consumers
In-Reply-To: <269388e30707090813ld16c239rbc1a8e1f90a155ce@mail.gmail.com> (Ben
	Hood's message of "Mon, 9 Jul 2007 16:13:38 +0100")
References: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com>
	<lyir8tmzr1.fsf@tanto.lshift.net>
	<269388e30707090813ld16c239rbc1a8e1f90a155ce@mail.gmail.com>
Message-ID: <lymyy5lget.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> Are you referring to the queue API that is used by the management
>> service? In that case, yes, in essence you have similar design
>> choices there on how to process the 'deliver' messages sent to the
>> native queue process. Be aware though that with this API you are
>> implementing a *queue*, not a *client*. So, for example, you end up
>> blocking the channel process through which the message was sent until
>> you return from the 'deliver' call.
>
> Thanks for pointing this out. When you say that, do you mean the
> defining a queue using the pseudo_queue method is implementing a queue
> rather than a client, e.g.
>
> Queue = rabbit_amqqueue:pseudo_queue(RealmName, QueueName, self())

Correct.

> Can I avoid this blocking by using the rabbit_amqqueue:basic_consume()
> method instead?

You could use a real queue instead of a pseudo queue, and, yes, then you
can use rabbit_amqqueue:basic_consume to consume messages. That requires
that your code implements the rabbit_writer message interface instead.

> Basically I have a remote consumers using the Java API and I have
> implemented business services in Erlang, which has the *luxury* of
> being able to call the API without having to frame methods and send
> stuff over a wire. So I think it quite good to just be able to use the
> asynchronous processing capabilities of the actual exchange.
> Furthermore, if use Erlang on the server side, I don't need to worry
> about concurrency issues and limitations that you would do in Java
> (please correct me if I'm wrong).

All sounds perfectly sensible.

>> Several people have asked whether there is an Erlang client for AMQP,
>> i.e. an Erlang API that implements the client portion of the
>> protocol. There currently isn't, but it is definitely something we'd
>> like to see developed. Contributions are welcome. Such a client would
>> present a relatively stable and interoperable API for Erlang code
>> wanting to use AMQP. It could also be designed in a way that allows the
>> framing to be bypassed when talking to RabbitMQ.
>
> Have you got any pointers as to how to go about this? I mean, would
> you just define
>
> a) The data structures as part of the interface spec (i.e. the
> rabbit.hrl header file)
> b) Methods to be exposed to client, e.g. openChannel0, openChannelN,
> accessRequest, basicConsume, basicPublish, etc
> c) Then implement these exported functions by sending the appropriate
> messages to the appropriate internal servers?

TBH, we haven't given this much thought yet. I have dug out a response
to an earlier email on the subject, sent before this list existed:

<quote>
If you want to build a proper AMQP client that implements the protocol
and is thus able to communicate with other AMQP-compliant brokers, you
have several options.

One approach would be to use our current framing code (auto-generated
from the protocol specification XML document) as the core, and refactor
the reader/writer state machines from rabbit_reader and rabbit_writer
into a generic AMQP peer library that could be used efficiently by both
a client and a broker implementation. This is most likely the approach
we will be taking.

Alternatively, you could build a fresh reader/writer state machine
specifically for client work. This would have the advantage of exposing
any AMQP-client-specific requirements that could then be refactored into
a common transport library at a later date.
</quote>

The above doesn't address the idea of bypassing the framing when the
Erlang client talks to RabbitMQ. I reckon that could be accomplished by
some further refactoring of reader/writer/channel, to separate out the
transport specific bits. We'll need to do that at some point anyway in
order to implement other transports, like SCTP.

One thing to be aware of is that this area of the code will be revised
quite heavily when we implement AMQP 0-10.


Regards,


Matthias.



From 0x6e6562 at gmail.com  Mon Jul  9 17:16:11 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 9 Jul 2007 17:16:11 +0100
Subject: [rabbitmq-discuss] Multiple consumers
In-Reply-To: <lymyy5lget.fsf@tanto.lshift.net>
References: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com>
	<lyir8tmzr1.fsf@tanto.lshift.net>
	<269388e30707090813ld16c239rbc1a8e1f90a155ce@mail.gmail.com>
	<lymyy5lget.fsf@tanto.lshift.net>
Message-ID: <269388e30707090916j3d8cc2f6q956353ecfa57173b@mail.gmail.com>

> You could use a real queue instead of a pseudo queue, and, yes, then you
> can use rabbit_amqqueue:basic_consume to consume messages. That requires
> that your code implements the rabbit_writer message interface instead.

When you say that the consumer should implement the rabbit_writer
message interface, am I correct in assuming that the
internal_send_command methods can be ignored, because these these are
channel specific?

-export([start/4, shutdown/1, mainloop/1]).
-export([send_command/2, send_command/3, deliver/6, deliver/7,
pause/1, unpause/2]).
-export([internal_send_command/3, internal_send_command/5]).

That is, the internal_send_command methods handle framing and socket
I/O and would not be invoked by a native client.

> One thing to be aware of is that this area of the code will be revised
> quite heavily when we implement AMQP 0-10.

Then I guess you are saying that unless you have a good idea about how
to abstract this away, then wait until 0-10 is implemented?



From matthias at lshift.net  Mon Jul  9 17:40:25 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 09 Jul 2007 17:40:25 +0100
Subject: [rabbitmq-discuss] Multiple consumers
In-Reply-To: <269388e30707090916j3d8cc2f6q956353ecfa57173b@mail.gmail.com>
	(Ben Hood's message of "Mon, 9 Jul 2007 17:16:11 +0100")
References: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com>
	<lyir8tmzr1.fsf@tanto.lshift.net>
	<269388e30707090813ld16c239rbc1a8e1f90a155ce@mail.gmail.com>
	<lymyy5lget.fsf@tanto.lshift.net>
	<269388e30707090916j3d8cc2f6q956353ecfa57173b@mail.gmail.com>
Message-ID: <lyejjhledi.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> You could use a real queue instead of a pseudo queue, and, yes, then you
>> can use rabbit_amqqueue:basic_consume to consume messages. That requires
>> that your code implements the rabbit_writer message interface instead.
>
> When you say that the consumer should implement the rabbit_writer
> message interface

What I meant is that your process must handle the same messages,
i.e. {send_command, ...}, {deliver, ...}, {pause, ...} etc.

>> One thing to be aware of is that this area of the code will be revised
>> quite heavily when we implement AMQP 0-10.
>
> Then I guess you are saying that unless you have a good idea about how
> to abstract this away, then wait until 0-10 is implemented?

No. The code base is fairly small, so it won't bee too much of a burden
to carry forward any changes in this area. I just wanted to alert you to
the fact that the APIs will definitely change.



Matthias.



From wgriffin at fraktured.net  Thu Jul 19 04:37:53 2007
From: wgriffin at fraktured.net (Wesley Griffin)
Date: Wed, 18 Jul 2007 23:37:53 -0400
Subject: [rabbitmq-discuss] Any change of getting Ubuntu 6.06 packages?
Message-ID: <d125a150707182037p19698654h4579fafd28eaa37f@mail.gmail.com>

I have an Ubuntu Dapper 6.06 server. I tried adding the RabbitMQ APT
repository and using it, but it doesn't like the erlang versions
availabe. Is there any chance of getting packages for Ubuntu 6.06
available via a repo or should I just install manually?

Thanks!
Wes

Here is some output from apt-get:

server:~ sudo apt-get install rabbitmq-server
Reading package lists... Done
Building dependency tree... Done
Some packages could not be installed. This may mean that you have
requested an impossible situation or if you are using the unstable
distribution that some required packages have not yet been created
or been moved out of Incoming.

Since you only requested a single operation it is extremely likely that
the package is simply not installable and a bug report against
that package should be filed.
The following information may help to resolve the situation:

The following packages have unmet dependencies:
  rabbitmq-server: Depends: erlang-nox but it is not going to be installed
E: Broken packages

server:~ sudo apt-get install erlang-nox
Reading package lists... Done
Building dependency tree... Done
Some packages could not be installed. This may mean that you have
requested an impossible situation or if you are using the unstable
distribution that some required packages have not yet been created
or been moved out of Incoming.

Since you only requested a single operation it is extremely likely that
the package is simply not installable and a bug report against
that package should be filed.
The following information may help to resolve the situation:

The following packages have unmet dependencies:
  erlang-nox: Depends: erlang-base (>= 1:11.b.3-tonyg1) but 1:10.b.7-1
is to be installed or
                       erlang-base-hipe (>= 1:11.b.3-tonyg1) but it is
not installable
E: Broken packages



From 0x6e6562 at gmail.com  Thu Jul 19 07:49:24 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Thu, 19 Jul 2007 07:49:24 +0100
Subject: [rabbitmq-discuss] Any change of getting Ubuntu 6.06 packages?
In-Reply-To: <d125a150707182037p19698654h4579fafd28eaa37f@mail.gmail.com>
References: <d125a150707182037p19698654h4579fafd28eaa37f@mail.gmail.com>
Message-ID: <269388e30707182349y6ae45b0bg38650e4ed97b46b2@mail.gmail.com>

Wes,

Does Erlang on its own install properly using APT?

I would try to get just the Erlang intrepreter working, and then you
can download the rabbit binaries and just unpack them and run them.

HTH,

Ben

> The following packages have unmet dependencies:
>   erlang-nox: Depends: erlang-base (>= 1:11.b.3-tonyg1) but 1:10.b.7-1
> is to be installed or
>                        erlang-base-hipe (>= 1:11.b.3-tonyg1) but it is
> not installable
> E: Broken packages



From yvette.chanco at cohesiveft.com  Thu Jul 19 17:16:56 2007
From: yvette.chanco at cohesiveft.com (Yvette Chanco)
Date: Thu, 19 Jul 2007 11:16:56 -0500
Subject: [rabbitmq-discuss] Any change of getting Ubuntu 6.06 packages?
In-Reply-To: <269388e30707182349y6ae45b0bg38650e4ed97b46b2@mail.gmail.com>
References: <d125a150707182037p19698654h4579fafd28eaa37f@mail.gmail.com>
	<269388e30707182349y6ae45b0bg38650e4ed97b46b2@mail.gmail.com>
Message-ID: <D7D601BA-081B-4FEC-80EE-999071EDD8C8@cohesiveft.com>

I work with cohesiveft and lshift on bundling rabbitmq into various  
final targets (it's actually the topic of my talk at Ubuntu Live on  
Sunday).

So, qualifying that I've only been testing on feisty and and edgy,  
not dapper, and that the version of erlang available in dapper is  
1:10, what I've found to be the issue usually is a few dependencies  
down, on the libssl level. Since it's within my power to do so, I  
solve the problem by making a custom repo with just the rabbitmq- 
server and librabbitmq-java packages, which means that an "apt-get  
install rabbitmq-server" will pull the dependencies from the standard  
repo for the running system. However, as not everybody likes to build  
their own repo, the other option is...

Don't use the lshift repository (deb http://dev.rabbitmq.com/debian/  
unstable/), but do make sure that the lines for universe in your  
sources.list are uncommented. Erlang is a universe component.

   sudo apt-get update
   sudo apt-get install erlang-base erlang-nox
   wget http://dev.rabbitmq.com/debian/unstable/rabbitmq-server_1.0.0- 
alpha-2_all.deb
   wget http://dev.rabbitmq.com/debian/unstable/librabbitmq- 
java_1.0.0-alpha-1_all.deb
   sudo dpkg -i rabbitmq-server_1.0.0-alpha-2_all.deb librabbitmq- 
java_1.0.0-alpha-1_all.deb

As Ben says, though, once you get erlang installed you could also use  
the binaries. As long as they work with 1:10, which (as I mentioned  
above) I haven't tested. If it doesn't work, the possible solutions  
for 6.06 would be more.... interesting.

-Yvette

On Jul 19, 2007, at 1:49 AM, Ben Hood wrote:

> Wes,
>
> Does Erlang on its own install properly using APT?
>
> I would try to get just the Erlang intrepreter working, and then you
> can download the rabbit binaries and just unpack them and run them.
>
> HTH,
>
> Ben
>
>> The following packages have unmet dependencies:
>>   erlang-nox: Depends: erlang-base (>= 1:11.b.3-tonyg1) but 1:10.b. 
>> 7-1
>> is to be installed or
>>                        erlang-base-hipe (>= 1:11.b.3-tonyg1) but  
>> it is
>> not installable
>> E: Broken packages
>
> _______________________________________________
> rabbitmq-discuss mailing list
> rabbitmq-discuss at lists.rabbitmq.com
> http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss




From simon at lshift.net  Thu Jul 19 17:36:55 2007
From: simon at lshift.net (Simon MacMullen)
Date: Thu, 19 Jul 2007 17:36:55 +0100
Subject: [rabbitmq-discuss] Any change of getting Ubuntu 6.06 packages?
In-Reply-To: <D7D601BA-081B-4FEC-80EE-999071EDD8C8@cohesiveft.com>
References: <d125a150707182037p19698654h4579fafd28eaa37f@mail.gmail.com>	<269388e30707182349y6ae45b0bg38650e4ed97b46b2@mail.gmail.com>
	<D7D601BA-081B-4FEC-80EE-999071EDD8C8@cohesiveft.com>
Message-ID: <469F9327.5090707@lshift.net>

Yvette Chanco wrote:
> However, as not everybody likes to build  
> their own repo, the other option is...
> 
> Don't use the lshift repository (deb http://dev.rabbitmq.com/debian/  
> unstable/), but do make sure that the lines for universe in your  
> sources.list are uncommented. Erlang is a universe component.

Just to follow up on this: we're aware that this is a problem. I'm not 
sure why our repository includes Erlang at the moment but I'm pretty 
sure it shouldn't.

When we produce the next release we'll be revamping our repository 
somewhat and will fix this. We'll also be looking at testing a bit more 
with Ubuntu...

Cheers, Simon

-- 
   [][][] Simon MacMullen
     [][] LShift Ltd
   []  [] www.lshift.net



From 0x6e6562 at gmail.com  Thu Jul 19 23:35:43 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Thu, 19 Jul 2007 23:35:43 +0100
Subject: [rabbitmq-discuss] Multiple consumers
In-Reply-To: <lyejjhledi.fsf@tanto.lshift.net>
References: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com>
	<lyir8tmzr1.fsf@tanto.lshift.net>
	<269388e30707090813ld16c239rbc1a8e1f90a155ce@mail.gmail.com>
	<lymyy5lget.fsf@tanto.lshift.net>
	<269388e30707090916j3d8cc2f6q956353ecfa57173b@mail.gmail.com>
	<lyejjhledi.fsf@tanto.lshift.net>
Message-ID: <269388e30707191535j3df7f191t31b43e9f854beb0c@mail.gmail.com>

Matthias,

> No. The code base is fairly small, so it won't bee too much of a burden
> to carry forward any changes in this area. I just wanted to alert you to
> the fact that the APIs will definitely change.

Sorry, its taken a while but I've been otherwise busy. I've made a
first cut of an erlang client AMQP with the necessary changes in
rabbit_reader, rabbit_channel0 and rabbit_channel (see attached
patch).

This patch is not complete, but I wanted to submit it for a sanity
check before I go off down the garden path.

The change consists of

1. an amqp_client module, which exports a similar API to the Java API.
The implementation uses the rabbit native API sparingly, in fact, the
call to any concrete rabbit function could be a init parameter making
it totally rabbit agnostic at compile time. It sends AMQP methods as
standard erlang messages, but it could be further abstracted to be
able to add framing if one wanted to connect to a foreign AMQP server
via TCP (should the need arise). At the moment this also includes some
preprocessor definitions from rabbit.hrl and rabbit_framing.hrl, but
these are AMQP specific and could be refactored away as well.

2. Changes to the rabbit_reader, rabbit_channel0 and rabbit_channel
modules to bypass socket I/O and framing. I've tried to keep the
amount of code duplication to a bar minimum.

To use it you load amqp_client into the same VM as rabbit, then

1. amqp_client:start_link().
2. amqp_client:open_channel(1, "").
3. amqp_client:access_request(1, "/data/REALM_NAME").

And that's where I stopped before this sanity check, but I would go on
in the same vain with the rest of the protocol.

The amqp_client uses the gen_server behaviour so that it can maintain
protocol state as well as the state of channel pids, user creditials
and tickets.

Also, the error handling is still quite agricultural (exits need to be
trapped) and the client lifecycle needs some thought as well (e.g. how
to stop it cleanly).

Anyway, any suggestions would be greatly appreciated,

Ben
-------------- next part --------------
A non-text attachment was scrubbed...
Name: erlang_client_1.patch
Type: application/octet-stream
Size: 19242 bytes
Desc: not available
Url : http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20070719/24a97075/attachment.obj 

From matthias at lshift.net  Fri Jul 20 14:41:46 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Fri, 20 Jul 2007 14:41:46 +0100
Subject: [rabbitmq-discuss] Multiple consumers
In-Reply-To: <269388e30707191535j3df7f191t31b43e9f854beb0c@mail.gmail.com>
	(Ben Hood's message of "Thu, 19 Jul 2007 23:35:43 +0100")
References: <269388e30707080420s6e85aaa6rfdb4610d2fcecd6@mail.gmail.com>
	<lyir8tmzr1.fsf@tanto.lshift.net>
	<269388e30707090813ld16c239rbc1a8e1f90a155ce@mail.gmail.com>
	<lymyy5lget.fsf@tanto.lshift.net>
	<269388e30707090916j3d8cc2f6q956353ecfa57173b@mail.gmail.com>
	<lyejjhledi.fsf@tanto.lshift.net>
	<269388e30707191535j3df7f191t31b43e9f854beb0c@mail.gmail.com>
Message-ID: <lyk5svxkdh.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> Sorry, its taken a while but I've been otherwise busy. I've made a
> first cut of an erlang client AMQP with the necessary changes in
> rabbit_reader, rabbit_channel0 and rabbit_channel (see attached
> patch).
>
> This patch is not complete, but I wanted to submit it for a sanity
> check before I go off down the garden path.

This looks good. I reckon your core design is sound.

Some things I spotted:

* I don't see the need for routing requests through the rabbit
application process

* The channel processes appear to be pointing to the same process for
both reader and writer. That is useful for the common case of RPC-style
interactions but you also need to support a subscription model along the
lines of the Consumer classes in the Java client.


Overall this is impressive work. Keep us posted on your progress.


Regards,

Matthias.



From 0x6e6562 at gmail.com  Sat Jul 21 03:31:46 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sat, 21 Jul 2007 03:31:46 +0100
Subject: [rabbitmq-discuss] FW:  Multiple consumers
In-Reply-To: <AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
Message-ID: <269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>

>  >>
>  >>* The channel processes appear to be pointing to the same
>  >>process for both reader and writer. That is useful for the
>  >>common case of RPC-style interactions but you also need to
>  >>support a subscription model along the lines of the Consumer
>  >>classes in the Java client.
>

How about implementing a custom behaviour, spawning a new process and
then passing this pid as this the writer? BTW, why is it that a reader
seems to write data and a writer seems to read data?

Ben



From matthias at lshift.net  Sat Jul 21 07:13:45 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sat, 21 Jul 2007 07:13:45 +0100
Subject: [rabbitmq-discuss] FW:  Multiple consumers
In-Reply-To: <269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	(Ben Hood's message of "Sat, 21 Jul 2007 03:31:46 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
Message-ID: <lyfy3ixp0m.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>>  >>
>>  >>* The channel processes appear to be pointing to the same
>>  >>process for both reader and writer. That is useful for the
>>  >>common case of RPC-style interactions but you also need to
>>  >>support a subscription model along the lines of the Consumer
>>  >>classes in the Java client.
>>
>
> How about implementing a custom behaviour, spawning a new process and
> then passing this pid as this the writer?

A custom behaviour is probably overkill at this stage. The standard
gen_server or gen_event behaviour ought to be sufficient for now.

> BTW, why is it that a reader seems to write data and a writer seems to
> read data?

The reader reads data from the connection and writers write data to the
connection. If you were implementing a network client you'd have the
same roles/processes there and they'd be logically cross-wired, i.e. the
client reader would receive data from the server writers, and the client
writers would send data to the server reader. But since you are
bypassing the network and instead implement and interact with
server-side processes directly the roles appear reversed. This may get
tricky if you later want to bolt-on a networked mode.


Matthias.



From 0x6e6562 at gmail.com  Sat Jul 21 17:10:55 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sat, 21 Jul 2007 17:10:55 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <lyfy3ixp0m.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<lyfy3ixp0m.fsf@tanto.lshift.net>
Message-ID: <269388e30707210910l71be9fcel464345686debf0db@mail.gmail.com>

> A custom behaviour is probably overkill at this stage. The standard
> gen_server or gen_event behaviour ought to be sufficient for now.

Yes, you're right, I'll take look to see if the gen_event behaviour
will do the trick.

>
> > BTW, why is it that a reader seems to write data and a writer seems to
> > read data?
>
> The reader reads data from the connection and writers write data to the
> connection. If you were implementing a network client you'd have the
> same roles/processes there and they'd be logically cross-wired, i.e. the
> client reader would receive data from the server writers, and the client
> writers would send data to the server reader. But since you are
> bypassing the network and instead implement and interact with
> server-side processes directly the roles appear reversed. This may get
> tricky if you later want to bolt-on a networked mode.
>

OK, that makes sense, I'll bear this in mind. Going back to the
orginal problem of setting the correct writer pid, I think I can add a
writer_pid field the the connection record, so that the client can
start a process to handle the subscription (e.g. by passing the Pid of
a gen_event event manager) and pass the Pid to the channel loop.

In general though (i.e. including the socket case), when the channel
loop sends messages to the writer pid, what happens when the writer
dies?



From matthias at lshift.net  Sat Jul 21 20:03:59 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sat, 21 Jul 2007 20:03:59 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707210910l71be9fcel464345686debf0db@mail.gmail.com>
	(Ben Hood's message of "Sat, 21 Jul 2007 17:10:55 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<lyfy3ixp0m.fsf@tanto.lshift.net>
	<269388e30707210910l71be9fcel464345686debf0db@mail.gmail.com>
Message-ID: <lywswtwpcw.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> In general though (i.e. including the socket case), when the channel
> loop sends messages to the writer pid, what happens when the writer
> dies?

In the socket case the writer is spawned on channel creation, and linked
to the channel process. If it exits *ab*normally the channel process
will get killed. That in turn will result in the reader sending back an
'connection.close', and terminating.


Matthias.



From 0x6e6562 at gmail.com  Sat Jul 21 20:30:23 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sat, 21 Jul 2007 20:30:23 +0100
Subject: [rabbitmq-discuss] FW:  Multiple consumers
In-Reply-To: <269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
Message-ID: <269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>

Matthias,

> >  >>* The channel processes appear to be pointing to the same
> >  >>process for both reader and writer. That is useful for the
> >  >>common case of RPC-style interactions but you also need to
> >  >>support a subscription model along the lines of the Consumer
> >  >>classes in the Java client.

Whilst trying to get the channel to send messages to a callback
handler for the subscription model, I've found that I need to set the
writer pid in the channel to the pid of the client to do the protocol
handling (the RPC-style interaction), but in order to get subscription
working I'm going to have to either

a) pass the Pid of a subscriber into the channel
b) have subscription events get sent back to the client process, which
then in turn can forward them on to a subscriber.

As far as I can tell, option (b) will be less intrusive into the
current server implementation at a cost of turning the client into a
pure data shovel for subscription events. If this overhead were
negligible, I would run with it, because it means that the channel
code can remain the same. Also, this is inline with what the java
client does, because it handles data from the socket, deframes it and
hands it off to a worker thread. Furthermore, I feel it is also more
inline with the protocol flow. What do think about taking approach
(b)?

Ben



From matthias at lshift.net  Sat Jul 21 23:42:19 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sat, 21 Jul 2007 23:42:19 +0100
Subject: [rabbitmq-discuss] FW:  Multiple consumers
In-Reply-To: <269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	(Ben Hood's message of "Sat, 21 Jul 2007 20:30:23 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
Message-ID: <lyr6n1wf90.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> Whilst trying to get the channel to send messages to a callback
> handler for the subscription model, I've found that I need to set the
> writer pid in the channel to the pid of the client to do the protocol
> handling (the RPC-style interaction), but in order to get subscription
> working I'm going to have to either
>
> a) pass the Pid of a subscriber into the channel
> b) have subscription events get sent back to the client process, which
> then in turn can forward them on to a subscriber.
>
> As far as I can tell, option (b) will be less intrusive into the
> current server implementation at a cost of turning the client into a
> pure data shovel for subscription events. If this overhead were
> negligible, I would run with it, because it means that the channel
> code can remain the same. Also, this is inline with what the java
> client does, because it handles data from the socket, deframes it and
> hands it off to a worker thread. Furthermore, I feel it is also more
> inline with the protocol flow. What do think about taking approach
> (b)?

In the Java client code it is the *channel* that keeps handles to
Consumers, and dispatches messages to them. So that is actually closer
to option (a).

Ultimately, certainly when moving to a full networked client, you will
end up with reader/channel/writer processes that are wired like this

client         server

reader <------ writer1..n 

channel1..n    channel1..n

writer1..n --> reader

Consumer processes would hang off the client channel1..n processes.

The "wires" may either be straight Erlang communication, bypassing any
framing and marshalling, or fully-fledged AMQP communication of TCP/IP
etc involving framing and marshalling.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul 22 00:23:06 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 22 Jul 2007 00:23:06 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <lyr6n1wf90.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	<lyr6n1wf90.fsf@tanto.lshift.net>
Message-ID: <269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>

Matthias,

> > a) pass the Pid of a subscriber into the channel
> > b) have subscription events get sent back to the client process, which
> > then in turn can forward them on to a subscriber.

> In the Java client code it is the *channel* that keeps handles to
> Consumers, and dispatches messages to them. So that is actually closer
> to option (a).

I agree that the client side terminology uses a *channel* that
dispatches to consumers, but I think we may may actually be talking
about the same thing. The analogy I was trying to draw in option (b)
was that in the Java client you have a thread that deframes data off
the wire and passes it on to event consumers. With the erlang client
in option (b), the server sends all events to the client process which
in turn would multiplex them to the consumers registered with the
client. The difference is that only the client knows about the
existence of the physical consumer process. Option (a) could make use
of the fact that as an erlang process, the server channel could
directly send an event to a consumer process, thus bypassing the
client process as follows:

client                       server

reader 1..n  <-----  writer 1..n

So the question I was trying to ask was: Does this direct dispatch
gain you anything? Certainly it is less intrusive to keep it as you
have illustrated below, at the (potentially negliable) cost of
shoveling data from the server writer to the consumer via the client
reader:


client processes       data shovel        server

consumer 1..n <----- reader <---------- writer 1..n

>
> Ultimately, certainly when moving to a full networked client, you will
> end up with reader/channel/writer processes that are wired like this
>
> client         server
>
> reader <------ writer1..n
>
> channel1..n    channel1..n
>
> writer1..n --> reader
>
> Consumer processes would hang off the client channel1..n processes.
>
> The "wires" may either be straight Erlang communication, bypassing any
> framing and marshalling, or fully-fledged AMQP communication of TCP/IP
> etc involving framing and marshalling.

I like the way you represented this, it helps in clarifying the interaction.

Ben



From matthias at lshift.net  Sun Jul 22 08:04:03 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 22 Jul 2007 08:04:03 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	(Ben Hood's message of "Sun, 22 Jul 2007 00:23:06 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
Message-ID: <lylkd8x6l8.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> Option (a) could make use of the fact that as an erlang process, the
> server channel could directly send an event to a consumer process,
> thus bypassing the client process as follows:
>
> client                       server
>
> reader 1..n  <-----  writer 1..n

The most direct route actually looks more like this:

rpc:
caller --> channel
caller <-- channel

message to subscriber:
consumer <-- channel <-- queue

Here the channel plays the role of the client channel, server channel,
and server writer.

That is reasonably challenging to implement. OTOH it will probably force
the kind of abstractions that would be good to have in any case.

> So the question I was trying to ask was: Does this direct dispatch
> gain you anything?

In the networked case we need to add quite a few actors:

rpc:
caller --> c_channel --> c_writer --> s_reader --> s_channel
caller <-- c_channel <-- c_reader <-- s_writer <-- s_channel

message to subscriber:
consumer <-- c_channel <-- c_reader <-- s_writer <-- queue

I reckon the short-circuit route is worthwhile since it simplifies (and
as a result speeds up) things considerably -- If we are going to have a
direct client at all, we might as well go the most direct route.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul 22 11:01:16 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 22 Jul 2007 11:01:16 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <lylkd8x6l8.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	<lylkd8x6l8.fsf@tanto.lshift.net>
Message-ID: <269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>

Matthias,

> The most direct route actually looks more like this:
>
> rpc:
> caller --> channel
> caller <-- channel
>
> message to subscriber:
> consumer <-- channel <-- queue
>
> Here the channel plays the role of the client channel, server channel,
> and server writer.

Agreed.

>
> That is reasonably challenging to implement. OTOH it will probably force
> the kind of abstractions that would be good to have in any case.

That's why I'm asking the question, because you will need to
incoporate this refactored flow into the flow of the current *socket
based* channel. By passing the messages back to the initiating client
to pass on to the actual subscriber, you don't have to change this.
The only reason I can see right now why you may do this is to optimize
this extra hop away. But as far as I can see, this is only relevant
for the non-networked case, which is why I didn't understand the way
you answered my question about direct dispatching below (because
you're probably envisaging something I haven't thought about).

>
> > So the question I was trying to ask was: Does this direct dispatch
> > gain you anything?
>
> In the networked case we need to add quite a few actors:
>
> rpc:
> caller --> c_channel --> c_writer --> s_reader --> s_channel
> caller <-- c_channel <-- c_reader <-- s_writer <-- s_channel
>
> message to subscriber:
> consumer <-- c_channel <-- c_reader <-- s_writer <-- queue

Agreed.

>
> I reckon the short-circuit route is worthwhile since it simplifies (and
> as a result speeds up) things considerably -- If we are going to have a
> direct client at all, we might as well go the most direct route.

Please understand this in the context of what I said above. I don't
see the relevance of the direct route in the networked case. In the
networked case, you will be using the same socket connection to send
the messages back to the subscriber, so this is exactly the same thing
as the current Java client, as you've correctly pointed out in the
diagram.

So I don't see where the short-circuit route comes into play in the
networked case, only in the non-networked case where you can utilize
erlang message passing.

I hope I haven't totally misunderstood what you have said.

Ben



From matthias at lshift.net  Sun Jul 22 11:18:22 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 22 Jul 2007 11:18:22 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	(Ben Hood's message of "Sun, 22 Jul 2007 11:01:16 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
Message-ID: <lyhcnwwxld.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> So I don't see where the short-circuit route comes into play in the
> networked case, only in the non-networked case where you can utilize
> erlang message passing.

Correct. Nothing I said was meant to indicate otherwise.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul 22 23:52:57 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 22 Jul 2007 23:52:57 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <lyhcnwwxld.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
Message-ID: <269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>

Matthias,

> > So I don't see where the short-circuit route comes into play in the
> > networked case, only in the non-networked case where you can utilize
> > erlang message passing.
>
> Correct. Nothing I said was meant to indicate otherwise.

OK, based on this discussion here's the latest patch.

The additions since the last one are implementations for

-queue_declare/3
-exchange_declare/8
-queue_bind/5
-basic_publish/6
-basic_consume/4

I've included a test for the client and a consumer for the basic
consume registration, which uses the gen_event behaviour.

I've also tested this in conjunction with the Java client, and the
initial tests seem to pass.

I had been looking at implementing the short circuit we've discussed
by sending the subscriber's pid as the consumerTag field in the basic
consume properties, but I thought that would pollute the basic_consume
method in rabbit_amqqueue because you would do do a list_to_pid
conversion of the consumerTag field and if any other non-erlang client
were set consumer tags that just happend to match erlang's Pid
notation, this would break.

So I opted to handle the reception of a consumer pid as an extra field
in the mainloop_without_framing/1 function in the channel.

So if this approach for subscriptions is ok, I will go ahead and
complete the protocol for the native client.

Ben
-------------- next part --------------
A non-text attachment was scrubbed...
Name: erlang_client_2.patch
Type: application/octet-stream
Size: 28685 bytes
Desc: not available
Url : http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20070722/0b688558/attachment.obj 

From chime at mu.dk  Mon Jul 23 00:16:06 2007
From: chime at mu.dk (Michael Arnoldus)
Date: Mon, 23 Jul 2007 01:16:06 +0200
Subject: [rabbitmq-discuss] Use of RabbitMQ with a C client?
Message-ID: <D7FEB81E-1D39-4BC1-B2A7-CA7E6C32E696@mu.dk>

Hi,

I'm investigating the use of AMQP for a new project. We need to be  
able to use AMQP from languages that doesn't yet have an AMQP  
binding. Since most languages have a usable C binding I'm interested  
in how to use a C binding with RabbitMQ. Would it be possible to use  
the OpenAMQ C client to connect to RabbitMQ? Has anybody actually  
tried this?

Regards,

Michael Arnoldus



From chime at mu.dk  Mon Jul 23 00:18:45 2007
From: chime at mu.dk (Michael Arnoldus)
Date: Mon, 23 Jul 2007 01:18:45 +0200
Subject: [rabbitmq-discuss] OpenAMQ vs. RabbitMQ
Message-ID: <D5CA0BDC-B666-4C2C-BB4C-4C33D55A9C20@mu.dk>

Hi,

What is the primary difference between the RabbitMQ server and the  
OpenAMQ server? I know one is in erlang and the other on is in C, and  
I know the difference between these two languages. What I want to  
know is if aqnybody has an idea about the actual differences in the  
current implementations.

I'm guessing, but maybe this question should be part of FAQ?

Regards,

Michael Arnoldus



From alexis.richardson at cohesiveft.com  Mon Jul 23 10:57:30 2007
From: alexis.richardson at cohesiveft.com (Alexis Richardson)
Date: Mon, 23 Jul 2007 10:57:30 +0100
Subject: [rabbitmq-discuss] OpenAMQ vs. RabbitMQ
In-Reply-To: <D5CA0BDC-B666-4C2C-BB4C-4C33D55A9C20@mu.dk>
References: <D5CA0BDC-B666-4C2C-BB4C-4C33D55A9C20@mu.dk>
Message-ID: <167204d20707230257r104b2692qef5fbbd78e4d3e43@mail.gmail.com>

Michael

Both products are mature and useful.  I do not want to discuss
commercial models on this list, so instead shall note the following:

1. The RabbitMQ broker is available under a Mozilla license, MPL 1.1,
and the clients under several licenses.  The OpenAMQ broker is
available under a GPL license, the clients under BSD.

2. I think it is fair to say we have different roadmaps.  I do not
want to speculate on the OpenAMQ roadmap on the RabbitMQ list - it
would not be appropriate.  We want to make best use of what Erlang/OTP
can do - see the FAQ - and I think you'll see more of a bias from us
towards integration with feature-rich business process components, eg
Mule, and some of the FIX products.  On the other hand I think the
iMatix guys are very interested in 'fast and simple' use cases around
transient messaging and multicast.

Please also note that the current releases of RabbitMQ is 1.0, which
implements AMQP 0-8.  The current OpenAMQ broker implements AMQP 0-9.
These two versions of AMQP are almost identical.  We are making
another release of RabbitMQ very soon, and AMQP 0-10 is on its way as
well...

Can you let me know if I have answered your question please?

alexis





On 7/23/07, Michael Arnoldus <chime at mu.dk> wrote:
> Hi,
>
> What is the primary difference between the RabbitMQ server and the
> OpenAMQ server? I know one is in erlang and the other on is in C, and
> I know the difference between these two languages. What I want to
> know is if aqnybody has an idea about the actual differences in the
> current implementations.
>
> I'm guessing, but maybe this question should be part of FAQ?
>
> Regards,
>
> Michael Arnoldus
>
> _______________________________________________
> rabbitmq-discuss mailing list
> rabbitmq-discuss at lists.rabbitmq.com
> http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss
>


-- 
Alexis Richardson
+44 20 7617 7339 (UK)
+44 77 9865 2911 (cell)
+1 650 206 2517 (US)



From alexis.richardson at cohesiveft.com  Mon Jul 23 11:10:32 2007
From: alexis.richardson at cohesiveft.com (Alexis Richardson)
Date: Mon, 23 Jul 2007 11:10:32 +0100
Subject: [rabbitmq-discuss] Use of RabbitMQ with a C client?
In-Reply-To: <D7FEB81E-1D39-4BC1-B2A7-CA7E6C32E696@mu.dk>
References: <D7FEB81E-1D39-4BC1-B2A7-CA7E6C32E696@mu.dk>
Message-ID: <167204d20707230310v4cfa6d54n37175879410d3c0b@mail.gmail.com>

Michael

Yes, this has been tried, but the results have not been reported back
to the community yet.  As I mentioned in my previous email, there is a
slight version mismatch preventing interop 'out of the box'.  Would
you be interested in getting involved with addressing this?

alexis



On 7/23/07, Michael Arnoldus <chime at mu.dk> wrote:
> Hi,
>
> I'm investigating the use of AMQP for a new project. We need to be
> able to use AMQP from languages that doesn't yet have an AMQP
> binding. Since most languages have a usable C binding I'm interested
> in how to use a C binding with RabbitMQ. Would it be possible to use
> the OpenAMQ C client to connect to RabbitMQ? Has anybody actually
> tried this?
>
> Regards,
>
> Michael Arnoldus
>
> _______________________________________________
> rabbitmq-discuss mailing list
> rabbitmq-discuss at lists.rabbitmq.com
> http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss
>


-- 
Alexis Richardson
+44 20 7617 7339 (UK)
+44 77 9865 2911 (cell)
+1 650 206 2517 (US)



From alexis.richardson at cohesiveft.com  Wed Jul 25 14:33:11 2007
From: alexis.richardson at cohesiveft.com (Alexis Richardson)
Date: Wed, 25 Jul 2007 14:33:11 +0100
Subject: [rabbitmq-discuss] interview about Erlang
Message-ID: <167204d20707250633l4d4b321er7cac61db099caf0f@mail.gmail.com>

Hi everyone,

Here is an interview with Joe Armstrong in DDJ in which he talks about
Erlang/OTP:

http://ddj.com/dept/opensource/201001928?cid=RSSfeed_DDJ_OpenSource

It's quite short, but useful for showing to people who have not heard
of the language/platform.

Quote: "Today multi-cores are really like "distributed system on a
chip" with very high-speed message passing. Since we have
share-nothing and concurrency, Erlang programs map beautifully onto
multi-cores. Ericsson is shipping products on dual-cores that run
virtually twice as fast as the uni-cores with only tiny changes to the
code."

alexis



-- 
Alexis Richardson
+44 20 7617 7339 (UK)
+44 77 9865 2911 (cell)
+1 650 206 2517 (US)



From alexis.richardson at cohesiveft.com  Wed Jul 25 15:00:12 2007
From: alexis.richardson at cohesiveft.com (Alexis Richardson)
Date: Wed, 25 Jul 2007 15:00:12 +0100
Subject: [rabbitmq-discuss] AMQP 'BoF'
Message-ID: <167204d20707250700w662185a4v314c8c25cbfd7c0a@mail.gmail.com>

Hi everyone

I am doing a BoF session on "Applying AMQP with Spring, Mule, Ruby,
and Ajax", at 8pm on August 30th, in the evening, at the London
Marriott Hotel Grosvenor Square.

All are welcome.

You can come to the BoF without paying for the whole NFJS conference
by signing up for it here: http://www.nfjs-exchange.com/ejug-bof-amqp

alexis




-- 
Alexis Richardson
+44 20 7617 7339 (UK)
+44 77 9865 2911 (cell)
+1 650 206 2517 (US)



From matthias at lshift.net  Sat Jul 28 09:00:41 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sat, 28 Jul 2007 09:00:41 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	(Ben Hood's message of "Sun, 22 Jul 2007 23:52:57 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<AE8FD6F8A5C7A74EB55A0639892B0A6C158080@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
Message-ID: <lyodhxq7o6.fsf@tanto.lshift.net>

Ben,

Apologies for the delay in responding to you - I have been very busy
this week.

"Ben Hood" <0x6e6562 at gmail.com> writes:

> OK, based on this discussion here's the latest patch.

Looks generally ok, with one caveat: Client channels ought to be
processes. That way you don't funnel everything through a single
process.

In the direct API the client channel processes ought to be the same as
the server channel processes, i.e. the user's client code would interact
directly with the server channel processes.

> So I opted to handle the reception of a consumer pid as an extra field
> in the mainloop_without_framing/1 function in the channel.

You appear to be changing the channel's writer pid with every
basic_consume. That doesn't look right.

think the direct consumer case should actually look like this:

  consumer <-- queue

(which is simpler than what I proposed before)

Queue processes maintain a list of consumer processes. In the direct API
that's the only mapping you need. In the network API the client channel
processes maintain a mapping from consumer tags to consumer processes.

The question is what should the writer_pid be set to in the direct API?

One possibility is to set it to the caller's pid when doing rpc. That
way rpc can be implemented like this:

rpc(ChannelPid, MethodRecord, Content) ->
  ChannelPid ! {method, MethodRecord, Content, self()},
  receive
     {send_command, MethodRecord} -> MethodRecord
     ...
  end.

The tricky bit is how to deal with asynchronous non-consumer events,
i.e. cases where a channel/transaction/queue processes sends messages to
a writer process as part of something other than an rpc or message
delivery. Perhaps the writer_pid should be set to the channel pid?  That
would require some pretty careful coding to avoid deadlock.


I reckon it may be easier to tackle the network API first. It is the
more general case and the refactoring it forces will inform our thinking
on how to best implement the direct API.


Matthias.



From 0x6e6562 at gmail.com  Sat Jul 28 14:54:04 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sat, 28 Jul 2007 14:54:04 +0100
Subject: [rabbitmq-discuss]  FW: Multiple consumers
In-Reply-To: <lyodhxq7o6.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
Message-ID: <269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>

Matthias,

> Apologies for the delay in responding to you - I have been very busy
> this week.

No worries. As it turns out, I sent a follow up mail to this list from
work account on Monday and have just received a notification that it
has been returned because it could not get delivered. I am going to
try to incorporate that into this conversation to try to keep things
in context.

The content of Monday's email is between the snip marks:

--snip--
I've just discovered an issue with the patch I sent:

The basic.consume_ok ack message gets sent to the subscriber and not to
the client reader.

To get around this, I extended the basic_consume/7 function in the
amqqueue module to take an acknowledgement Pid as a further argument (
hence making the function basic_consume/8 ).

In the corresponding function in amqueue_process, I set the replies to
sent to this acknowledgement process.

Then in the channel, extended the ch record with an acknowledgement_pid
field which is set according to the context of the mainloop, so the main
loop decides to which Pid an ack is sent to.

Now the basic.consume_ok goes back to the client control process and
only the deliver method goes to the subscriber.
--snip--

> Looks generally ok, with one caveat: Client channels ought to be
> processes. That way you don't funnel everything through a single
> process.
>
> In the direct API the client channel processes ought to be the same as
> the server channel processes, i.e. the user's client code would interact
> directly with the server channel processes.

Fair point, and I've already begun to refactor the direct client this
week to take this into consideration. What I started to do is to
create a named amqp_client server process for each channel, so that
the protocol flow within a channel is not inhibited by the protocol
flow from another channel that were both using the same amqp_client
process. So everytime a channel is opened by the user, a gen_server
process is started with the name chN at host. An alternative to this
approach would be for the client to save the Pid of the amqp_client
process and expose an API such as

access_request(AmqpClientPid, Realm)

In contrast, if you use the named approach, the API might look this:

access_request(Channel, Host, Realm)

In the Direct API, the host would probably always be the localhost,
but I went initially for a combination of Channel and Host to keep a
consistent API in the networked case. But I think this has been
completely thought through yet, and the each amqp_client process in
the networked case will have to use the same socket connection.

> You appear to be changing the channel's writer pid with every
> basic_consume. That doesn't look right.

Do you mean in the mainloop_without_framing function?

{method, MethodRecord, Content, WriterPid} ->
        State0 = State#ch{writer_pid = WriterPid},
	    State1 = handle_method(MethodRecord, Content, State0),
	    mainloop_without_framing(State1);

If so, yes, I think that is unecessary since I introduced the concept
of an acknowledgement pid. I will have a look at removing that.

If not, then I don't completely understand.

>
> think the direct consumer case should actually look like this:
>
>   consumer <-- queue
>
> (which is simpler than what I proposed before)
>
> Queue processes maintain a list of consumer processes. In the direct API
> that's the only mapping you need. In the network API the client channel
> processes maintain a mapping from consumer tags to consumer processes.

So are you saying that you should pass in the consumer's pid to the
rabbit_amqqueue_process and have that maintain a list of consumers?

I don't think I understand this fully. Can you elaborate?

>
> The question is what should the writer_pid be set to in the direct API?
>
> One possibility is to set it to the caller's pid when doing rpc. That
> way rpc can be implemented like this:
>
> rpc(ChannelPid, MethodRecord, Content) ->
>   ChannelPid ! {method, MethodRecord, Content, self()},
>   receive
>      {send_command, MethodRecord} -> MethodRecord
>      ...
>   end.
>
> The tricky bit is how to deal with asynchronous non-consumer events,
> i.e. cases where a channel/transaction/queue processes sends messages to
> a writer process as part of something other than an rpc or message
> delivery. Perhaps the writer_pid should be set to the channel pid?  That
> would require some pretty careful coding to avoid deadlock.
>
>
> I reckon it may be easier to tackle the network API first. It is the
> more general case and the refactoring it forces will inform our thinking
> on how to best implement the direct API.

You might be right on this, but I don't see how the networked API will
change anything on the server side, otherwise wouldn't you have to
change the java client as well.



From chime at mu.dk  Sat Jul 28 17:46:32 2007
From: chime at mu.dk (Michael Arnoldus)
Date: Sat, 28 Jul 2007 18:46:32 +0200
Subject: [rabbitmq-discuss] Javascript client
Message-ID: <6323D01C-D9F1-4331-9FDB-08ED1324F12D@mu.dk>

Hi,

Do you have any idea when you will have a Javascript client ready? We  
are considering using RabbitMQ for a new project and we need a  
binding to javascript. Any info would be appreciated.

Kind regards,

Michael Arnoldus
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 1844 bytes
Desc: not available
Url : http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20070728/49694e97/attachment.bin 

From matthias at lshift.net  Sun Jul 29 00:21:19 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 29 Jul 2007 00:21:19 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com> (Ben
	Hood's message of "Sat, 28 Jul 2007 14:54:04 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<269388e30707201931r7796e87eq9260bc8b6cf9a3e7@mail.gmail.com>
	<269388e30707211230r20e08f9ag39d314a96d1d595b@mail.gmail.com>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
Message-ID: <lyk5skqfm8.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> The basic.consume_ok ack message gets sent to the subscriber and not
> to the client reader.

I think that may partially be due to some design choices in the
channel/queue implementation that may need revisiting. atm the
consume_ok is sent by the *queue* process. I think it ought to be sent
by the channel process instead - the channel process should be
responsible for sending back responses to *all* synchronous methods.

> What I started to do is to create a named amqp_client server process
> for each channel, so that the protocol flow within a channel is not
> inhibited by the protocol flow from another channel that were both
> using the same amqp_client process. So everytime a channel is opened
> by the user, a gen_server process is started with the name
> chN at host.

Why do the channel processes need to be named?

> if you use the named approach, the API might look this:
>
> access_request(Channel, Host, Realm)

I'd like to see
  access_request(Channel, Realm)

>> You appear to be changing the channel's writer pid with every
>> basic_consume. That doesn't look right.
>
> Do you mean in the mainloop_without_framing function?

Yes.

>> think the direct consumer case should actually look like this:
>>
>>   consumer <-- queue
>>[...]
> So are you saying that you should pass in the consumer's pid to the
> rabbit_amqqueue_process and have that maintain a list of consumers?

rabbit_amqqueue_process already does this.

> I don't see how the networked API will change anything on the server
> side, otherwise wouldn't you have to change the java client as well.

The idea was/is to use the existing server code (rabbit_reader,
rabbit_channel etc) as the basis for the client code. This will require
some refactoring along the lines you have been pursuing so that server
and client can share a substantial part of their code base.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul 29 01:26:20 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 29 Jul 2007 01:26:20 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <lyk5skqfm8.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
	<lyk5skqfm8.fsf@tanto.lshift.net>
Message-ID: <269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>

Matthias,


> I think that may partially be due to some design choices in the
> channel/queue implementation that may need revisiting. atm the
> consume_ok is sent by the *queue* process. I think it ought to be sent
> by the channel process instead - the channel process should be
> responsible for sending back responses to *all* synchronous methods.

Fair enough, but I can't see how this affects the direct client
fundamentally or even in terms of what messages it passes and what it
expects to receive. I think that this could potentially be done
independently of the direct client.

>
> Why do the channel processes need to be named?

They don't need to be named per se. I just chose that approach as way
to get a handle or a reference to a process that is implementing
channel N. GIven the fact that you want to have a separate process per
channel, if you stored the pid of the channel handler, that would
suffice as well. I just though this is a simple way of maintaining a
reference to the process that has done the protocol handling for a
particular channel. Otherwise you would have to devise another way to
refer to the protocol state of a channel.

>
> > if you use the named approach, the API might look this:
> >
> > access_request(Channel, Host, Realm)
>
> I'd like to see
>   access_request(Channel, Realm)

I orginally started with that variant, then I thought it might be
ambiguous when you are connecting to more than one AMQP server. In the
direct case, adding the host is probably unecessary, but I wanted to
keep a consistent interface for the network case.

>
> >> You appear to be changing the channel's writer pid with every
> >> basic_consume. That doesn't look right.
> >
> > Do you mean in the mainloop_without_framing function?
>
> Yes.

The current code is catering for the basic_consume call, so it sets
the writer pid to the actual subscriber and the ack_pid to process
handling the protocol for a channel:

mainloop_without_framing(State) ->
    receive
	{method, MethodRecord, Content} ->
	    State1 = handle_method(MethodRecord, Content, State),
	    mainloop_without_framing(State1);
	{method, MethodRecord, Content, SubscriberPid} ->
        WriterPid = State#ch.writer_pid,
        State0 = State#ch{writer_pid = SubscriberPid},
	    State1 = handle_method(MethodRecord, Content, State0),
        State2 = State1#ch{writer_pid = WriterPid},
	    mainloop_without_framing(State2);
	Other ->
	    rabbit_log:error("Unexpected ch~p content: ~p~n",
[State#ch.channel, Other]),
	    mainloop_without_framing(State)
    end.

> > So are you saying that you should pass in the consumer's pid to the
> > rabbit_amqqueue_process and have that maintain a list of consumers?
>
> rabbit_amqqueue_process already does this.

I've been looking at this, but viewed it as an optimization rather
than a fundamental change. At the moment the queue sends to the writer
that then sends to the actual consumer, when is an extra hop in the
chain. I think this could be changed without having to change the
client interaction.

>
> > I don't see how the networked API will change anything on the server
> > side, otherwise wouldn't you have to change the java client as well.
>
> The idea was/is to use the existing server code (rabbit_reader,
> rabbit_channel etc) as the basis for the client code. This will require
> some refactoring along the lines you have been pursuing so that server
> and client can share a substantial part of their code base.

I suppose you could use the handle_XXX functions in rabbit_channel
directly to acheive the same goal. In that case, you might have to
merge some of the channel0 stuff into this channel. I can see some
merit in that, though I think this would have to get discussed a bit
more before diving into any code.

BTW, I've implemented the process per channel model and now I'm
looking at paramterizing the ampq_client to cater for the network
case. Will let you know when something useful comes to life.


Ben



From matthias at lshift.net  Sun Jul 29 08:50:53 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 29 Jul 2007 08:50:53 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>
	(Ben Hood's message of "Sun, 29 Jul 2007 01:26:20 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<lyr6n1wf90.fsf@tanto.lshift.net>
	<269388e30707211623h4ff6b6e7wd28c92fa8f8c77da@mail.gmail.com>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
	<lyk5skqfm8.fsf@tanto.lshift.net>
	<269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>
Message-ID: <lybqdvr6le.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> > if you use the named approach, the API might look this:
>> >
>> > access_request(Channel, Host, Realm)
>>
>> I'd like to see
>>   access_request(Channel, Realm)
>
> I orginally started with that variant, then I thought it might be
> ambiguous when you are connecting to more than one AMQP server.

It would not be ambiguous because the Channel process will have been
created by the Client/Connection/Reader process, which equips it with
references to the correct Reader, Writer for a particular connection.

> The current code is catering for the basic_consume call, so it sets
> the writer pid to the actual subscriber and the ack_pid to process
> handling the protocol for a channel:
>
> mainloop_without_framing(State) ->
>     receive
> 	{method, MethodRecord, Content} ->
> 	    State1 = handle_method(MethodRecord, Content, State),
> 	    mainloop_without_framing(State1);
> 	{method, MethodRecord, Content, SubscriberPid} ->
>         WriterPid = State#ch.writer_pid,
>         State0 = State#ch{writer_pid = SubscriberPid},
> 	    State1 = handle_method(MethodRecord, Content, State0),
>         State2 = State1#ch{writer_pid = WriterPid},
> 	    mainloop_without_framing(State2);
> 	Other ->
> 	    rabbit_log:error("Unexpected ch~p content: ~p~n",
> [State#ch.channel, Other]),
> 	    mainloop_without_framing(State)
>     end.

The problem with this is that basic.consume_ok should be returned as the
response to the caller, not sent to the subscriber. That is what is
happening in the Java client.

I reckon the easiest way  to accomplish this in the direct client is to
shift the responsibility of sending the consume_ok from the queue to the
channel, as indicated in my previous email. That is on our todo list,
but it won't get done in time for the next release.

With that change in place, the above code then needs to be tweaked so
that the handling of the basic.consume method gets access to both the
WriterPid (for sending back the consume_ok) and the SubscriberPid (for
passing to the queue).

> BTW, I've implemented the process per channel model and now I'm
> looking at paramterizing the ampq_client to cater for the network
> case. Will let you know when something useful comes to life.

Cool. It will be interesting to see what changes to the design this
forces.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul 29 10:01:45 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 29 Jul 2007 10:01:45 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <lybqdvr6le.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
	<lyk5skqfm8.fsf@tanto.lshift.net>
	<269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>
	<lybqdvr6le.fsf@tanto.lshift.net>
Message-ID: <269388e30707290201r715fbbcdm2a0a41faa64ee8e1@mail.gmail.com>

Matthias,

> > I orginally started with that variant, then I thought it might be
> > ambiguous when you are connecting to more than one AMQP server.
>
> It would not be ambiguous because the Channel process will have been
> created by the Client/Connection/Reader process, which equips it with
> references to the correct Reader, Writer for a particular connection.

That is true, but what happens when you have connections to mulitple
remotes servers or you have one connection via the direct API and
another via the networked API (e.g. if you were connecting to rabbitmq
directly and interacting with say QPid remotely)?

Example:

User --> ChannelProcess(N) --> ServerReader/Writer
User --> ChannelProcess(N) --> Network --> Server

In this example a user has opened channel N using the direct API and
has opened another channel N with a remote network server. How does
the user distinguish between the two Pids that they would have to use
in conjunction with an API call? If you just supplied the channel as a
parameter, the channel Pid resolution wouldn't work, unless the user
stores the Pid of the spawned channel process when they start it. Then
in that case, for the direct API since you have a process per channel,
you wouldn't even need to supply the channel. You would only need the
channel in the network case, where you have a single socket handling
process.

> The problem with this is that basic.consume_ok should be returned as the
> response to the caller, not sent to the subscriber. That is what is
> happening in the Java client.

This is not happening. To solve this I've introduced the concept of an
acknowledgement pid that the *_ok methods get dispatched to, so the
basic.consume_ok goes to the caller and the actual message gets
delivered to the subscriber. This is what I described in the mail that
got returned which I re-incorporated into this discussion thread.

>
> I reckon the easiest way  to accomplish this in the direct client is to
> shift the responsibility of sending the consume_ok from the queue to the
> channel, as indicated in my previous email. That is on our todo list,
> but it won't get done in time for the next release.

That would be another way of solving it:

case rabbit_amqqueue:basic_consume(Q, NoAck, ReaderPid, WriterPid, AckPid,
					       ConsumerTag, ExclusiveConsume, NoWait) of
		{ok, ActualConsumerTag} ->
		    put_consumer_mapping(ActualConsumerTag, ActualQueueName),
		    %% send consume_ok here
		    State;

>
> With that change in place, the above code then needs to be tweaked so
> that the handling of the basic.consume method gets access to both the
> WriterPid (for sending back the consume_ok) and the SubscriberPid (for
> passing to the queue).

Well, as I've stated above, I solved it another way so it's not
currently an issue, but to change it to the way you suggest would be
easy enough anyway. I'll wait direction if you think you are going to
revisit this area after the next release.

Ben



From 0x6e6562 at gmail.com  Sun Jul 29 12:08:54 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 29 Jul 2007 12:08:54 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <lybqdvr6le.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
	<lyk5skqfm8.fsf@tanto.lshift.net>
	<269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>
	<lybqdvr6le.fsf@tanto.lshift.net>
Message-ID: <269388e30707290408p6cc39d9apf357b386034c9c28@mail.gmail.com>

Matthias,

> Cool. It will be interesting to see what changes to the design this
> forces.

I'm just looking at using the reader and writer modules to implement
the socket handling in the network client. Would you consider this
approach in general, or is there anything in there that ties it
fundamentally to the server side?

Ben



From matthias at lshift.net  Sun Jul 29 13:03:25 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 29 Jul 2007 13:03:25 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707290201r715fbbcdm2a0a41faa64ee8e1@mail.gmail.com>
	(Ben Hood's message of "Sun, 29 Jul 2007 10:01:45 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
	<lyk5skqfm8.fsf@tanto.lshift.net>
	<269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>
	<lybqdvr6le.fsf@tanto.lshift.net>
	<269388e30707290201r715fbbcdm2a0a41faa64ee8e1@mail.gmail.com>
Message-ID: <lyvec3pgc2.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> what happens when you have connections to mulitple remotes servers or
> you have one connection via the direct API and another via the
> networked API (e.g. if you were connecting to rabbitmq directly and
> interacting with say QPid remotely)?
>
> Example:
>
> User --> ChannelProcess(N) --> ServerReader/Writer
> User --> ChannelProcess(N) --> Network --> Server
>
> In this example a user has opened channel N using the direct API and
> has opened another channel N with a remote network server. How does
> the user distinguish between the two Pids that they would have to use
> in conjunction with an API call? If you just supplied the channel as a
> parameter, the channel Pid resolution wouldn't work, unless the user
> stores the Pid of the spawned channel process when they start it. Then
> in that case, for the direct API since you have a process per channel,
> you wouldn't even need to supply the channel. You would only need the
> channel in the network case, where you have a single socket handling
> process.

Sorry about the confusion, I meant
  access_request(Channel*Pid*, Realm)
So yes, the user would need to keep hold of the ChannelPid, just as they
currently keep hold of the object reference to the Channel object in the
Java API.

This would work for both the network and direct API.


Matthias.



From matthias at lshift.net  Sun Jul 29 13:07:30 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 29 Jul 2007 13:07:30 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707290408p6cc39d9apf357b386034c9c28@mail.gmail.com>
	(Ben Hood's message of "Sun, 29 Jul 2007 12:08:54 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<lylkd8x6l8.fsf@tanto.lshift.net>
	<269388e30707220301n51749bd4yb85851db5825dab9@mail.gmail.com>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
	<lyk5skqfm8.fsf@tanto.lshift.net>
	<269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>
	<lybqdvr6le.fsf@tanto.lshift.net>
	<269388e30707290408p6cc39d9apf357b386034c9c28@mail.gmail.com>
Message-ID: <lyodhvpg59.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

>> Cool. It will be interesting to see what changes to the design this
>> forces.
>
> I'm just looking at using the reader and writer modules to implement
> the socket handling in the network client. Would you consider this
> approach in general, or is there anything in there that ties it
> fundamentally to the server side?

As it stands there probably *is* something that ties these modules to
the server side. The point of the refactoring is to eliminate that
dependency. The end result will be either a single set of dual-use
modules or a core set of modules which is used by a set of small client
and server modules.


Matthias.



From 0x6e6562 at gmail.com  Sun Jul 29 13:19:14 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Sun, 29 Jul 2007 13:19:14 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <lyvec3pgc2.fsf@tanto.lshift.net>
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
	<lyk5skqfm8.fsf@tanto.lshift.net>
	<269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>
	<lybqdvr6le.fsf@tanto.lshift.net>
	<269388e30707290201r715fbbcdm2a0a41faa64ee8e1@mail.gmail.com>
	<lyvec3pgc2.fsf@tanto.lshift.net>
Message-ID: <269388e30707290519h27e37a1ck58d0625948a5f231@mail.gmail.com>

Matthias

>
> Sorry about the confusion, I meant
>   access_request(Channel*Pid*, Realm)
> So yes, the user would need to keep hold of the ChannelPid, just as they
> currently keep hold of the object reference to the Channel object in the
> Java API.
>
> This would work for both the network and direct API.


OK, if you're happy with that approach, I'll back out the named
process stuff and switch over to the user passing the pid, which I
think is generally more elegant as well.

I do have a couple of questions about this though:

1. In the direct case, the host and channel would be set in the
start() call, so just passing the Pid is fine. In the network case,
you would only start one client process, so you would still have to
pass in the channel number as an integer for the client process to
differentiate. Or would you somehow initialize a socket connection and
then pass this to a process that you spawn per channel?

2. Should the processes be linked at all? That is, if a channel
process dies, should the user process die as well?

Ben



From matthias at lshift.net  Sun Jul 29 13:30:47 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 29 Jul 2007 13:30:47 +0100
Subject: [rabbitmq-discuss] Javascript client
In-Reply-To: <6323D01C-D9F1-4331-9FDB-08ED1324F12D@mu.dk> (Michael Arnoldus's
	message of "Sat, 28 Jul 2007 18:46:32 +0200")
References: <6323D01C-D9F1-4331-9FDB-08ED1324F12D@mu.dk>
Message-ID: <lyk5sjpf2g.fsf@tanto.lshift.net>

Michael,

Michael Arnoldus <chime at mu.dk> writes:

> Do you have any idea when you will have a Javascript client ready? We
> are considering using RabbitMQ for a new project and we need a
> binding to javascript. Any info would be appreciated.

We do have an experimental Javascript client, using an AMQP-over-HTTP
transport with a JSON codec. It would take some time to tidy up the
code, implement any important missing feature, do testing and
documentation etc, before I'd feel comfortable making it part of an
official RabbitMQ release. Also, the work Ben Hood is doing on
implementing an Erlang client will result in some refactoring that
allows a cleaner implementation of the server side. This too is
something we'd want to incorporate before releasing the code.

We could perhaps make the code for all this available for download in
its current state, so that the community can work on it independently
from the RabbitMQ team. Once sufficient progress has been made on the
code we could fold it back into the official RabbitMQ releases.

Would you be interested in pursuing this approach?


Regards,

Matthias



From matthias at lshift.net  Sun Jul 29 14:01:42 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Sun, 29 Jul 2007 14:01:42 +0100
Subject: [rabbitmq-discuss] FW: Multiple consumers
In-Reply-To: <269388e30707290519h27e37a1ck58d0625948a5f231@mail.gmail.com>
	(Ben Hood's message of "Sun, 29 Jul 2007 13:19:14 +0100")
References: <AE8FD6F8A5C7A74EB55A0639892B0A6C13A90D@SPR3V4.office.local>
	<lyhcnwwxld.fsf@tanto.lshift.net>
	<269388e30707221552u18ddaf6al1b7c9e9831269033@mail.gmail.com>
	<lyodhxq7o6.fsf@tanto.lshift.net>
	<269388e30707280654ha7b6ef7hc185221530f57131@mail.gmail.com>
	<lyk5skqfm8.fsf@tanto.lshift.net>
	<269388e30707281726l7f9d2acfp19fbc765bf8f677d@mail.gmail.com>
	<lybqdvr6le.fsf@tanto.lshift.net>
	<269388e30707290201r715fbbcdm2a0a41faa64ee8e1@mail.gmail.com>
	<lyvec3pgc2.fsf@tanto.lshift.net>
	<269388e30707290519h27e37a1ck58d0625948a5f231@mail.gmail.com>
Message-ID: <lyfy37pdmx.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> I do have a couple of questions about this though:
>
> 1. In the direct case, the host and channel would be set in the
> start() call, so just passing the Pid is fine.

There is no 'host' in the direct case.

> In the network case, you would only start one client process, so you
> would still have to pass in the channel number as an integer for the
> client process to differentiate. Or would you somehow initialize a
> socket connection and then pass this to a process that you spawn per
> channel?

The initialisation sequence for the networked client is:

1) open socket,

2) spawn reader process, parameterised by the socket.

3) open channels by sending a message to the reader process. This should
result in the spawning a new channel process, parameterised by the
channel number, ReaderPid and WriterPid, and the necessary book-keeping
(mapping channel numbers to pids) - i.e. everything
rabbit_reader:open_channel does currently. The reply message to the
sender of the 'open_channel' message should contain the Pid of the new
channel process.

> 2. Should the processes be linked at all? That is, if a channel
> process dies, should the user process die as well?

Channel processes should be (and are) linked to their reader process. As
for linking them to the user process, i.e. the process that initiated
the opening of a channel, I reckon we should leave that up to the user.


Matthias.



From chime at mu.dk  Sun Jul 29 20:14:08 2007
From: chime at mu.dk (Michael Arnoldus)
Date: Sun, 29 Jul 2007 21:14:08 +0200
Subject: [rabbitmq-discuss] Javascript client
In-Reply-To: <lyk5sjpf2g.fsf@tanto.lshift.net>
References: <6323D01C-D9F1-4331-9FDB-08ED1324F12D@mu.dk>
	<lyk5sjpf2g.fsf@tanto.lshift.net>
Message-ID: <0759D870-2AB3-4821-BD56-CA7D8AC397B6@mu.dk>

Matthias,

Thats great news!

Yes, download as it is now would absolutely be a workable solution.  
As long as we can get something to work from javascript.

Let me know if you are prepared to do this, as this will influence  
our choice of AMQP.

Regards,

Michael

> Michael,
>
> Michael Arnoldus <chime at mu.dk> writes:
>
>> Do you have any idea when you will have a Javascript client ready? We
>> are considering using RabbitMQ for a new project and we need a
>> binding to javascript. Any info would be appreciated.
>
> We do have an experimental Javascript client, using an AMQP-over-HTTP
> transport with a JSON codec. It would take some time to tidy up the
> code, implement any important missing feature, do testing and
> documentation etc, before I'd feel comfortable making it part of an
> official RabbitMQ release. Also, the work Ben Hood is doing on
> implementing an Erlang client will result in some refactoring that
> allows a cleaner implementation of the server side. This too is
> something we'd want to incorporate before releasing the code.
>
> We could perhaps make the code for all this available for download in
> its current state, so that the community can work on it independently
> from the RabbitMQ team. Once sufficient progress has been made on the
> code we could fold it back into the official RabbitMQ releases.
>
> Would you be interested in pursuing this approach?
>
>
> Regards,
>
> Matthias

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 1844 bytes
Desc: not available
Url : http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20070729/4396c013/attachment.bin 

From matthias at lshift.net  Mon Jul 30 06:39:24 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 30 Jul 2007 06:39:24 +0100
Subject: [rabbitmq-discuss] Javascript client
In-Reply-To: <0759D870-2AB3-4821-BD56-CA7D8AC397B6@mu.dk> (Michael Arnoldus's
	message of "Sun, 29 Jul 2007 21:14:08 +0200")
References: <6323D01C-D9F1-4331-9FDB-08ED1324F12D@mu.dk>
	<lyk5sjpf2g.fsf@tanto.lshift.net>
	<0759D870-2AB3-4821-BD56-CA7D8AC397B6@mu.dk>
Message-ID: <lybqdupi0j.fsf@tanto.lshift.net>

Michael,

Michael Arnoldus <chime at mu.dk> writes:

> Yes, download as it is now would absolutely be a workable solution.
> As long as we can get something to work from javascript.
>
> Let me know if you are prepared to do this, as this will influence
> our choice of AMQP.

We will work on making the Javascript client code available in its
current state as soon as possible after the upcoming release.

NB: This code is RabbitMQ-specific since the AMQ WG has not (yet)
defined an HTTP transport.


Matthias



From chime at mu.dk  Mon Jul 30 06:52:53 2007
From: chime at mu.dk (Michael Arnoldus)
Date: Mon, 30 Jul 2007 07:52:53 +0200
Subject: [rabbitmq-discuss] Javascript client
In-Reply-To: <lybqdupi0j.fsf@tanto.lshift.net>
References: <6323D01C-D9F1-4331-9FDB-08ED1324F12D@mu.dk>
	<lyk5sjpf2g.fsf@tanto.lshift.net>
	<0759D870-2AB3-4821-BD56-CA7D8AC397B6@mu.dk>
	<lybqdupi0j.fsf@tanto.lshift.net>
Message-ID: <0F978869-0F6D-4C71-8CC0-4AF7825135D1@mu.dk>

Matthias,

Thats good news.

Do you have any idea about the timeschedule for this release?

Michael

Den 30/07/2007 kl. 7.39 skrev Matthias Radestock:

> Michael,
>
> Michael Arnoldus <chime at mu.dk> writes:
>
>> Yes, download as it is now would absolutely be a workable solution.
>> As long as we can get something to work from javascript.
>>
>> Let me know if you are prepared to do this, as this will influence
>> our choice of AMQP.
>
> We will work on making the Javascript client code available in its
> current state as soon as possible after the upcoming release.
>
> NB: This code is RabbitMQ-specific since the AMQ WG has not (yet)
> defined an HTTP transport.
>
>
> Matthias

-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 1844 bytes
Desc: not available
Url : http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20070730/f68f54a4/attachment.bin 

From 0x6e6562 at gmail.com  Mon Jul 30 15:39:41 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 30 Jul 2007 15:39:41 +0100
Subject: [rabbitmq-discuss] Frame generation
Message-ID: <269388e30707300739oa01a200vfe1ac25bba1e4a2e@mail.gmail.com>

Hi,

I don't know whether this is a bug or not, but I think the encoding
for the start.connection_ok method may be wrong. The response field is
actually a table but is not being encoded as such. I've included a
patch for inspection. To provoke this problem, the use the following:

f() ->
    rabbit_binary_generator:build_simple_method_frame(1, start_ok() ),

start_ok() ->
    #'connection.start_ok'{
		client_properties = [
                            {<<"product">>,longstr,<<"Erlang-AMQC">>},
                            {<<"version">>,longstr,<<"0.1">>},
                            {<<"platform">>,longstr,<<"Erlang">>}
							],
        mechanism = <<"AMQPLAIN">>,
        response = [
                    {<<"LOGIN">>, longstr, <<"a">> },
                    {<<"PASSWORD">>, longstr, <<"a">> }
                    ],
        locale = <<"en_US">>
	}.

BTW, is there a bug database for rabbit rather than posting to the list?

HTH,

Ben

-------

diff -r fb6ff292558d src/rabbit_framing.erl
--- a/src/rabbit_framing.erl    Sun Jul 29 14:09:25 2007 +0100
+++ b/src/rabbit_framing.erl    Mon Jul 30 15:34:06 2007 +0100
@@ -1355,9 +1355,10 @@ encode_method_fields(#'connection.start_
   F0Tab = rabbit_binary_generator:generate_table(F0),
   F0Len = size(F0Tab),
   F1Len = size(F1),
-  F2Len = size(F2),
+  F2Tab = rabbit_binary_generator:generate_table(F2),
+  F2Len = size(F2Tab),
   F3Len = size(F3),
-  <<F0Len:32/unsigned, F0Tab:F0Len/binary, F1Len:8/unsigned,
F1:F1Len/binary, F2Len:32/unsigned, F2:F2Len/binary, F3Len:8/unsigned,
F3:F3Len/binary>>;
+  <<F0Len:32/unsigned, F0Tab:F0Len/binary, F1Len:8/unsigned,
F1:F1Len/binary, F2Len:32/unsigned, F2Tab:F2Len/binary,
F3Len:8/unsigned, F3:F3Len/binary>>;
 encode_method_fields(#'connection.secure'{challenge = F0}) ->
   F0Len = size(F0),
   <<F0Len:32/unsigned, F0:F0Len/binary>>;



From matthias at lshift.net  Mon Jul 30 15:54:43 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 30 Jul 2007 15:54:43 +0100
Subject: [rabbitmq-discuss] Frame generation
In-Reply-To: <269388e30707300739oa01a200vfe1ac25bba1e4a2e@mail.gmail.com> (Ben
	Hood's message of "Mon, 30 Jul 2007 15:39:41 +0100")
References: <269388e30707300739oa01a200vfe1ac25bba1e4a2e@mail.gmail.com>
Message-ID: <lyps2aaqmk.fsf@tanto.lshift.net>

Ben,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> I don't know whether this is a bug or not, but I think the encoding
> for the start.connection_ok method may be wrong. The response field is
> actually a table but is not being encoded as such.

The 0-8 spec states that the field is a longstr, and provides the
following explanation:
      A block of opaque data passed to the security mechanism. The contents
      of this data are defined by the SASL security mechanism.  For the
      PLAIN security mechanism this is defined as a field table holding
      two fields, LOGIN and PASSWORD.

So for PLAIN auth the field will indeed contain a table, but that is not
something captured in the type.

> BTW, is there a bug database for rabbit rather than posting to the
> list?

There is no public bug database atm. It's on our todo list.

> diff -r fb6ff292558d src/rabbit_framing.erl

rabbit_framing.erl is auto-generated. If you do find any bugs in it then
you need to fix the generation script, not the file itself.


Matthias.



From 0x6e6562 at gmail.com  Mon Jul 30 16:43:47 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 30 Jul 2007 16:43:47 +0100
Subject: [rabbitmq-discuss] Frame generation
In-Reply-To: <lyps2aaqmk.fsf@tanto.lshift.net>
References: <269388e30707300739oa01a200vfe1ac25bba1e4a2e@mail.gmail.com>
	<lyps2aaqmk.fsf@tanto.lshift.net>
Message-ID: <269388e30707300843j5c968335r7d4030a74dcd13ad@mail.gmail.com>

Matthias,

> The 0-8 spec states that the field is a longstr, and provides the
> following explanation:
>       A block of opaque data passed to the security mechanism. The contents
>       of this data are defined by the SASL security mechanism.  For the
>       PLAIN security mechanism this is defined as a field table holding
>       two fields, LOGIN and PASSWORD.
>
> So for PLAIN auth the field will indeed contain a table, but that is not
> something captured in the type.

So basically what you are saying it the spec treats it as opaque but
the sender and receiver implicitly agree that it's a table, i.e. if
you use PLAIN you just pass

\0username\0password

and for AMQPLAIN you encode as a table and then pass as an opaque string?

> rabbit_framing.erl is auto-generated. If you do find any bugs in it then
> you need to fix the generation script, not the file itself.

Ah, I've always wondered what that codegen module does and why the
spec is encoded in XML. Just out of interest's sake, does this
approach make the maintainance and migration easier or does it save on
boilerplate code?

Ben



From matthias at lshift.net  Mon Jul 30 17:15:01 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 30 Jul 2007 17:15:01 +0100
Subject: [rabbitmq-discuss] Frame generation
In-Reply-To: <46AE0BFF.70507@lshift.net> (Simon MacMullen's message of "Mon,
	30 Jul 2007 17:04:15 +0100")
References: <46AE0BFF.70507@lshift.net>
Message-ID: <lyabtd7tru.fsf@tanto.lshift.net>

Ben,

> So basically what you are saying it the spec treats it as opaque but
> the sender and receiver implicitly agree that it's a table

correct.

>> rabbit_framing.erl is auto-generated. If you do find any bugs in it
>> then you need to fix the generation script, not the file itself.
>
> Ah, I've always wondered what that codegen module does and why the
> spec is encoded in XML. Just out of interest's sake, does this
> approach make the maintainance and migration easier or does it save on
> boilerplate code?

Mostly the former.

Btw, we generate the Java version of the codec in the same way.


Matthias.



From matthias at lshift.net  Mon Jul 30 17:34:27 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 30 Jul 2007 17:34:27 +0100
Subject: [rabbitmq-discuss] Javascript client
In-Reply-To: <lybqdupi0j.fsf@tanto.lshift.net> (Matthias Radestock's message
	of "Mon, 30 Jul 2007 06:39:24 +0100")
References: <6323D01C-D9F1-4331-9FDB-08ED1324F12D@mu.dk>
	<lyk5sjpf2g.fsf@tanto.lshift.net>
	<0759D870-2AB3-4821-BD56-CA7D8AC397B6@mu.dk>
	<lybqdupi0j.fsf@tanto.lshift.net>
Message-ID: <ly64417svg.fsf@tanto.lshift.net>

Michael,

Michael Arnoldus <chime at mu.dk> writes:

> Do you have any idea about the timeschedule for this release?

We are aiming for early next week.

Btw, prompted by your email I spent some time today looking at where we
are at with the AMQP-over-HTTP implementation and Javascript API. The
code is in a reasonably good shape and mostly working. I have extracted
it from our main code base and added a to-do list, so we are ready to
make this available for download as soon as the upcoming release is out.


Matthias.



From jwolstenholme at gmail.com  Mon Jul 30 17:50:38 2007
From: jwolstenholme at gmail.com (James Wolstenholme)
Date: Mon, 30 Jul 2007 17:50:38 +0100
Subject: [rabbitmq-discuss] Socket Exceptions
In-Reply-To: <724b561a0707300915t75c68d3dj1ad6b43705b9bdd8@mail.gmail.com>
References: <724b561a0707300915t75c68d3dj1ad6b43705b9bdd8@mail.gmail.com>
Message-ID: <724b561a0707300950y46937568h3a33125c5929ba77@mail.gmail.com>

Hello -

I'm in the early days of testing RabbitMQ and have been experiencing the
symptoms described below when letting my sample applications run
uninterrupted for 500,000 - 1,000,000 messages or so. Unfortunately the
errors appear inconsistently (ie after different numbers of consumed
messages) and do not always appear on every run. I've included the output
from my client application (very similar to the ConsumerMain class included
in the examples - I've also had the 'read timed out' exception raised when
running that class 'as is') as well as the log contents entries from rabbit
at the point of the exception.

Out testing environment is described below.

2x
    * 4 core AMD Opteron
    * 8G memory
    * eth0 interface with MTU set to 9000
    * Centos OS - kernel version 2.6.18

One of these machines is the RabbitMQ server and hosts the consumer
application, the other hosts only the producer application. The rabbit
connection and channel are configured as follows.

Multiple threads are generating messages from the producer application
Version = 1.0.0 alpha
Ack sent = yes, every 50 messages
framesize = 9000 (our message size is 200 objects * 40 bytes + 12 byte
header = 8012 bytes)
queue type = direct
persistent = true (using ChannelN.MINIMAL_PERSISTENT_BASIC_PROPERTIES)
transactional = false

This is designed as a performance test and so is hammering as much load
through the applications as possible. I appreciate that it may be difficult
to diagnose the issue from this description but I would like to know if this
is something that has been seen before or if there is a way I can modify the
level of logging to get more information about the problems from RabbitMQ
itself.

Thanks & regards

James Wolstenholme
Software Engineer


==============
Connection reset
==============

RabbitMQ log

=INFO REPORT==== 30-Jul-2007::14:52:05 ===
Rolling persister log to "/usr/local/lib/erlang/lib/rabbitmq-
server-1.0.0-alpha/mnesia/rabbit/rabbit_persister.LOG.previous"

=ERROR REPORT==== 30-Jul-2007::14:52:42 ===
Reader timeout (3 s) in state frame_header

=INFO REPORT==== 30-Jul-2007::14:53:03 ===
< 0.166.0>: Clean connection shutdown.


Consumer application stdout

     [java] 117544 ms: Received 210538 - 285 since last report (80 Hz) -
objects :  42107600
     [java] AMQConnection.mainLoop: exception java.net.SocketException:
Connection reset
     [java] java.net.SocketException: Connection reset
     [java]     at java.net.SocketInputStream.read(SocketInputStream.java
:168)
     [java]     at java.net.SocketInputStream.read (SocketInputStream.java
:182)
     [java] Shutdown signal terminating consumer.
com.rabbitmq.client.ShutdownSignal (hard error; reason:
java.net.SocketException: Connection reset)
     [java]     at java.io.DataInputStream.readUnsignedByte (
DataInputStream.java:271)
     [java]     at com.rabbitmq.client.Frame.readFrom(Frame.java:84)
     [java]     at com.rabbitmq.client.AMQConnection.readFrame(
AMQConnection.java:212)
     [java]     at com.rabbitmq.client.AMQConnection.mainLoop (
AMQConnection.java:239)
     [java]     at com.rabbitmq.client.AMQConnection$1.run(
AMQConnection.java:131)
     [java]     at java.lang.Thread.run(Thread.java:619)
     [java] Channel 1 received shutdown signal:
com.rabbitmq.client.ShutdownSignal (hard error; reason:
java.net.SocketException: Connection reset)
     [java] Channel 0 received shutdown signal:
com.rabbitmq.client.ShutdownSignal (hard error; reason:
java.net.SocketException : Connection reset)


============
Read timed out
============

RabbitMQ log

=INFO REPORT==== 30-Jul-2007::15:15:01 ===
<0.230.0>: Opening channel 1

=ERROR REPORT==== 30-Jul-2007::15:16:44 ===
Error in process <0.220.0> on node 'rabbit at tfweb01' with exit value:
{{badmatch,{error,closed}},[{rabbit_writer,send,2},{rabbit_writer,internal_send_command,5},{rabbit_writer,do_deliver,9},{rabbit_writer,handle_message,2},{rabbit_writer,mainloop,1}]}


=ERROR REPORT==== 30-Jul-2007::15:16:44 ===
Error in process <0.181.0> on node 'rabbit at tfweb01' with exit value:
{{badmatch,{error,enotconn}},[{rabbit_reader,switch_callback,3},{rabbit_reader,mainloop,1},{rabbit_reader,start_connection,1}]}


=INFO REPORT==== 30-Jul-2007::15:16:44 ===
Requeueing 1 messages, 365175 already on queue


Consumer application stdout

     [java] 101002 ms: Received 66492 - 693 since last report (708 Hz) -
objects :  13298400
     [java] AMQConnection.mainLoop: exception
java.net.SocketTimeoutException: Read timed out
     [java] java.net.SocketTimeoutException: Read timed out
     [java]     at java.net.SocketInputStream.socketRead0 (Native Method)
     [java]     at java.net.SocketInputStream.read(SocketInputStream.java
:129)
     [java]     at java.io.DataInputStream.readFully(DataInputStream.java
:178)
     [java]     at java.io.DataInputStream.readFully (DataInputStream.java
:152)
     [java]     at com.rabbitmq.client.Frame.readFrom(Frame.java:101)
     [java]     at com.rabbitmq.client.AMQConnection.readFrame(
AMQConnection.java:212)
     [java]     at com.rabbitmq.client.AMQConnection.mainLoop (
AMQConnection.java:239)
     [java]     at com.rabbitmq.client.AMQConnection$1.run(
AMQConnection.java:131)
     [java]     at java.lang.Thread.run(Thread.java:619)
     [java] Channel 1 received shutdown signal:
com.rabbitmq.client.ShutdownSignal (hard error; reason:
java.net.SocketTimeoutException: Read timed out)
     [java] Shutdown signal terminating consumer.
com.rabbitmq.client.ShutdownSignal (hard error; reason:
java.net.SocketTimeoutException : Read timed out)
     [java] Channel 0 received shutdown signal:
com.rabbitmq.client.ShutdownSignal (hard error; reason:
java.net.SocketTimeoutException: Read timed out)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20070730/a9b39cff/attachment.htm 

From 0x6e6562 at gmail.com  Mon Jul 30 19:08:31 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 30 Jul 2007 19:08:31 +0100
Subject: [rabbitmq-discuss] Socket Exceptions
In-Reply-To: <724b561a0707300950y46937568h3a33125c5929ba77@mail.gmail.com>
References: <724b561a0707300915t75c68d3dj1ad6b43705b9bdd8@mail.gmail.com>
	<724b561a0707300950y46937568h3a33125c5929ba77@mail.gmail.com>
Message-ID: <269388e30707301108v20f9245dg1a482bd164e82ad4@mail.gmail.com>

James,

> I'm in the early days of testing RabbitMQ and have been experiencing the
> symptoms described below when letting my sample applications run
> uninterrupted for 500,000 - 1,000,000 messages or so. Unfortunately the

Have you tried setting the timeout a little higher before you run your
tests to see if that makes a difference?

HTH,

Ben



From matthias at lshift.net  Mon Jul 30 20:09:32 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 30 Jul 2007 20:09:32 +0100
Subject: [rabbitmq-discuss] Socket Exceptions
In-Reply-To: <724b561a0707300950y46937568h3a33125c5929ba77@mail.gmail.com>
	(James Wolstenholme's message of "Mon,
	30 Jul 2007 17:50:38 +0100")
References: <724b561a0707300915t75c68d3dj1ad6b43705b9bdd8@mail.gmail.com>
	<724b561a0707300950y46937568h3a33125c5929ba77@mail.gmail.com>
Message-ID: <lyir811zf7.fsf@tanto.lshift.net>

James,

"James Wolstenholme" <jwolstenholme at gmail.com> writes:

> I'm in the early days of testing RabbitMQ and have been experiencing
> the symptoms described below when letting my sample applications run
> uninterrupted for 500,000 - 1,000,000 messages or so.

The errors you are getting indicate that both client and server are
timing out receiving data. This can be caused by extremely heavily
loaded clients or servers, preventing data from being processed in a
timely manner and heartbeat frames from being sent.

Try running everything just below maximum load, making sure that
producer, server and consumer always have a little bit of spare
capacity.

Another thing to try is reducing the frame size. In RabbitMQ 1.0.0 the
server must receive at least one complete frame inside the heartbeat
interval, or it will time out. That changes in the upcoming release - a
timeout will then only occur if no data has been transmitted at all
within a heartbeat interval.


Matthias.



From 0x6e6562 at gmail.com  Mon Jul 30 21:09:48 2007
From: 0x6e6562 at gmail.com (Ben Hood)
Date: Mon, 30 Jul 2007 21:09:48 +0100
Subject: [rabbitmq-discuss] Socket Exceptions
In-Reply-To: <lyir811zf7.fsf@tanto.lshift.net>
References: <724b561a0707300915t75c68d3dj1ad6b43705b9bdd8@mail.gmail.com>
	<724b561a0707300950y46937568h3a33125c5929ba77@mail.gmail.com>
	<lyir811zf7.fsf@tanto.lshift.net>
Message-ID: <269388e30707301309m6cb14232q11604fafc4a5263c@mail.gmail.com>

James,

> The errors you are getting indicate that both client and server are
> timing out receiving data. This can be caused by extremely heavily
> loaded clients or servers, preventing data from being processed in a
> timely manner and heartbeat frames from being sent.

Another thought: Is kernel polling turned on in the erlang VM? If it
isn't, it might be worth a try to see if this makes any difference on
server throughput.

HTH,

Ben



From matthias at lshift.net  Mon Jul 30 22:34:57 2007
From: matthias at lshift.net (Matthias Radestock)
Date: Mon, 30 Jul 2007 22:34:57 +0100
Subject: [rabbitmq-discuss] Socket Exceptions
In-Reply-To: <269388e30707301309m6cb14232q11604fafc4a5263c@mail.gmail.com>
	(Ben Hood's message of "Mon, 30 Jul 2007 21:09:48 +0100")
References: <724b561a0707300915t75c68d3dj1ad6b43705b9bdd8@mail.gmail.com>
	<724b561a0707300950y46937568h3a33125c5929ba77@mail.gmail.com>
	<lyir811zf7.fsf@tanto.lshift.net>
	<269388e30707301309m6cb14232q11604fafc4a5263c@mail.gmail.com>
Message-ID: <ly4pjl1sou.fsf@tanto.lshift.net>

Ben, James,

"Ben Hood" <0x6e6562 at gmail.com> writes:

> Another thought: Is kernel polling turned on in the erlang VM? If it
> isn't, it might be worth a try to see if this makes any difference on
> server throughput.

We haven't seen any performance difference in our tests when
enabling/disabling kernel polling. If you do, please let us know.

In any case, it's a good idea to enable kernel poll, so in the upcoming
release the default startup scripts for RabbitMQ on Unix do that.


Matthias.



