<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] How Should a Messaging Client Handle Errors?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20How%20Should%20a%20Messaging%20Client%20Handle%20Errors%3F&In-Reply-To=%3C3095E7BFC8C0664E97D71288189F19C6179FC73A55%40AUSP01VMBX29.collaborationhost.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013891.html">
   <LINK REL="Next"  HREF="013893.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] How Should a Messaging Client Handle Errors?</H1>
    <B>Mike Hadlow</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20How%20Should%20a%20Messaging%20Client%20Handle%20Errors%3F&In-Reply-To=%3C3095E7BFC8C0664E97D71288189F19C6179FC73A55%40AUSP01VMBX29.collaborationhost.net%3E"
       TITLE="[rabbitmq-discuss] How Should a Messaging Client Handle Errors?">mike.hadlow at 15below.com
       </A><BR>
    <I>Thu Jul 14 13:01:17 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="013891.html">[rabbitmq-discuss] How Should a Messaging Client Handle Errors?
</A></li>
        <LI>Next message: <A HREF="013893.html">[rabbitmq-discuss] How Should a Messaging Client Handle Errors?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13892">[ date ]</a>
              <a href="thread.html#13892">[ thread ]</a>
              <a href="subject.html#13892">[ subject ]</a>
              <a href="author.html#13892">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Rob,

Your Dead Letter Exchange sounds very interesting, just what I need in fact for option 2 :)

How long before we can expect to see this in RabbitMQ? I'm thinking I'll probably have to implement a client-side DLE for the time being and then change to use your DLE once it's available. But it's great to hear that it's happening.

A very useful feature would be some way of communicating the reason for the basic.reject or basic.nack, such as a stack trace for example. If basic.nack took a reason string that could be added as a header to the message sent to the DLE, it would be very helpful.

Thanks
Mike

-----Original Message-----
From: Rob Harrop [mailto:<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rob.harrop at gmail.com</A>]
Sent: 14 July 2011 12:46
To: Mike Hadlow
Cc: <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
Subject: Re: [rabbitmq-discuss] How Should a Messaging Client Handle Errors?

Mike,

The solution you outline in option 2 sounds like the Dead-Letter Exchange support I'm working on at the moment.

Using DLEs, you can declare that a queue routes all dead messages to a specified exchange for later processing. Messages are considered dead when:

* The queue containing the message is deleted
* The queue containing the message is purged
* The queue containing is deleted due to lease expiry
* The message is rejected (basic.reject or basic.nack) with requeue=false
* The TTL for the message expires

Messages are routed to DLEs using their original routing key. If you make the DLE a fanout exchange then you can easily route all dead messages to all queues bound to the DLE.

When this feature is complete, the DLE code will ensure that persistent messages are routed through the DLE before being removed from the source queue - this should give you the guarantee of safety that you are looking for.

Regards,

Rob

Mike Hadlow wrote:
&gt;<i> Hi All,
</I>&gt;<i>
</I>&gt;<i> This is a copy of a blog post I've just written
</I>&gt;<i> &lt;<A HREF="http://mikehadlow.blogspot.com/2011/07/easynetq-how-should-messaging-client.html">http://mikehadlow.blogspot.com/2011/07/easynetq-how-should-messaging-client.html</A>&gt;.
</I>&gt;<i> I was wondering if anyone on the group had any good suggestions for
</I>&gt;<i> error handling strategies?
</I>&gt;<i>
</I>&gt;<i> EasyNetQ &lt;<A HREF="https://github.com/mikehadlow/EasyNetQ">https://github.com/mikehadlow/EasyNetQ</A>&gt; is my simple .NET
</I>&gt;<i> API for RabbitMQ.
</I>&gt;<i>
</I>&gt;<i> I've started thinking about the best patterns for implementing error
</I>&gt;<i> handling in EasyNetQ. One of the aims of EasyNetQ is to remove as many
</I>&gt;<i> infrastructure concerns from the application developer as possible.
</I>&gt;<i> This means that the API should correctly handle any exceptions that
</I>&gt;<i> bubble up from the application layer.
</I>&gt;<i>
</I>&gt;<i> One of the core requirements is that we shouldn't lose messages when
</I>&gt;<i> the application throws. The question then becomes: where should the
</I>&gt;<i> message, that the application was consuming when it threw, go? There
</I>&gt;<i> seem to be three choices:
</I>&gt;<i>
</I>&gt;<i>    1. Put the failed message back on the queue it was consumed from.
</I>&gt;<i>    2. Put the failed message on an error queue.
</I>&gt;<i>    3. A combination of 1 and 2.
</I>&gt;<i>
</I>&gt;<i> *Option 1*has the benefit that it's the out-of-the-box behaviour of
</I>&gt;<i> AMQP. In the case of EasyNetQ, I would simply catch any exceptions,
</I>&gt;<i> log them, and just send a noAck command back to RabbitMQ. Rabbit would
</I>&gt;<i> put the message at the back of the queue and then resend it when it
</I>&gt;<i> got to the front.
</I>&gt;<i>
</I>&gt;<i> Another advantage of this technique is that it gives competing
</I>&gt;<i> consumers the opportunity to process the message. If you have more
</I>&gt;<i> than one consumer on a queue, Rabbit will send the messages to them in
</I>&gt;<i> turn, so this is out-of-the-box.
</I>&gt;<i>
</I>&gt;<i> The drawback of this method is that there's the possibility of the
</I>&gt;<i> queue filling up with failed messages. The consumer would just be
</I>&gt;<i> cycling around throwing exceptions and any messages that it might be
</I>&gt;<i> able to to consume would be slowed down by having to wait their turn
</I>&gt;<i> amongst a long queue of failed messages.
</I>&gt;<i>
</I>&gt;<i> Another problem is that it's difficult to manually inspect the
</I>&gt;<i> messages and selectively delete or retry them.
</I>&gt;<i>
</I>&gt;<i> *Option 2*is harder to implement. I would have to catch exceptions,
</I>&gt;<i> log them and then write the message to an error queue. I would need to
</I>&gt;<i> write an error queue consumer to store the messages in a database. I
</I>&gt;<i> would then need to provide the user with some way to inspect the
</I>&gt;<i> messages alongside the error that caused them to arrive in the error
</I>&gt;<i> queue so that they could make a ignore/retry decision.
</I>&gt;<i>
</I>&gt;<i> I could also implement some kind of wait-and-retry function on the
</I>&gt;<i> error queue, but that would also add additional complexity.
</I>&gt;<i>
</I>&gt;<i> It has the advantage that the original queue remains clear of failing
</I>&gt;<i> messages. Failed messages and the error condition that caused the
</I>&gt;<i> failure can be inspected together, and failed messages can be manually
</I>&gt;<i> ignored or retried.
</I>&gt;<i>
</I>&gt;<i> With the failed messages sitting in a database, it would also be
</I>&gt;<i> simple to create a mechanism where those messages could be replayed on
</I>&gt;<i> a developer machine to aid in debugging.
</I>&gt;<i>
</I>&gt;<i> *A combination of 1 and 2*. I'm moving towards thinking that a
</I>&gt;<i> combination of 1 &amp; 2 might be the best strategy. When a message fails
</I>&gt;<i> initially, we simply noAck it and it goes back to the queue. AMQP
</I>&gt;<i> provides a Redelivered flag, so when the messages is consumed a second
</I>&gt;<i> time we can be aware that it's a retry. Unfortunately there doesn't
</I>&gt;<i> seem to be a retry count in AMQP, so the best we can do is allow for a
</I>&gt;<i> single retry. This has the benefit that it gives a competing consumer
</I>&gt;<i> a chance to process the message.
</I>&gt;<i>
</I>&gt;<i> After the single retry we fall back to *Option 2*. The message is
</I>&gt;<i> passed to the error queue on the second failure.
</I>&gt;<i>
</I>&gt;<i> I would be very interested in hearing how other people have
</I>&gt;<i> implemented error handling with AMQP/RabbitMQ.
</I>&gt;<i>
</I>&gt;<i> Many thanks
</I>&gt;<i>
</I>&gt;<i> Mike
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 15below Limited: Company registered in England and Wales No 3945289
</I>&gt;<i> Registered Office: Lyndean House, 43-46 Queens Road, Brighton BN1 3XB,
</I>&gt;<i> United Kingdom
</I>&gt;<i>
</I>&gt;<i> 15below Australia Pty Limited: ABN 25 132 716 379 Level 50, 120
</I>&gt;<i> Collins Street, Melbourne, Victoria 3000, Australia
</I>&gt;<i>
</I>&gt;<i> Please think about the environment before printing this email.
</I>&gt;<i>
</I>&gt;<i> **********************************************************************
</I>&gt;<i> ** This email and any attachments may be confidential and/or legally
</I>&gt;<i> privileged and are solely for the use of the intended recipient. If
</I>&gt;<i> you have received this email in error please contact the sender. Any
</I>&gt;<i> views or opinions expressed within this e-mail are solely those of the
</I>&gt;<i> sender, and do not necessarily represent those of 15below unless
</I>&gt;<i> otherwise specifically stated. Although 15below has taken every
</I>&gt;<i> reasonable precaution to ensure that any attachment to this e-mail has
</I>&gt;<i> been checked for viruses, it is strongly recommended that you carry
</I>&gt;<i> out your own virus check before opening any attachment, as we cannot
</I>&gt;<i> accept liability for any damage sustained as a result of software virus infection.
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>
 15below Limited: Company registered in England and Wales No 3945289
Registered Office: Lyndean House, 43-46 Queens Road, Brighton BN1 3XB, United Kingdom

15below Australia Pty Limited: ABN 25 132 716 379
Level 50, 120 Collins Street, Melbourne, Victoria 3000, Australia

Please think about the environment before printing this email.

************************************************************************
This email and any attachments may be confidential and/or legally privileged and are solely for the use of the intended recipient.  If you have received this email in error please contact the sender.  Any views or opinions expressed within this e-mail are solely those of the sender, and do not necessarily represent those of 15below unless otherwise specifically stated.  Although 15below has taken every reasonable precaution to ensure that any attachment to this e-mail has been checked for viruses, it is strongly recommended that you carry out your own virus check before opening any attachment, as we cannot accept liability for any damage sustained as a result of software virus infection.
</PRE>





















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013891.html">[rabbitmq-discuss] How Should a Messaging Client Handle Errors?
</A></li>
	<LI>Next message: <A HREF="013893.html">[rabbitmq-discuss] How Should a Messaging Client Handle Errors?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13892">[ date ]</a>
              <a href="thread.html#13892">[ thread ]</a>
              <a href="subject.html#13892">[ subject ]</a>
              <a href="author.html#13892">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
