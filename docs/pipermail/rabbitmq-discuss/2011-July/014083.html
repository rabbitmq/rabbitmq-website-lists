<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Channel takes everyone down
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Channel%20takes%20everyone%20down&In-Reply-To=%3C4E282586.5020108%402600hz.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014081.html">
   <LINK REL="Next"  HREF="014092.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Channel takes everyone down</H1>
    <B>James Aimonetti</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Channel%20takes%20everyone%20down&In-Reply-To=%3C4E282586.5020108%402600hz.com%3E"
       TITLE="[rabbitmq-discuss] Channel takes everyone down">james at 2600hz.com
       </A><BR>
    <I>Thu Jul 21 14:11:34 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="014081.html">[rabbitmq-discuss] Celery access from .net
</A></li>
        <LI>Next message: <A HREF="014092.html">[rabbitmq-discuss] Slow shutdown issue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14083">[ date ]</a>
              <a href="thread.html#14083">[ thread ]</a>
              <a href="subject.html#14083">[ subject ]</a>
              <a href="author.html#14083">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

&gt;<i>Really though, why would your processes be exiting with a non-normal
</I>&gt;<i>reason? That suggests some sort of crash/bug and thus tearing down the
</I>&gt;<i>connection _could_ be considered the right thing to do. One way around
</I>&gt;<i>this though would be to use several connections rather than several
</I>&gt;<i>channels.
</I>
I have many consumers that listen for a given type of request. They
spawn handlers for each request to see if they should handle this
particular request. Those handlers will exit non-normally because there
are a lot of pattern-matching-as-assertion lines to make sure the
handler is processing a request it knows how to respond to, a la &quot;let it
crash&quot;. We have redundancy in the cluster so that segment A that has
clients A-M and segment B with clients N-Z (not really how its done)
will both receive a call for client P. Both segments will spawn at least
two handlers for the call each, but those handlers on segment A will
crash pretty quickly, while segment B will happily process the
particular call.

Mmore specifically, for example, there is a listener for incoming
telephone calls that spawns a handler for that particular call-id.
Events for that call are published with the routing key
call.event.CALLID. This listener can crash for a variety of reasons,
valid or not, but those moments it was out of service mean it can't know
the state of the call (having a durable queue store those messages isn't
an option because we run primarily with ram_nodes since we want to be
able to put this on an embedded device that may not have a hard-drive,
or may have a flash-card which we want to avoid writing to).

Each call handler has a channel to consume over, but since call handlers
can live a few milliseconds or a few minutes or even hours (depending on
how long the call lasts), I've found it hard to simulate various call
volumes to track down when and why my channel/consumer monitoring
process &quot;orphans&quot; a channel (the consumer goes down but the channel
isn't closed). So my quick fix was to link them directly.

I've stayed away from multiple connections as I thought channels were a
lighter-weight concept than connections. One day, I'd like to see if we
can't increase throughput by having multiple connections as well, but
for now what we have serves us well. And, like I said, this issue is
relatively easy to clean up manually and only becomes a problem after
weeks of running, but when we hit the embedded device phase, our memory
constraints will start to expose these types of leaks faster.

Sorry for the ramble. Will be watching for those updates!

Take care,

James

- -- 
James Aimonetti
Distributed Systems Engineer / DJ MC_

2600hz | <A HREF="http://2600hz.com">http://2600hz.com</A>
sip:<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">james at 2600hz.com</A>
tel: 415.886.7905
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.10 (GNU/Linux)
Comment: Using GnuPG with Mozilla - <A HREF="http://enigmail.mozdev.org/">http://enigmail.mozdev.org/</A>

iQEcBAEBAgAGBQJOKCWGAAoJENc77s1OYoGgHdoIAK0bjjm3ZWArxzkVuih3WcmL
weWry4wBpLZ1stc+JzLBoFYgzdPVeGO+1BHC1pkkqrygd1YMYgpCn8NRuIxpFpbE
D9QjwsNz+eMJAiBR+PCHt96PEYi7W29w0wjoTSvMdZWsXro1FMWIu0cYslJ1zcgd
BA6xoNEBPj1CpOCFsbT3RkBpr130lpd14KLHl2N//LQPm7GdkTF3IXCwuuK5xcFI
1saTYM7X1aPTt1Bzf6q7HFIJsB528Pm1b6kyaNuhLvacz0psUMYGe8RTnutGDRtV
c5eZAKNk7jmBrFDgk6GNZBLKXzOe1F5pAu2zb+U8d4KPDWkGiB8g7E45LZcUKo0=
=fBi6
-----END PGP SIGNATURE-----
</PRE>




































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014081.html">[rabbitmq-discuss] Celery access from .net
</A></li>
	<LI>Next message: <A HREF="014092.html">[rabbitmq-discuss] Slow shutdown issue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14083">[ date ]</a>
              <a href="thread.html#14083">[ thread ]</a>
              <a href="subject.html#14083">[ subject ]</a>
              <a href="author.html#14083">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
