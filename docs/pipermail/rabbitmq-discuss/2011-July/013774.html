<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Published message not queued after	publish-ok received when connection quickly closed
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Published%20message%20not%20queued%20after%0A%09publish-ok%20received%20when%20connection%20quickly%20closed&In-Reply-To=%3C314D419E-FDDC-4AA9-84C5-3E8EA4230D62%40101ideas.cz%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013770.html">
   <LINK REL="Next"  HREF="013778.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Published message not queued after	publish-ok received when connection quickly closed</H1>
    <B>Stastny Jakub</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Published%20message%20not%20queued%20after%0A%09publish-ok%20received%20when%20connection%20quickly%20closed&In-Reply-To=%3C314D419E-FDDC-4AA9-84C5-3E8EA4230D62%40101ideas.cz%3E"
       TITLE="[rabbitmq-discuss] Published message not queued after	publish-ok received when connection quickly closed">stastny at 101ideas.cz
       </A><BR>
    <I>Fri Jul  8 16:32:10 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="013770.html">[rabbitmq-discuss] Published message not queued after publish-ok received when connection quickly closed
</A></li>
        <LI>Next message: <A HREF="013778.html">[rabbitmq-discuss] Published message not queued after publish-ok received when connection quickly closed
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13774">[ date ]</a>
              <a href="thread.html#13774">[ thread ]</a>
              <a href="subject.html#13774">[ subject ]</a>
              <a href="author.html#13774">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>El 8 Jul 2011, a las 16:16, Michael Nacos escribi&#243;:

&gt;<i> so if the publish call returns immediately with no guarantees, what's the point of adding a @channel.tx_commit right after it?
</I>
Transactions are mainly atomicity, so if you publish more messages, then running it in a transactions will result in saving all or nothing (and getting an error back). Using it for one item will result in getting the error back, so you'll know if it went wrong (I think, I don't have much experience with them).

The docs:

&quot;The Tx class allows publish and ack operations to be batched into atomic units of work. The intention is that all publish and ack requests issued within a transaction will complete successfully or none of them will. Servers SHOULD implement atomic transactions at least where all publish or ack requests affect a single queue. Transactions that cover multiple queues may be non atomic, given that queues can be created and destroyed asynchronously, and such events do not form part of any transaction.&quot;

&gt;<i> the question becomes how do I get a reliable publish ack to base the tx_commit/metadata.ack on
</I>&gt;<i> 
</I>&gt;<i> I saw this in the docs for publisher confirms:
</I>&gt;<i> 
</I>&gt;<i> # define a callback that will be executed when message is acknowledged
</I>&gt;<i> channel.on_ack do |basic_ack|
</I>&gt;<i>   puts &quot;Received an acknowledgement: delivery_tag = #{basic_ack.delivery_tag}, multiple = #{basic_ack.multiple}&quot;
</I>&gt;<i> end
</I>&gt;<i> which is great, but how does it fit within the consume loop? I need execution to block until it's safe to issue the metadata.ack call. Is this something I can achieve with eventmachine?
</I>
I'm not sure if I understand ... this is a callback, it doesn't block as well as #subscribe, it's a callback called when a message is delivered to the client. EventMachine is an implementation of reactor pattern (it means it's async). So it works based on events (when I get this, do that ... ). BTW just to make sure, do you know that this on_ack is for ack which the *broker* sends? So you don't call metadata.ack for this (you ack messages when they're actually processed on the consumer).

Cheers,

Jakub

&gt;<i> 2011/7/8 Jakub &#352;&#357;astn&#253; &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">stastny at 101ideas.cz</A>&gt;
</I>&gt;<i> Basic.Publish isn't pseudo-synchronous, it's really asynchronous. Exchange#publish doesn't take nowait option (so no, your code isn't safe), it simply send the data and that's it. Then you have no idea whether everything went OK or not. That's why you can use either transactions (yes, you'd have to wrap the code in it as you've mentioned) or publisher confirms (which I'd personally prefer as transactions are really slow and fairly tricky). The documentation for publisher confirms in AMQP gem is here: <A HREF="http://rdoc.info/github/ruby-amqp/amqp/master/file/docs/Durability.textile">http://rdoc.info/github/ruby-amqp/amqp/master/file/docs/Durability.textile</A>
</I>&gt;<i> 
</I>&gt;<i> Jakub
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.flickr.com/photos/jakub-stastny">http://www.flickr.com/photos/jakub-stastny</A>
</I>&gt;<i> <A HREF="http://twitter.com/botanicus">http://twitter.com/botanicus</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 2011/7/8 Michael Nacos &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">m.nacos at gmail.com</A>&gt;
</I>&gt;<i> so, what's currently the best way to publish messages consumed from one queue into another with the amqp gem? This is quite important in processing scenaria when no messages may be lost. In particular, is the following code safe? Will the pseudo-synchronous publish call return only after the message has been accepted in the second queue (:nowait =&gt; false)? otherwise, what would be the point of wrapping the publish call with @channel.tx_select / @channel.tx_commit ?
</I>&gt;<i> 
</I>&gt;<i> # consumer which publishes each message to another queue
</I>&gt;<i> # ------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> @consume_from = 'first'
</I>&gt;<i> @deliver_to = 'second'
</I>&gt;<i> 
</I>&gt;<i> EM.run do
</I>&gt;<i>   AMQP.connect do |connection|
</I>&gt;<i>     @channel = MQ.new(connection)
</I>&gt;<i>     # making sure the relevant queues exist
</I>&gt;<i>     @queue1 = @channel.queue(@consume_from, :passive =&gt; false, :durable =&gt; true)
</I>&gt;<i>     @queue2 = @channel.queue(@deliver_to, :passive =&gt; false, :durable =&gt; true)
</I>&gt;<i>     # setting up the consumer loop
</I>&gt;<i>     @queue1.subscribe(:ack =&gt; true) do |metadata, data|
</I>&gt;<i>       @channel.default_exchange.publish(data, \
</I>&gt;<i>         :routing_key =&gt; @deliver_to, \
</I>&gt;<i>         :persistent =&gt; true, \
</I>&gt;<i>         :nowait =&gt; false)
</I>&gt;<i>       puts '.'
</I>&gt;<i>       metadata.ack
</I>&gt;<i>     end
</I>&gt;<i>   end
</I>&gt;<i> end
</I>&gt;<i> 
</I>&gt;<i> 2011/7/4 Jakub &#352;&#357;astn&#253; &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">stastny at 101ideas.cz</A>&gt;
</I>&gt;<i> AMQP 0.8 is available as RC, it's way more stable than 0.7, so I would recommend to just use the RC.
</I>&gt;<i> 
</I>&gt;<i> Jakub
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://www.flickr.com/photos/jakub-stastny">http://www.flickr.com/photos/jakub-stastny</A>
</I>&gt;<i> <A HREF="http://twitter.com/botanicus">http://twitter.com/botanicus</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 2011/7/4 Michael Nacos &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">m.nacos at gmail.com</A>&gt;
</I>&gt;<i> there seems to be some support for tx_select, tx_commit, tx_rollback in the master branch of the amqp gem, but not in the 0.7.x-stable branch, which is what most people are using
</I>&gt;<i> 
</I>&gt;<i> 2011/5/6 David Wragg &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">david at rabbitmq.com</A>&gt;
</I>&gt;<i> Simon MacMullen &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">simon at rabbitmq.com</A>&gt; writes:
</I>&gt;<i> &gt; On 05/05/11 22:33, Elias Levy wrote:
</I>&gt;<i> &gt;&gt; While writing some code using the Ruby AMQP gem against RabbitMQ, I've
</I>&gt;<i> &gt;&gt; noticed that if I publish a message and quickly close the connection,
</I>&gt;<i> &gt;&gt; even though I've received a publish-ok response from the server, the
</I>&gt;<i> &gt;&gt; message fails to be queued by the broker.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm not at all familiar with the Ruby client, but I should point out
</I>&gt;<i> &gt; that unlike many of the other AMQP methods, basic.publish does not
</I>&gt;<i> &gt; have a corresponding basic.publish-ok method; it's always
</I>&gt;<i> &gt; asynchronous. So I imagine the post-publish callback fires
</I>&gt;<i> &gt; immediately.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; In order to be able to know when the broker has taken responsibility
</I>&gt;<i> &gt; for a message you can either wrap the publish in a transaction (when
</I>&gt;<i> &gt; you see tx.commit-ok you know the server has the message) or use the
</I>&gt;<i> &gt; rather more lightweight publish confirms:
</I>&gt;<i> o&gt;
</I>&gt;<i> &gt; <A HREF="http://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/">http://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/</A>
</I>&gt;<i> 
</I>&gt;<i> Another way to solve the problem is to do a synchronous AMQP method
</I>&gt;<i> rather than abruptly closing the connection.  If this the sync method
</I>&gt;<i> completes successfully, you can be sure that your published messages
</I>&gt;<i> have reached the broker (it doesn't give you all the guarantees of
</I>&gt;<i> transactions, but it is much lighter weight).
</I>&gt;<i> 
</I>&gt;<i> An easy way to do this with all versions of the AMQP gem (even 0.6.7) is
</I>&gt;<i> to use the AMQP#close callback.  E.g., add something like this to your
</I>&gt;<i> code:
</I>&gt;<i> 
</I>&gt;<i>  client.close { puts &quot;Closed ok&quot; ; EM.stop }
</I>&gt;<i> 
</I>&gt;<i> David
</I>&gt;<i> 
</I>&gt;<i> --
</I>&gt;<i> David Wragg
</I>&gt;<i> Staff Engineer, RabbitMQ
</I>&gt;<i> VMware, Inc.
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20110708/5e5d69a8/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20110708/5e5d69a8/attachment.htm</A>&gt;
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013770.html">[rabbitmq-discuss] Published message not queued after publish-ok received when connection quickly closed
</A></li>
	<LI>Next message: <A HREF="013778.html">[rabbitmq-discuss] Published message not queued after publish-ok received when connection quickly closed
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13774">[ date ]</a>
              <a href="thread.html#13774">[ thread ]</a>
              <a href="subject.html#13774">[ subject ]</a>
              <a href="author.html#13774">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
