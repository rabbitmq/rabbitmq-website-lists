<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Consumer Callback
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Consumer%20Callback&In-Reply-To=%3C32143563.post%40talk.nabble.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014168.html">
   <LINK REL="Next"  HREF="014193.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Consumer Callback</H1>
    <B>fangbot</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Consumer%20Callback&In-Reply-To=%3C32143563.post%40talk.nabble.com%3E"
       TITLE="[rabbitmq-discuss] Consumer Callback">fangbot at gmail.com
       </A><BR>
    <I>Tue Jul 26 22:27:15 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="014168.html">[rabbitmq-discuss] Consumer Callback
</A></li>
        <LI>Next message: <A HREF="014193.html">[rabbitmq-discuss] Consumer Callback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14192">[ date ]</a>
              <a href="thread.html#14192">[ thread ]</a>
              <a href="subject.html#14192">[ subject ]</a>
              <a href="author.html#14192">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Hi Steve,

Thanks for the response. After reviewing some other posts on this forum,
I've decided to use multithreading in order to achieve the behavior I'm
looking for. Essentially, for every consumer, I create a new thread and
inside the run() method, I am calling an infinite while loop in order to
automatically retrieve the results. All of this is just to familiarize
myself with how RabbitMQ works - in the future, I suspect that every client
will run on a different machine and thus there will be only two threads max
(the application thread and the consumer thread).

Another question - I am doing some performance testing on the messaging
speeds, and my tests are roughly modeled after those in MulticastMain.
However, I've noticed that to record the speeds, getTimeMillis() is being
used. However, if there are other threads (outside of my process) that are
also running, won't they throw off (i.e. increase) the recorded time since
getTimeMillis() isn't thread-specific? Shouldn't something like
ThreadMXBean.getCurrentThreadCPUTime() be used instead?

Thanks in advance for the response!

Best,
-Fang


Steve Powell-7 wrote:
&gt;<i> 
</I>&gt;<i> Dear fangbot,
</I>&gt;<i> You do not say whether you are using Python or Java (the two languages
</I>&gt;<i> shown on the tutorials pages) but I will assume it is Java.
</I>&gt;<i> 
</I>&gt;&gt;<i> is there a way to create an event
</I>&gt;&gt;<i> such that when a queue gets pushed a message, it automatically calls
</I>&gt;&gt;<i> consumer.nextDelivery somehow
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> The simple answer is 'yes', approximately.  There is a push interface
</I>&gt;<i> (defined by the Consumer interface) which is driven whenever a message is
</I>&gt;<i> delivered.
</I>&gt;<i> 
</I>&gt;<i> The tutorials use QueueingConsumer, which is a way to isolate the clients
</I>&gt;<i> engine (the channel thread) from the user's thread.  As you observe, this
</I>&gt;<i> is a pull interface. QueueingConsumer.nextDelivery() will block until
</I>&gt;<i> there is a message to return.
</I>&gt;<i> 
</I>&gt;<i> If you want to use a push interface (which is what QueueingConsumer uses
</I>&gt;<i> under the covers) then you are free to create your own Consumer
</I>&gt;<i> (implementation of the Consumer interface) class, and the handleDelivery()
</I>&gt;<i> method therein will be driven when a message arrives.  The drawback is
</I>&gt;<i> that this 'callback' is driven on a RabbitMQ client thread, and (at the
</I>&gt;<i> moment) you are not permitted to do long-running things on this thread or
</I>&gt;<i> make channel calls, or block, as this will often result in deadlocks.
</I>&gt;<i> However, if you can limit what this does, you are free to communicate with
</I>&gt;<i> another thread of yours, for example to put it on a BlockingQueue (like
</I>&gt;<i> QueueingConsumer does), or to otherwise trigger another thread to do
</I>&gt;<i> something.
</I>&gt;<i> 
</I>&gt;<i> The easiest (and recommended) way to code your own Consumer is to subclass
</I>&gt;<i> DefaultConsumer, and override the methods you want to change (in your case
</I>&gt;<i> handleDelivery()). Take a look at the DefaultConsumer class to see what it
</I>&gt;<i> does.
</I>&gt;<i> 
</I>&gt;<i> Other methods on the Consumer interface are driven if other events occur,
</I>&gt;<i> like channel close, for example.  Your class can then do the right thing.
</I>&gt;<i> 
</I>&gt;<i> This area is currently being reworked -- not to change the interface
</I>&gt;<i> (much!) but to lift some of the restrictions on the things a callback
</I>&gt;<i> method can do without causing deadlocks -- which will also see better
</I>&gt;<i> control of the system resources used by the consumer callbacks.
</I>&gt;<i> 
</I>&gt;<i> I hope this helps -- please come back here if you have any more questions;
</I>&gt;<i> or even if you don't -- we'd like to know how you get on.
</I>&gt;<i> 
</I>&gt;<i> Steve Powell  (a happy bunny)
</I>&gt;<i> ----------some definitions from the SPD----------
</I>&gt;<i> Rigatoni n. A prime-ministerial grin.
</I>&gt;<i> Nigella n. The next bottle-size up from a Nebuchadnezzar.
</I>&gt;<i> Homily adv. Rather like a frenchman.
</I>&gt;<i> 
</I>&gt;<i> On 20 Jul 2011, at 23:26, fangbot wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I'm looking to create multiple publishers/subscribers from the main
</I>&gt;&gt;<i> thread
</I>&gt;&gt;<i> that my program is run (i.e. the thread where I have declared my
</I>&gt;&gt;<i> channel).
</I>&gt;&gt;<i> It seems that in the tutorials, the only way for consumers to get a
</I>&gt;&gt;<i> message
</I>&gt;&gt;<i> from the queue its connected to is to explicitly call
</I>&gt;&gt;<i> consumer.nextDelivery(). However, as far as my understanding, in order to
</I>&gt;&gt;<i> constantly check for new publications, this call must reside within a
</I>&gt;&gt;<i> while(true) loop. 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Say I wanted to create a consumer with an anonymous queue and attach it
</I>&gt;&gt;<i> to
</I>&gt;&gt;<i> an exchange. Then, I want to make a publication to that exchange. When
</I>&gt;&gt;<i> that
</I>&gt;&gt;<i> publication is made, the consumer will print something to the console
</I>&gt;&gt;<i> using
</I>&gt;&gt;<i> an overridden nextDelivery(). In order to do this, do I have to basically
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 1. Create the consumer/queue and attach it with a routingId to the
</I>&gt;&gt;<i> exchange
</I>&gt;&gt;<i> 2. Publish a method with that routingId to the exchange
</I>&gt;&gt;<i> 3. Invoke the while loop to constantly check for messages
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> in that order?
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> If so, then is there a way to support two (or more) consumers to
</I>&gt;&gt;<i> automatically get nextDelivery? It seems that the only way is to write a
</I>&gt;&gt;<i> while loop that goes through every consumer, and calls nextDelivery on
</I>&gt;&gt;<i> that
</I>&gt;&gt;<i> consumer, in an infinite loop. Instead, is there a way to create an event
</I>&gt;&gt;<i> such that when a queue gets pushed a message, it automatically calls
</I>&gt;&gt;<i> consumer.nextDelivery somehow?
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Thanks in advance for the reply. I'm fairly new to RabbitMQ, so please
</I>&gt;&gt;<i> forgive me if the question is somewhat basic/has already been answered
</I>&gt;&gt;<i> elsewhere :-D.
</I>&gt;&gt;<i> -- 
</I>&gt;&gt;<i> View this message in context:
</I>&gt;&gt;<i> <A HREF="http://old.nabble.com/Consumer-Callback-tp32103305p32103305.html">http://old.nabble.com/Consumer-Callback-tp32103305p32103305.html</A>
</I>&gt;&gt;<i> Sent from the RabbitMQ mailing list archive at Nabble.com.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> rabbitmq-discuss mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>
-- 
View this message in context: <A HREF="http://old.nabble.com/Consumer-Callback-tp32103305p32143563.html">http://old.nabble.com/Consumer-Callback-tp32103305p32143563.html</A>
Sent from the RabbitMQ mailing list archive at Nabble.com.

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014168.html">[rabbitmq-discuss] Consumer Callback
</A></li>
	<LI>Next message: <A HREF="014193.html">[rabbitmq-discuss] Consumer Callback
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14192">[ date ]</a>
              <a href="thread.html#14192">[ thread ]</a>
              <a href="subject.html#14192">[ subject ]</a>
              <a href="author.html#14192">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
