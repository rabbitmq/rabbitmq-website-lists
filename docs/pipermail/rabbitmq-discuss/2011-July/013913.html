<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] 15000 msg/sec
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%2015000%20msg/sec&In-Reply-To=%3CCANVKUrUJ4X6mxoS3Lo5tjsfBguLzA_E40z-dVETA-9pJ-EEUdg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013912.html">
   <LINK REL="Next"  HREF="013914.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] 15000 msg/sec</H1>
    <B>Eugene Kirpichov</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%2015000%20msg/sec&In-Reply-To=%3CCANVKUrUJ4X6mxoS3Lo5tjsfBguLzA_E40z-dVETA-9pJ-EEUdg%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] 15000 msg/sec">ekirpichov at gmail.com
       </A><BR>
    <I>Fri Jul 15 15:27:12 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="013912.html">[rabbitmq-discuss] 15000 msg/sec
</A></li>
        <LI>Next message: <A HREF="013914.html">[rabbitmq-discuss] 15000 msg/sec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13913">[ date ]</a>
              <a href="thread.html#13913">[ thread ]</a>
              <a href="subject.html#13913">[ subject ]</a>
              <a href="author.html#13913">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Is this the minimal piece of code that demonstrates poor performance?
It's hard to decipher that much code and it can have many kinds of
problems inside; I think you should be able to trim it down to a
couple dozen lines demonstrating the same speed; then diagnosing will
become a lot easier.

2011/7/15 News Aanad &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">news.anand11 at gmail.com</A>&gt;:
&gt;<i> This is my code.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> //&#160; The contents of this file are subject to the Mozilla Public License
</I>&gt;<i> //&#160; Version 1.1 (the &quot;License&quot;); you may not use this file except in
</I>&gt;<i> //&#160; compliance with the License. You may obtain a copy of the License
</I>&gt;<i> //&#160; at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
</I>&gt;<i> //
</I>&gt;<i> //&#160; Software distributed under the License is distributed on an &quot;AS IS&quot;
</I>&gt;<i> //&#160; basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
</I>&gt;<i> //&#160; the License for the specific language governing rights and
</I>&gt;<i> //&#160; limitations under the License.
</I>&gt;<i> //
</I>&gt;<i> //&#160; The Original Code is RabbitMQ.
</I>&gt;<i> //
</I>&gt;<i> //&#160; The Initial Developer of the Original Code is VMware, Inc.
</I>&gt;<i> //&#160; Copyright (c) 2007-2011 VMware, Inc.&#160; All rights reserved.
</I>&gt;<i> //
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> package com.rabbitmq.examples;
</I>&gt;<i>
</I>&gt;<i> import java.io.ByteArrayInputStream;
</I>&gt;<i> import java.io.ByteArrayOutputStream;
</I>&gt;<i> import java.io.DataInputStream;
</I>&gt;<i> import java.io.DataOutputStream;
</I>&gt;<i> import java.io.IOException;
</I>&gt;<i> import java.util.Arrays;
</I>&gt;<i> import java.util.Collections;
</I>&gt;<i> import java.util.List;
</I>&gt;<i> import java.util.SortedSet;
</I>&gt;<i> import java.util.TreeSet;
</I>&gt;<i> import java.util.UUID;
</I>&gt;<i> import java.util.concurrent.Semaphore;
</I>&gt;<i>
</I>&gt;<i> import org.apache.commons.cli.CommandLine;
</I>&gt;<i> import org.apache.commons.cli.CommandLineParser;
</I>&gt;<i> import org.apache.commons.cli.GnuParser;
</I>&gt;<i> import org.apache.commons.cli.HelpFormatter;
</I>&gt;<i> import org.apache.commons.cli.Option;
</I>&gt;<i> import org.apache.commons.cli.Options;
</I>&gt;<i> import org.apache.commons.cli.ParseException;
</I>&gt;<i>
</I>&gt;<i> import com.rabbitmq.client.AMQP;
</I>&gt;<i> import com.rabbitmq.client.Channel;
</I>&gt;<i> import com.rabbitmq.client.ConfirmListener;
</I>&gt;<i> import com.rabbitmq.client.Connection;
</I>&gt;<i> import com.rabbitmq.client.ConnectionFactory;
</I>&gt;<i> import com.rabbitmq.client.Envelope;
</I>&gt;<i> import com.rabbitmq.client.MessageProperties;
</I>&gt;<i> import com.rabbitmq.client.QueueingConsumer;
</I>&gt;<i> import com.rabbitmq.client.QueueingConsumer.Delivery;
</I>&gt;<i> import com.rabbitmq.client.ReturnListener;
</I>&gt;<i> import com.rabbitmq.client.ShutdownSignalException;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> public class MulticastMain {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; public static void main(String[] args) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; Options options = getOptions();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; CommandLineParser parser = new GnuParser();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; try {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CommandLine cmd = parser.parse(options, args);
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (cmd.hasOption('?')) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; usage(options);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.exit(0);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String hostName&#160;&#160;&#160;&#160;&#160; = strArg(cmd, 'h', &quot;localhost&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int portNumber&#160;&#160;&#160;&#160;&#160;&#160; = intArg(cmd, 'p', AMQP.PROTOCOL.PORT);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String exchangeType&#160; = strArg(cmd, 't', &quot;direct&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String exchangeName&#160; = strArg(cmd, 'e', exchangeType);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int samplingInterval = intArg(cmd, 'i', 1);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int rateLimit&#160;&#160;&#160;&#160;&#160;&#160;&#160; = intArg(cmd, 'r', 0);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int producerCount&#160;&#160;&#160; = intArg(cmd, 'x', 1);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int consumerCount&#160;&#160;&#160; = intArg(cmd, 'y', 1);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int producerTxSize&#160;&#160; = intArg(cmd, 'm', 0);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int consumerTxSize&#160;&#160; = intArg(cmd, 'n', 0);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long confirm&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; = intArg(cmd, 'c', -1);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; boolean autoAck&#160;&#160;&#160;&#160;&#160; = cmd.hasOption('a');
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int prefetchCount&#160;&#160;&#160; = intArg(cmd, 'q', 0);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int minMsgSize&#160;&#160;&#160;&#160;&#160;&#160; = intArg(cmd, 's', 0);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int timeLimit&#160;&#160;&#160;&#160;&#160;&#160;&#160; = intArg(cmd, 'z', 0);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; List&lt;?&gt; flags&#160;&#160;&#160;&#160;&#160;&#160;&#160; = lstArg(cmd, 'f');
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int frameMax&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; = intArg(cmd, 'M', 0);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int heartbeat&#160;&#160;&#160;&#160;&#160;&#160;&#160; = intArg(cmd, 'b', 0);
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ((producerTxSize &gt; 0) &amp;&amp; confirm &gt;= 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ParseException(&quot;Cannot select both
</I>&gt;<i> producerTxSize&quot;+
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot; and confirm&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //setup
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String id = UUID.randomUUID().toString();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Stats stats = new Stats(1000L * samplingInterval);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ConnectionFactory factory = new ConnectionFactory();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; factory.setHost(hostName);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; factory.setPort(portNumber);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; factory.setRequestedFrameMax(frameMax);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; factory.setRequestedHeartbeat(heartbeat);
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread[] consumerThreads = new Thread[consumerCount];
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Connection[] consumerConnections = new
</I>&gt;<i> Connection[consumerCount];
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (int i = 0; i &lt; consumerCount; i++) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;starting consumer #&quot; + i);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Connection conn = factory.newConnection();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; consumerConnections[i] = conn;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Channel channel = conn.createChannel();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (consumerTxSize &gt; 0) channel.txSelect();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.exchangeDeclare(exchangeName, exchangeType);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String queueName =
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.queueDeclare(&quot;&quot;,
</I>&gt;<i> flags.contains(&quot;persistent&quot;),
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; true, false, null).getQueue();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; QueueingConsumer consumer = new QueueingConsumer(channel);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (prefetchCount &gt; 0) channel.basicQos(prefetchCount);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.basicConsume(queueName, autoAck, consumer);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.queueBind(queueName, exchangeName, id);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread t =
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; new Thread(new Consumer(consumer, id,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; consumerTxSize, autoAck,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stats, timeLimit));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; consumerThreads[i] = t;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; t.start();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread[] producerThreads = new Thread[producerCount];
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Connection[] producerConnections = new
</I>&gt;<i> Connection[producerCount];
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (int i = 0; i &lt; producerCount; i++) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;starting producer #&quot; + i);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Connection conn = factory.newConnection();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; producerConnections[i] = conn;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Channel channel = conn.createChannel();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (producerTxSize &gt; 0) channel.txSelect();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (confirm &gt;= 0) channel.confirmSelect();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.exchangeDeclare(exchangeName, exchangeType);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; final Producer p = new Producer(channel, exchangeName, id,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; flags, producerTxSize,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 1000L * samplingInterval,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; rateLimit, minMsgSize,
</I>&gt;<i> timeLimit,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; confirm);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.setReturnListener(p);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.setConfirmListener(p);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread t = new Thread(p);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; producerThreads[i] = t;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; t.start();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (int i = 0; i &lt; producerCount; i++) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; producerThreads[i].join();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; producerConnections[i].close();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (int i = 0; i &lt; consumerCount; i++) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; consumerThreads[i].join();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; consumerConnections[i].close();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; catch( ParseException exp ) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.err.println(&quot;Parsing failed. Reason: &quot; +
</I>&gt;<i> exp.getMessage());
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; usage(options);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (Exception e) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.err.println(&quot;Main thread caught exception: &quot; + e);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; e.printStackTrace();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.exit(1);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; private static void usage(Options options) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; HelpFormatter formatter = new HelpFormatter();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; formatter.printHelp(&quot;&lt;program&gt;&quot;, options);
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; private static Options getOptions() {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; Options options = new Options();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;?&quot;, &quot;help&quot;,&#160;&#160;&#160;&#160;&#160; false,&quot;show usage&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;h&quot;, &quot;host&quot;,&#160;&#160;&#160;&#160;&#160; true, &quot;broker
</I>&gt;<i> host&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;p&quot;, &quot;port&quot;,&#160;&#160;&#160;&#160;&#160; true, &quot;broker
</I>&gt;<i> port&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;t&quot;, &quot;type&quot;,&#160;&#160;&#160;&#160;&#160; true, &quot;exchange
</I>&gt;<i> type&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;e&quot;, &quot;exchange&quot;,&#160; true, &quot;exchange
</I>&gt;<i> name&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;i&quot;, &quot;interval&quot;,&#160; true, &quot;sampling
</I>&gt;<i> interval&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;r&quot;, &quot;rate&quot;,&#160;&#160;&#160;&#160;&#160; true, &quot;rate limit&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;x&quot;, &quot;producers&quot;, true, &quot;producer
</I>&gt;<i> count&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;y&quot;, &quot;consumers&quot;, true, &quot;consumer
</I>&gt;<i> count&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;m&quot;, &quot;ptxsize&quot;,&#160;&#160; true, &quot;producer tx
</I>&gt;<i> size&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;n&quot;, &quot;ctxsize&quot;,&#160;&#160; true, &quot;consumer tx
</I>&gt;<i> size&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;c&quot;, &quot;confirm&quot;,&#160;&#160; true, &quot;max
</I>&gt;<i> unconfirmed publishes&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;a&quot;, &quot;autoack&quot;,&#160;&#160; false,&quot;auto ack&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;q&quot;, &quot;qos&quot;,&#160;&#160;&#160;&#160;&#160;&#160; true, &quot;qos prefetch
</I>&gt;<i> count&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;s&quot;, &quot;size&quot;,&#160;&#160;&#160;&#160;&#160; true, &quot;message
</I>&gt;<i> size&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;z&quot;, &quot;time&quot;,&#160;&#160;&#160;&#160;&#160; true, &quot;time limit&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; Option flag =&#160;&#160;&#160;&#160; new Option(&quot;f&quot;, &quot;flag&quot;,&#160;&#160;&#160;&#160;&#160; true, &quot;message
</I>&gt;<i> flag&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; flag.setArgs(Option.UNLIMITED_VALUES);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(flag);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;M&quot;, &quot;framemax&quot;,&#160; true, &quot;frame max&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; options.addOption(new Option(&quot;b&quot;, &quot;heartbeat&quot;, true, &quot;heartbeat
</I>&gt;<i> interval&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; return options;
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; private static String strArg(CommandLine cmd, char opt, String def) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; return cmd.getOptionValue(opt, def);
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; private static int intArg(CommandLine cmd, char opt, int def) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; return Integer.parseInt(cmd.getOptionValue(opt,
</I>&gt;<i> Integer.toString(def)));
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; private static List&lt;?&gt; lstArg(CommandLine cmd, char opt) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; String[] vals = cmd.getOptionValues('f');
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; if (vals == null) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; vals = new String[] {};
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; return Arrays.asList(vals);
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; public static class Producer implements Runnable, ReturnListener,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ConfirmListener
</I>&gt;<i> &#160;&#160;&#160; {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private Channel channel;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private String&#160; exchangeName;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private String&#160; id;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private boolean mandatory;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private boolean immediate;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private boolean persistent;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private int&#160;&#160;&#160;&#160; txSize;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; interval;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private int&#160;&#160;&#160;&#160; rateLimit;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; timeLimit;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private byte[]&#160; message;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; startTime;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; lastStatsTime;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private int&#160;&#160;&#160;&#160; msgCount;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private int&#160;&#160;&#160;&#160; returnCount;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160;&#160;&#160; confirm;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private Semaphore confirmPool;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160;&#160;&#160; confirmCount;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160;&#160;&#160; nackCount;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private volatile SortedSet&lt;Long&gt; unconfirmedSet =
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Collections.synchronizedSortedSet(new TreeSet&lt;Long&gt;());
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public Producer(Channel channel, String exchangeName, String id,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; List&lt;?&gt; flags, int txSize,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long interval, int rateLimit, int minMsgSize, int
</I>&gt;<i> timeLimit,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long confirm)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throws IOException {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.channel&#160;&#160;&#160;&#160;&#160; = channel;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.exchangeName = exchangeName;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.id&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; = id;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.mandatory&#160;&#160;&#160; = flags.contains(&quot;mandatory&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.immediate&#160;&#160;&#160; = flags.contains(&quot;immediate&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.persistent&#160;&#160; = flags.contains(&quot;persistent&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.txSize&#160;&#160;&#160;&#160;&#160;&#160; = txSize;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.interval&#160;&#160;&#160;&#160; = interval;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.rateLimit&#160;&#160;&#160; = rateLimit;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.timeLimit&#160;&#160;&#160; = 1000L * timeLimit;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.message&#160;&#160;&#160;&#160;&#160; = new byte[minMsgSize];
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.confirm&#160;&#160;&#160;&#160;&#160; = confirm;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (confirm &gt; 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.confirmPool&#160; = new Semaphore((int)confirm);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public synchronized void handleReturn(int replyCode,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String replyText,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String exchange,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String routingKey,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; AMQP.BasicProperties
</I>&gt;<i> properties,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; byte[] body)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throws IOException {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; returnCount++;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public void handleAck(long seqNo, boolean multiple) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; handleAckNack(seqNo, multiple, false);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public void handleNack(long seqNo, boolean multiple) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; handleAckNack(seqNo, multiple, true);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private void handleAckNack(long seqNo, boolean multiple,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; boolean nack) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int numConfirms = 0;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (multiple) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; SortedSet&lt;Long&gt; confirmed = unconfirmedSet.headSet(seqNo +
</I>&gt;<i> 1);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; numConfirms += confirmed.size();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; confirmed.clear();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unconfirmedSet.remove(seqNo);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; numConfirms = 1;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; synchronized (this) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (nack) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; nackCount += numConfirms;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; confirmCount += numConfirms;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (confirmPool != null) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (int i = 0; i &lt; numConfirms; ++i) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; confirmPool.release();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public void run() {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long now;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; now = startTime = lastStatsTime = System.currentTimeMillis();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; msgCount = 0;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int totalMsgCount = 0;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while (timeLimit == 0 || now &lt; startTime + timeLimit) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (confirmPool != null) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; confirmPool.acquire();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; delay(now);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; publish(createMessage(totalMsgCount));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; totalMsgCount++;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; msgCount++;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (txSize != 0 &amp;&amp; totalMsgCount % txSize == 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.txCommit();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; now = System.currentTimeMillis();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (IOException e) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new RuntimeException(e);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException e) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new RuntimeException (e);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;sending rate avg: &quot; +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (totalMsgCount * 1000L / (now - startTime)) +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot; msg/s&quot;);
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private void publish(byte[] msg)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throws IOException {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unconfirmedSet.add(channel.getNextPublishSeqNo());
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.basicPublish(exchangeName, id,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; mandatory, immediate,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; persistent ?
</I>&gt;<i> MessageProperties.MINIMAL_PERSISTENT_BASIC :
</I>&gt;<i> MessageProperties.MINIMAL_BASIC,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; msg);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private void delay(long now)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throws InterruptedException {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long elapsed = now - lastStatsTime;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //example: rateLimit is 5000 msg/s,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //10 ms have elapsed, we have sent 200 messages
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //the 200 msgs we have actually sent should have taken us
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //200 * 1000 / 5000 = 40 ms. So we pause for 40ms - 10ms
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long pause = rateLimit == 0 ?
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0 : (msgCount * 1000L / rateLimit - elapsed);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (pause &gt; 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(pause);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (elapsed &gt; interval) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long sendRate, returnRate, confirmRate, nackRate;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; synchronized(this) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sendRate&#160;&#160;&#160;&#160; = msgCount&#160;&#160;&#160;&#160; * 1000L / elapsed;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; returnRate&#160;&#160; = returnCount&#160; * 1000L / elapsed;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; confirmRate&#160; = confirmCount * 1000L / elapsed;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; nackRate&#160;&#160;&#160;&#160; = nackCount&#160;&#160;&#160; * 1000L / elapsed;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; msgCount&#160;&#160;&#160;&#160; = 0;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; returnCount&#160; = 0;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; confirmCount = 0;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; nackCount&#160;&#160;&#160; = 0;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.print(&quot;sending rate: &quot; + sendRate + &quot; msg/s&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (mandatory || immediate) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.print(&quot;, returns: &quot; + returnRate + &quot; ret/s&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (confirm &gt;= 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.print(&quot;, confirms: &quot; + confirmRate + &quot; c/s&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (nackRate &gt; 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.print(&quot;, nacks: &quot; + nackRate + &quot; n/s&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; lastStatsTime = now;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private byte[] createMessage(int sequenceNumber)
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throws IOException {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ByteArrayOutputStream acc = new ByteArrayOutputStream();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; DataOutputStream d = new DataOutputStream(acc);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long nano = System.nanoTime();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; d.writeInt(sequenceNumber);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; d.writeLong(nano);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; d.flush();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; acc.flush();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; byte[] m = acc.toByteArray();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (m.length &lt;= message.length) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.arraycopy(m, 0, message, 0, m.length);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return message;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return m;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; public static class Consumer implements Runnable {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private QueueingConsumer q;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private String&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; id;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; txSize;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private boolean&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; autoAck;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private Stats&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stats;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; timeLimit;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public Consumer(QueueingConsumer q, String id,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int txSize, boolean autoAck,
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Stats stats, int timeLimit) {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.q&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; = q;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.id&#160;&#160;&#160;&#160;&#160;&#160;&#160; = id;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.txSize&#160;&#160;&#160; = txSize;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.autoAck&#160;&#160; = autoAck;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.stats&#160;&#160;&#160;&#160; = stats;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.timeLimit = 1000L * timeLimit;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public void run() {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long now;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long startTime;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; startTime = now = System.currentTimeMillis();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int totalMsgCount = 0;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Channel channel = q.getChannel();
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; while (timeLimit == 0 || now &lt; startTime + timeLimit) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Delivery delivery;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (timeLimit == 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; delivery = q.nextDelivery();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; delivery = q.nextDelivery(startTime + timeLimit -
</I>&gt;<i> now);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (delivery == null) break;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160; &#160;&#160;&#160; &#160;&#160;&#160; totalMsgCount++;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; DataInputStream d = new DataInputStream(new
</I>&gt;<i> ByteArrayInputStream(delivery.getBody()));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; d.readInt();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long msgNano = d.readLong();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long nano = System.nanoTime();
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Envelope envelope = delivery.getEnvelope();
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!autoAck) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.basicAck(envelope.getDeliveryTag(), false);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (txSize != 0 &amp;&amp; totalMsgCount % txSize == 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; channel.txCommit();
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; now = System.currentTimeMillis();
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stats.collectStats(now,
</I>&gt;<i> id.equals(envelope.getRoutingKey()) ? (nano - msgNano) : 0L);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (IOException e) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new RuntimeException(e);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException e) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new RuntimeException (e);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (ShutdownSignalException e) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new RuntimeException(e);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long elapsed = now - startTime;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (elapsed &gt; 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;recving rate avg: &quot; +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (totalMsgCount * 1000L / elapsed) +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot; msg/s&quot;);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; public static class Stats {
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; interval;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; lastStatsTime;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private int&#160;&#160;&#160;&#160; msgCount;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private int&#160;&#160;&#160;&#160; latencyCount;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; minLatency;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; maxLatency;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private long&#160;&#160;&#160; cumulativeLatency;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public Stats(long interval) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.interval = interval;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; reset(System.currentTimeMillis());
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; private void reset(long t) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; lastStatsTime&#160;&#160;&#160;&#160; = t;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; msgCount&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; = 0;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; latencyCount&#160;&#160;&#160;&#160;&#160; = 0;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; minLatency&#160;&#160;&#160;&#160;&#160;&#160;&#160; = Long.MAX_VALUE;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxLatency&#160;&#160;&#160;&#160;&#160;&#160;&#160; = Long.MIN_VALUE;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cumulativeLatency = 0L;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; public synchronized void collectStats(long now, long latency) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; msgCount++;
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (latency &gt; 0) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; minLatency = Math.min(minLatency, latency);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxLatency = Math.max(maxLatency, latency);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cumulativeLatency += latency;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; latencyCount++;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; long elapsed = now - lastStatsTime;
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (elapsed &gt; interval) {
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;recving rate: &quot; +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (1000L * msgCount / elapsed) +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot; msg/s&quot; +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (latencyCount &gt; 0 ?
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;, min/avg/max latency: &quot; +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; minLatency/1000L + &quot;/&quot; +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cumulativeLatency / (1000L *
</I>&gt;<i> latencyCount) + &quot;/&quot; +
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; maxLatency/1000L + &quot; microseconds&quot; :
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;&quot;));
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; reset(now);
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;&#160;&#160; }
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Fri, Jul 15, 2011 at 7:06 PM, Eugene Kirpichov &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ekirpichov at gmail.com</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am sorry but this link doesn't have any source code - this is the
</I>&gt;&gt;<i> library.
</I>&gt;&gt;<i> I meant *your* source code, the code of your program; the code which
</I>&gt;&gt;<i> exercises the library and gets 5000 msg/s.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> P.S. Please use &quot;Reply all&quot;, this discussion is most probably
</I>&gt;&gt;<i> interesting for many people in the community.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 2011/7/15 News Aanad &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">news.anand11 at gmail.com</A>&gt;:
</I>&gt;&gt;<i> &gt; I am following this link for my java code:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; <A HREF="http://www.rabbitmq.com/releases/rabbitmq-java-client/v2.5.1/rabbitmq-java-client-bin-2.5.1.tar.gz">http://www.rabbitmq.com/releases/rabbitmq-java-client/v2.5.1/rabbitmq-java-client-bin-2.5.1.tar.gz</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; On Fri, Jul 15, 2011 at 6:56 PM, Eugene Kirpichov &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ekirpichov at gmail.com</A>&gt;
</I>&gt;&gt;<i> &gt; wrote:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Please show the source code of all participating components. It's
</I>&gt;&gt;<i> &gt;&gt; impossible to say anything definite without it.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; 2011/7/15 News Aanad &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">news.anand11 at gmail.com</A>&gt;:
</I>&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt; Till now i am getting the result of 5000 msg/sec in java.
</I>&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt; On Fri, Jul 15, 2011 at 6:53 PM, Eugene Kirpichov
</I>&gt;&gt;<i> &gt;&gt; &gt; &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ekirpichov at gmail.com</A>&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt; wrote:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; I guess you should get the speed you want, and much more, if you
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; just
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; set up a high enough value for prefetch (see basic.qos) and set
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; autoack.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; I got ~8k msg/s with much larger messages and persistence turned on
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; too.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; 2011/7/15 News Aanad &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">news.anand11 at gmail.com</A>&gt;:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; Message size is 199 bytes
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; Messaging scenario is Persistence
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; On Fri, Jul 15, 2011 at 6:47 PM, Eugene Kirpichov
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ekirpichov at gmail.com</A>&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt; wrote:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; Hi.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; What's the size of messages?
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; What's your messaging scenario in general? Persistence, prefetch,
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; transactions?
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; 2011/7/15 News Aanad &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">news.anand11 at gmail.com</A>&gt;:
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; Hi, I wanted to achieve the goal of 15000 msg/sec in RabbitMQ.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; I
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; have
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; tried a lot in java as well as in ruby. And right now
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; implementing
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; node.js .
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; I want to prefer java because after lots of experimentation the
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; only
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; java has given me good result but still goal is not achieved.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; So i want help to know how to reach upto 15000 msg/sec in
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; RabbitMQ
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; using java. If any good suggestion &#160;is there please tell me or
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; if
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; any
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; site to prefer then please tell me.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; Thanks.
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; _______________________________________________
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; rabbitmq-discuss mailing list
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; --
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; Eugene Kirpichov
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; Principal Engineer, Mirantis Inc. <A HREF="http://www.mirantis.com/">http://www.mirantis.com/</A>
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;&gt; Editor, <A HREF="http://fprog.ru/">http://fprog.ru/</A>
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; --
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; Eugene Kirpichov
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; Principal Engineer, Mirantis Inc. <A HREF="http://www.mirantis.com/">http://www.mirantis.com/</A>
</I>&gt;&gt;<i> &gt;&gt; &gt;&gt; Editor, <A HREF="http://fprog.ru/">http://fprog.ru/</A>
</I>&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt; &gt;
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; --
</I>&gt;&gt;<i> &gt;&gt; Eugene Kirpichov
</I>&gt;&gt;<i> &gt;&gt; Principal Engineer, Mirantis Inc. <A HREF="http://www.mirantis.com/">http://www.mirantis.com/</A>
</I>&gt;&gt;<i> &gt;&gt; Editor, <A HREF="http://fprog.ru/">http://fprog.ru/</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> --
</I>&gt;&gt;<i> Eugene Kirpichov
</I>&gt;&gt;<i> Principal Engineer, Mirantis Inc. <A HREF="http://www.mirantis.com/">http://www.mirantis.com/</A>
</I>&gt;&gt;<i> Editor, <A HREF="http://fprog.ru/">http://fprog.ru/</A>
</I>&gt;<i>
</I>&gt;<i>
</I>


-- 
Eugene Kirpichov
Principal Engineer, Mirantis Inc. <A HREF="http://www.mirantis.com/">http://www.mirantis.com/</A>
Editor, <A HREF="http://fprog.ru/">http://fprog.ru/</A>
</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013912.html">[rabbitmq-discuss] 15000 msg/sec
</A></li>
	<LI>Next message: <A HREF="013914.html">[rabbitmq-discuss] 15000 msg/sec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13913">[ date ]</a>
              <a href="thread.html#13913">[ thread ]</a>
              <a href="subject.html#13913">[ subject ]</a>
              <a href="author.html#13913">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
