<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] flow control issues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3CAANLkTinTckbgOSDXwcSAQLObtPTi9m_w6aihU1ABGzZA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008857.html">
   <LINK REL="Next"  HREF="008905.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] flow control issues</H1>
    <B>Marek Majkowski</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3CAANLkTinTckbgOSDXwcSAQLObtPTi9m_w6aihU1ABGzZA%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] flow control issues">majek04 at gmail.com
       </A><BR>
    <I>Fri Sep 10 14:06:56 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="008857.html">[rabbitmq-discuss] flow control issues
</A></li>
        <LI>Next message: <A HREF="008905.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8887">[ date ]</a>
              <a href="thread.html#8887">[ thread ]</a>
              <a href="subject.html#8887">[ subject ]</a>
              <a href="author.html#8887">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Romary,

First, thank a lot for the feedback. For example the information about
SSL memory
usage is indeed very interesting. (if that is a big problem to you,
you may always
fall back to the old technique of using stunnel)

The flow control was heavily modified between 1.8.1 and 2.0.0. In summary:
 - 1.8.1 - we have send Channel.flow AMQP message to everyone once
   rabbit reached memory limit
 - 2.0.0 - once we reach memory limit, the connections from which we hear
   publishes are stopped temporarily. We stop receiving bytes from tcp sockets.
   That 'stop' shouldn't take too long, as data should be swapped out to disk
   and memory pressure will drop pretty quickly.


On Wed, Sep 8, 2010 at 11:49, Romary Kremer &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">romary.kremer at gmail.com</A>&gt; wrote:
&gt;<i> I've started playing a bit with the latest release 2.0.0 and I m affraid
</I>&gt;<i> that it looks like their are some regression or at least some semantic
</I>&gt;<i> updates.
</I>
It's best if you upgraded both server and client library. Do you have any
particular problems? A lot was changed in 2.0.0 but we think it's fully
functional. If you found something that blocks you to migrate, you
could report a bug.

&gt;<i> It looks like any listener is called back &#160;when the alarm handler is set or
</I>&gt;<i> cleared, while the producers are still paused / resumed
</I>&gt;<i> like their are to be.
</I>
Interesting. Maybe we have a race there? Or maybe you're blocking
the main java client thread? (nothing blocking should be done from
the main thread)

&gt;&gt;<i> during long running tests, we have encountered strange behaviour due to
</I>&gt;&gt;<i> flow control :
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The queue depth starts to increase linearly for about 2 hours, these is
</I>&gt;&gt;<i> coherent since the message throughput of the single consumer
</I>&gt;&gt;<i> is not enough to absorb message ingress. Memory occupation grow faster as
</I>&gt;&gt;<i> well, until the memory watermark is reached on the broker side.
</I>
Are you sure your consumer is ACK-ing the messages it received?

&gt;&gt;<i> From that point, the producers are indeed paused, as flow control request
</I>&gt;&gt;<i> has been issued by the broker, but the consumer seems to be blocked
</I>&gt;&gt;<i> as well. The queue level is flatten at its top value until the end of the
</I>&gt;&gt;<i> test, even when memory occupation lowered under the threshold.
</I>
That's how 1.8.1 behaves. In 2.0.0 we introduced swapping out big queues
to disk, so the memory usage shouldn't be dependent on a queue size.

&gt;&gt;<i> By registering the FlowListener callback, we have noticed that not all of
</I>&gt;&gt;<i> the producers are notified all the time the alarm handler is set.
</I>&gt;&gt;<i> Does this mean that the broker applies some heuristic to try not to block
</I>&gt;&gt;<i> every body every time ?
</I>&gt;&gt;<i> Or does it mean that some of the channels have been somehow blacklisted by
</I>&gt;&gt;<i> the broker ?
</I>
No, in 1.8.1 broker should send 'channel.flow' to all the channels.

&gt;&gt;<i> Could anybody explain how the blocking of consumer is assumed to be
</I>&gt;&gt;<i> implemented ?
</I>
The best description is probably here:
  <A HREF="http://www.rabbitmq.com/extensions.html#memsup">http://www.rabbitmq.com/extensions.html#memsup</A>

But it covers 2.0.0. I'd suggest an upgrade to 2.0.0 and monitoring
not only queue size but also number of unacknowledged messages
('Msg unack' in status plugin). This number should be near zero.

Cheers,
  Marek Majkowski
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008857.html">[rabbitmq-discuss] flow control issues
</A></li>
	<LI>Next message: <A HREF="008905.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8887">[ date ]</a>
              <a href="thread.html#8887">[ thread ]</a>
              <a href="subject.html#8887">[ subject ]</a>
              <a href="author.html#8887">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
