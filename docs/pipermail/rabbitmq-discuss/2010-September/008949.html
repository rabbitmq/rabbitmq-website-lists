<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] flow control issues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3C0AD84B1E-7A80-48AB-A4D9-477A577AA862%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008942.html">
   <LINK REL="Next"  HREF="008963.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] flow control issues</H1>
    <B>romary.kremer at gmail.com</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3C0AD84B1E-7A80-48AB-A4D9-477A577AA862%40gmail.com%3E"
       TITLE="[rabbitmq-discuss] flow control issues">romary.kremer at gmail.com
       </A><BR>
    <I>Wed Sep 15 19:11:47 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="008942.html">[rabbitmq-discuss] flow control issues
</A></li>
        <LI>Next message: <A HREF="008963.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8949">[ date ]</a>
              <a href="thread.html#8949">[ thread ]</a>
              <a href="subject.html#8949">[ subject ]</a>
              <a href="author.html#8949">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Le 15 sept. 10 &#224; 16:11, Marek Majkowski a &#233;crit :

&gt;<i> On Tue, Sep 14, 2010 at 09:07, <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">romary.kremer at gmail.com</A>
</I>&gt;<i> &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">romary.kremer at gmail.com</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> The flow control was heavily modified between 1.8.1 and 2.0.0. In  
</I>&gt;&gt;&gt;<i> summary:
</I>&gt;&gt;&gt;<i> - 1.8.1 - we have send Channel.flow AMQP message to everyone once
</I>&gt;&gt;&gt;<i>  rabbit reached memory limit
</I>&gt;&gt;&gt;<i> - 2.0.0 - once we reach memory limit, the connections from which  
</I>&gt;&gt;&gt;<i> we hear
</I>&gt;&gt;&gt;<i>  publishes are stopped temporarily. We stop receiving bytes from tcp
</I>&gt;&gt;&gt;<i> sockets.
</I>&gt;&gt;&gt;<i>  That 'stop' shouldn't take too long, as data should be swapped  
</I>&gt;&gt;&gt;<i> out to
</I>&gt;&gt;&gt;<i> disk
</I>&gt;&gt;&gt;<i>  and memory pressure will drop pretty quickly.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Do you mean that in 2.0.0 the Channel.flow AMQP message is no  
</I>&gt;&gt;<i> longer sent to
</I>&gt;&gt;<i> the producer that are stopped temporarily ? So that would explain why
</I>&gt;&gt;<i>        1) Channel.publish() can be blocking on the client side when  
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> broker stop
</I>&gt;&gt;<i>        reading from the socket !
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>        2) FlowListener.handleFlow() is no longer invoked on the  
</I>&gt;&gt;<i> registered
</I>&gt;&gt;<i> listener when
</I>&gt;&gt;<i>        the alarm handler is set or cleared
</I>&gt;&gt;<i> Are my deduction wright ?
</I>&gt;<i>
</I>&gt;<i> Yes. You will never hear &quot;FlowListener.handleFlow()&quot; and it may be  
</I>&gt;<i> possible for
</I>&gt;<i> channel.publish to block (though I would need to consult the sources
</I>&gt;<i> to be sure).
</I>
It seems to me that FlowListener interface is likely to be deprecated  
so, does'nt it ?
Does not really matter for us anyway, cause we where on wrong idea  
using that.
Does this new implementation keep the broker on track for compliance  
with specification then ?

&gt;<i>
</I>&gt;&gt;<i> Do you have any figures to quantify &quot;should, not take too long&quot; ?  
</I>&gt;&gt;<i> Are their
</I>&gt;&gt;<i> some
</I>&gt;&gt;<i> test reports available about that major evolution ?
</I>&gt;<i>
</I>&gt;<i> That's the question we really avoided :) Oh, well. No, we haven't  
</I>&gt;<i> done any
</I>&gt;<i> 'real' tests, it's only based on our intuition and experience. In most
</I>&gt;<i> cases the blocking goes away pretty quickly - after 30 seconds  
</I>&gt;<i> usually,
</I>&gt;<i> about two minutes sometimes.
</I>
This would be acceptable for our needs, only if we can somehow  
guarantee that's an upper boundary !
&gt;<i>
</I>&gt;<i> But it is possible to create a very pessimistic environment in which  
</I>&gt;<i> the
</I>&gt;<i> memory usage will not drop - and the connection could be stuck for a  
</I>&gt;<i> long time.
</I>&gt;<i> (though it's pretty unlikely).
</I>
... Not that much unlikely, considering my little playing with the  
MultiCastMain sample (see my previous reply about it for details).
I get 100 % times blocked connection.
What would be, based on your knowledge and your intuition, &quot;a very  
pessimistic environment in which the memory usage will not drop&quot; ?

I think that the experimentation I've done on the MultiCastMain is  
maybe a beginning of an answer for that question, although I would
never have considered that a single producer could have such power to  
flood the broker.

&gt;<i>
</I>&gt;&gt;<i> Sorry If I wasn't clear on the previous post ,we are already in  
</I>&gt;&gt;<i> 2.0.0 for
</I>&gt;&gt;<i> both broker and
</I>&gt;&gt;<i> client library.
</I>&gt;<i>
</I>&gt;<i> Good.
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> It looks like any listener is called back  when the alarm handler  
</I>&gt;&gt;&gt;&gt;<i> is set
</I>&gt;&gt;&gt;&gt;<i> or
</I>&gt;&gt;&gt;&gt;<i> cleared, while the producers are still paused / resumed
</I>&gt;&gt;&gt;&gt;<i> like their are to be.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Interesting. Maybe we have a race there? Or maybe you're blocking
</I>&gt;&gt;&gt;<i> the main java client thread? (nothing blocking should be done from
</I>&gt;&gt;&gt;<i> the main thread)
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I am quite sure I am not blocking the main thread, neither the  
</I>&gt;&gt;<i> Connection
</I>&gt;&gt;<i> Thread. All
</I>&gt;&gt;<i> the message-related logic is in a particular thread (Some kind of
</I>&gt;&gt;<i> ProducerGroup
</I>&gt;&gt;<i> pool of threads actually).
</I>&gt;&gt;<i> Consumer call back are running within the Connection thread if I  
</I>&gt;&gt;<i> refer to
</I>&gt;&gt;<i> the Javadoc !
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The same code using the library version 1.8.1, The callback where  
</I>&gt;&gt;<i> invoked
</I>&gt;&gt;<i> when
</I>&gt;&gt;<i> alarm handler is set or cleared anyway.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> during long running tests, we have encountered strange behaviour  
</I>&gt;&gt;&gt;&gt;&gt;<i> due to
</I>&gt;&gt;&gt;&gt;&gt;<i> flow control :
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> The queue depth starts to increase linearly for about 2 hours,  
</I>&gt;&gt;&gt;&gt;&gt;<i> these is
</I>&gt;&gt;&gt;&gt;&gt;<i> coherent since the message throughput of the single consumer
</I>&gt;&gt;&gt;&gt;&gt;<i> is not enough to absorb message ingress. Memory occupation grow  
</I>&gt;&gt;&gt;&gt;&gt;<i> faster
</I>&gt;&gt;&gt;&gt;&gt;<i> as
</I>&gt;&gt;&gt;&gt;&gt;<i> well, until the memory watermark is reached on the broker side.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Are you sure your consumer is ACK-ing the messages it received?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The Consumer call back does ACK messages upon reception, one at a  
</I>&gt;&gt;<i> time
</I>&gt;&gt;<i> (multiple == false).
</I>&gt;&gt;<i> Does the basic.ack() method is eligible to be blocked as well as  
</I>&gt;&gt;<i> publish()
</I>&gt;&gt;<i> upon flow control ?
</I>&gt;<i>
</I>&gt;<i> Well, under current implementation of flow control - yes. As it's  
</I>&gt;<i> whole
</I>&gt;<i> tcp/ip connection that gets blocked. It will affect any commands,  
</I>&gt;<i> including
</I>&gt;<i> basic.ack.
</I>&gt;<i>
</I>&gt;<i> What we usually propose is to use different tcp/ip connection for  
</I>&gt;<i> receiving
</I>&gt;<i> and different for publishing. On memory pressure we only block the  
</I>&gt;<i> publishers.
</I>&gt;<i> Using separate connection only for receiving you may be sure it will
</I>&gt;<i> never be blocked.
</I>
Weren't Channel design for that ? In our environment, we have  
(naively ?) considered the use of Channel to
separate the message production from the consumption.
Since we are targeting 10 000 peers doing both production and  
consumption, the fact of multiplying the number of
connections by 2 is not negligible at all, considering scalability.
Moreover, as I reported later on, we use SSL to authenticate the  
broker, and we are still unclear about memory leaks
induce by SSL connections. Doubling the number of connections will not  
be negligible at all considering memory occupation either.
In conclusion, we are not likely to implement our peers using 2  
connections for the same broker.
What would you recommend to us then ? And could you give us a better  
understanding on the use case of channels ?

&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> From that point, the producers are indeed paused, as flow control
</I>&gt;&gt;&gt;&gt;&gt;<i> request
</I>&gt;&gt;&gt;&gt;&gt;<i> has been issued by the broker, but the consumer seems to be  
</I>&gt;&gt;&gt;&gt;&gt;<i> blocked
</I>&gt;&gt;&gt;&gt;&gt;<i> as well. The queue level is flatten at its top value until the  
</I>&gt;&gt;&gt;&gt;&gt;<i> end of
</I>&gt;&gt;&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;&gt;&gt;<i> test, even when memory occupation lowered under the threshold.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> That's how 1.8.1 behaves. In 2.0.0 we introduced swapping out big  
</I>&gt;&gt;&gt;<i> queues
</I>&gt;&gt;&gt;<i> to disk, so the memory usage shouldn't be dependent on a queue size.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Good new, because we had identified 2 scenarios in wich memory- 
</I>&gt;&gt;<i> based channel
</I>&gt;&gt;<i> flow
</I>&gt;&gt;<i> was triggered :
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>        - the use of SSL
</I>&gt;&gt;<i>        - the use of larger message (4kb, same ingress)
</I>&gt;&gt;<i> Now I hope that the message size will not be that much determinant  
</I>&gt;&gt;<i> for flow
</I>&gt;&gt;<i> controll,as soon
</I>&gt;&gt;<i> as consumers are able to handle these message regularly.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> By registering the FlowListener callback, we have noticed that  
</I>&gt;&gt;&gt;&gt;&gt;<i> not all
</I>&gt;&gt;&gt;&gt;&gt;<i> of
</I>&gt;&gt;&gt;&gt;&gt;<i> the producers are notified all the time the alarm handler is set.
</I>&gt;&gt;&gt;&gt;&gt;<i> Does this mean that the broker applies some heuristic to try not  
</I>&gt;&gt;&gt;&gt;&gt;<i> to
</I>&gt;&gt;&gt;&gt;&gt;<i> block
</I>&gt;&gt;&gt;&gt;&gt;<i> every body every time ?
</I>&gt;&gt;&gt;&gt;&gt;<i> Or does it mean that some of the channels have been somehow  
</I>&gt;&gt;&gt;&gt;&gt;<i> blacklisted
</I>&gt;&gt;&gt;&gt;&gt;<i> by
</I>&gt;&gt;&gt;&gt;&gt;<i> the broker ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> No, in 1.8.1 broker should send 'channel.flow' to all the channels.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Strange so, their must be some thing very weird.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Could anybody explain how the blocking of consumer is assumed to  
</I>&gt;&gt;&gt;&gt;&gt;<i> be
</I>&gt;&gt;&gt;&gt;&gt;<i> implemented ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The best description is probably here:
</I>&gt;&gt;&gt;<i>  <A HREF="http://www.rabbitmq.com/extensions.html#memsup">http://www.rabbitmq.com/extensions.html#memsup</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> But it covers 2.0.0. I'd suggest an upgrade to 2.0.0 and monitoring
</I>&gt;&gt;&gt;<i> not only queue size but also number of unacknowledged messages
</I>&gt;&gt;&gt;<i> ('Msg unack' in status plugin). This number should be near zero.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> We are already with 2.0.0.
</I>&gt;&gt;<i> Where can I find some doc about the Status plugin anyway ?
</I>&gt;<i>
</I>&gt;<i> I'm afraid the old blog post is the only source:
</I>&gt;<i> <A HREF="http://www.lshift.net/blog/2009/11/30/introducing-rabbitmq-status-plugin">http://www.lshift.net/blog/2009/11/30/introducing-rabbitmq-status-plugin</A>
</I>
Take it easy, it was really straight forward to install it after all.  
for those who would experiment some issues just
go in /usr/lib/rabbitmq/lib/rabbitmq_server-2.0.0/plugins then get
	-mochiweb-2.0.0.ez
	-rabbitmq-mochiweb-2.0.0.ez
	-rabbit_status-2.0.0.ez
from here, and voila !!

B.R,

Romary.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100915/58b83b72/attachment-0001.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100915/58b83b72/attachment-0001.htm</A>&gt;
</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008942.html">[rabbitmq-discuss] flow control issues
</A></li>
	<LI>Next message: <A HREF="008963.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8949">[ date ]</a>
              <a href="thread.html#8949">[ thread ]</a>
              <a href="subject.html#8949">[ subject ]</a>
              <a href="author.html#8949">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
