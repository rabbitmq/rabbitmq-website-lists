<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] flow control issues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3CE1ED8931-797F-4DC8-889A-2BDDFA6C54CD%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009079.html">
   <LINK REL="Next"  HREF="008958.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] flow control issues</H1>
    <B>romary.kremer at gmail.com</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3CE1ED8931-797F-4DC8-889A-2BDDFA6C54CD%40gmail.com%3E"
       TITLE="[rabbitmq-discuss] flow control issues">romary.kremer at gmail.com
       </A><BR>
    <I>Wed Sep 15 14:45:50 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="009079.html">[rabbitmq-discuss] flow control issues
</A></li>
        <LI>Next message: <A HREF="008958.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8940">[ date ]</a>
              <a href="thread.html#8940">[ thread ]</a>
              <a href="subject.html#8940">[ subject ]</a>
              <a href="author.html#8940">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,
since I can not find out the reasons of our problems yet, I've decided  
to perform some more basics tests.

Here are the latest results I' ve gathered by doing some test with the  
MultiCastMain program from java client 2.0.0

First of all, let me introduce the modifications I have performed on  
the MultiCastMain to allow more flexibility in the configuration :
	- introduction of optional parameter &quot;-D&quot; to toggle Durability of  
exchange and queue ON (missing value means OFF)
	- introduction of optional parameter &quot;-A&quot; to toggle autodelete of the  
queue ON (missing value means OFF)
	- introduction of optional parameter &quot;-X&quot; to toggle exclusiveness on  
the queue ON (missing value means OFF)
	- introduction of optional parameter &quot;-Q&quot; to give a name to a queue :  
useful to fetch messages from the same queue between several executions.
	- introduction of optional parameter &quot;-K&quot; to give the same routing  
key (for producer) and binding key (for consumer) between several  
executions.

Here after is a snippet of /etc/rabbitmq/rabbitmq.config :
	[
   	{rabbit, [
      		{vm_memory_high_watermark, 0.05},
      		{ssl_listeners, [{&quot;0.0.0.0&quot;,5671}]},
      		{ssl_options, [{cacertfile,&quot;/var/lib/rabbitmq/ssl/certificate- 
authority/schneider-ca.pem&quot;},
                    	{certfile,&quot;/var/lib/rabbitmq/ssl/broker-certs/ 
broker-cert.pem&quot;},
                     	{keyfile,&quot;/var/lib/rabbitmq/ssl/broker-certs/ 
broker-key.pem&quot;},
                     	{verify,verify_none},
                     	{fail_if_no_peer_cert,false}]}
    		]}	
	].

To step in the memory limitations faster, I 've decreased the memory  
watermark threshold to .05 (5%)
This corresponds to 50 MB on the host we are using for this test as  
shown on the rabbit.log file upon startup of broker :

	=INFO REPORT==== 15-Sep-2010::12:36:15 ===
	Limiting to approx 65435 file handles (58889 sockets)

	=INFO REPORT==== 15-Sep-2010::12:36:15 ===
	Memory limit set to 50MB.

Finally the broker status description (rabbitmqctl status)

	[{running_applications,[{rabbit_status,&quot;RabbitMQ Status Page&quot;,&quot;0.01&quot;},
         	                {rabbit,&quot;RabbitMQ&quot;,&quot;2.0.0&quot;},
                 	        {ssl,&quot;Erlang/OTP SSL application&quot;,&quot;3.10.7&quot;},
                         	{public_key,&quot;Public key  
infrastructure&quot;,&quot;0.4&quot;},
                        	 	{mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.4.12&quot;},
                        		{os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.2.4&quot;},
                         	{sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.1.8&quot;},
                         	{rabbit_mochiweb,&quot;RabbitMQ Mochiweb  
Embedding&quot;,&quot;0.01&quot;},
                         	{mochiweb,&quot;MochiMedia Web Server&quot;,&quot;1.3&quot;},
                         	{crypto,&quot;CRYPTO version 1&quot;,&quot;1.6.3&quot;},
                         	{inets,&quot;INETS  CXC 138 49&quot;,&quot;5.2&quot;},
                         	{stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;1.16.4&quot;},
                         	{kernel,&quot;ERTS  CXC 138 10&quot;,&quot;2.13.4&quot;}]},
	 {nodes,[{disc,['<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbit at mystic-buntu</A>']}]},
  	{running_nodes,['<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbit at mystic-buntu</A>']}]

Thanks to the modifications of the MultiCastMain, I've run a 2 phases  
producer / consumer test as described bellow :

	phase 0 : initialization of exchange and queue for the test :
		MultiCastMain -h &lt;host&gt; -p 5672 -s 1000 -n 1 -x 0 -y 1 -e testX -Q  
testQ -K testK -D -z 10
		this launches a single consumer creating the exchange testX and  
queue testQ with durability ON.
		The queue is bound to the exchange using key testK.
		The test is told to end after 10 seconds.
		
	phase 1 - launch a producer alone and watch memory occupation +  
connections status and queue depth (via rabbit_status plugin for  
instance)
		MultiCastMain -h &lt;host&gt; -p 5672 -s 1000 -n 1 -x 1 -y 0 -e testX -Q  
testQ -K testK -D

		This run a producer that will publish 1kb messages to the testX  
exchange with routing key testK.
		These messages will be queued inside testQ.

The producer is blocked after only few seconds running as the memory  
threshold is reached. The queue depth indicated 12 011 messages.
(You can scroll to the end of this mail to see an extract of broker  
log to illustrate the alarm_hanlder notifications.)

What do I mean by &quot;the producer is blocked&quot; :
	- rabbit_status plugin shows the connection in status &quot;bocked&quot;
	- rabbit_status plugin shows that the depth of queue testQ remains  
constant
	- The trace from MultiCastMain does not displays new stats of sending  
rate after a while
	- The last lines in the broker log are :
		=INFO REPORT==== 15-Sep-2010::14:53:44 ===
		vm_memory_high_watermark set. Memory used:53650536 allowed:52556595

		=INFO REPORT==== 15-Sep-2010::14:53:44 ===
     		alarm_handler: {set,{vm_memory_high_watermark,[]}}

 From that point, the producer is blocked without any possible  
recovery. As the flow control is designed in v 2.0.0, I would have  
expected the producer
to be released thanks to sawp of messages to the disk. Anyway, my  
second assumption was that a consumer is needed to release pressure on  
the queue,
so I decided to keep the producer f running, and start phase 2 as  
follow :
	
	phase 2 - launch a consumer alone and watch memory occupation +  
connections status and queue depth (via rabbit_status plugin for  
instance)

		MultiCastMain -h &lt;host&gt; -p 5672 -s 1000 -n 1 -x 0 -y 1 -e testX -Q  
testQ -K testK -D
		This runs a consumer that will get message out the queue testQ.

The messages from testQ are removed quite fast too, but the memory  
occupation does not seem to be impacted at all, as the producer is  
still blocked.
 From the rabbit_status plugin, the status of the connections remains :
	- &quot;blocked&quot; for the producer
	- &quot;blocking&quot; for the consumer

And memory usage is still over the threshold :  memory (used/ 
available) = 53MB / 50MB

The only way I found out to allow memory to fall back bellow the  
threshold is by killing manually the connection of the producer.
Killing the producer process on the client side does not do indeed :

	If  I kill the producer process, the connection seems to disappear  
but the memory remains over the threshold.
	The rabbit_status plugin seem to fail after this because I got a  
strange error report in the broker log. (see the end of this long  
mail !)
	
By closing the connection on the broker side, the memory has (not  
always) fallen below the threshold, back to normal (32 MB / 50 MB).

I think this behaviour is not expected and maybe that could be due to  
a bug somewhere, since it si fully reproductible on my configuration.
The fact that the memory occupation never falls below the threshold  
after message are removed from the queue is particularly strange and
unwilling from my point of view. It think that this simple test can  
points out an issue that would explains the problems that I mentioned  
in the
previous messages, but not sure about it.

I am sorry for this quite long message, but I thought that the more  
details you get, the better.

best regards,

Romary.
	
The following is an extract from the broker log during phase 1

	=INFO REPORT==== 15-Sep-2010::14:53:24 ===
	accepted TCP connection on 0.0.0.0:5672 from 192.168.0.71:1845

	=INFO REPORT==== 15-Sep-2010::14:53:24 ===
	starting TCP connection &lt;0.16120.0&gt; from 192.168.0.71:1845

	=INFO REPORT==== 15-Sep-2010::14:53:42 ===
	vm_memory_high_watermark set. Memory used:52632808 allowed:52556595

	=INFO REPORT==== 15-Sep-2010::14:53:42 ===
    	alarm_handler: {set,{vm_memory_high_watermark,[]}}

	=INFO REPORT==== 15-Sep-2010::14:53:43 ===
	vm_memory_high_watermark clear. Memory used:52355320 allowed:52556595

	=INFO REPORT==== 15-Sep-2010::14:53:43 ===
  	alarm_handler: {clear,vm_memory_high_watermark}

	=INFO REPORT==== 15-Sep-2010::14:53:44 ===
	vm_memory_high_watermark set. Memory used:53650536 allowed:52556595

	=INFO REPORT==== 15-Sep-2010::14:53:44 ===
     	alarm_handler: {set,{vm_memory_high_watermark,[]}}

The following is an extract from the broker log during phase 2
	
	=INFO REPORT==== 15-Sep-2010::15:21:38 ===
	accepted TCP connection on 0.0.0.0:5672 from 192.168.0.71:1880

	=INFO REPORT==== 15-Sep-2010::15:21:38 ===
	starting TCP connection &lt;0.2101.1&gt; from 192.168.0.71:1880

The following is the error report after shutting down the producer  
process (client side)

ERROR REPORT==== 15-Sep-2010::15:37:53 ===
** Generic server rabbit_status_web terminating
** Last message in was get_context
** When Server state == {state,1284557846311,&quot;Wed, 15 Sep 2010  
11:37:26 GMT&quot;,
                                [&lt;&lt;&quot;0.0.0.0:5672 &quot;&gt;&gt;],
                                [[{pid,&lt;&lt;&quot;&lt;0.16120.0&gt;&quot;&gt;&gt;},
                                  {address,&lt;&lt;&quot;192.168.0.58&quot;&gt;&gt;},
                                  {port,5672},
                                  {peer_address,&lt;&lt;&quot;192.168.0.71&quot;&gt;&gt;},
                                  {peer_port,1845},
                                  {recv_oct,12696041},
                                  {recv_cnt,72079},
                                  {send_oct,357},
                                  {send_cnt,5},
                                  {send_pend,0},
                                  {state,&lt;&lt;&quot;blocked&quot;&gt;&gt;},
                                  {channels,1},
                                  {user,&lt;&lt;&quot;guest&quot;&gt;&gt;},
                                  {vhost,&lt;&lt;&quot;/&quot;&gt;&gt;},
                                  {timeout,0},
                                  {frame_max,131072}]],
                                [[{vhost,&lt;&lt;&quot;/&quot;&gt;&gt;},
                                  {name,&lt;&lt;&quot;testQ&quot;&gt;&gt;},
                                  {durable,&lt;&lt;&quot;true&quot;&gt;&gt;},
                                  {auto_delete,&lt;&lt;&quot;false&quot;&gt;&gt;},
                                  {arguments,&lt;&lt;&quot;[]&quot;&gt;&gt;},
                                  {pid,&lt;&lt;&quot;&lt;0.12150.0&gt;&quot;&gt;&gt;},
                                  {messages_ready,0},
                                  {messages_unacknowledged,0},
                                   
{messages_uncommitted,&lt;&lt;&quot;undefined&quot;&gt;&gt;},
                                  {messages,0},
                                  {acks_uncommitted,&lt;&lt;&quot;undefined&quot;&gt;&gt;},
                                  {consumers,0},
                                  {transactions,&lt;&lt;&quot;undefined&quot;&gt;&gt;},
                                  {memory,6171332}]],
                                 
33,65535,55843456,52556595.0,161,1048576}
** Reason for termination ==
** {{badmatch,{error,enotconn}},{gen_server,call, 
[&lt;0.16120.0&gt;,info,infinity]}}

=ERROR REPORT==== 15-Sep-2010::15:37:53 ===
** Generic server &lt;0.16124.0&gt; terminating
** Last message in was {'EXIT',&lt;0.16123.0&gt;,{badmatch,{error,enotconn}}}
** When Server state == {ch,running, 
1,&lt;0.16120.0&gt;,&lt;0.16122.0&gt;,undefined,none,
                             {set,0,16,16,8,80,48,
                                  {[],[],[],[],[],[],[],[],[],[],[],[], 
[],[],
                                   [],[]},
                                  {{[],[],[],[],[],[],[],[],[],[],[], 
[],[],[],
                                    [],[]}}},
                             1,
                             {[],[]},
                             {[],[]},
                             &lt;&lt;&quot;guest&quot;&gt;&gt;,&lt;&lt;&quot;/&quot;&gt;&gt;,&lt;&lt;&gt;&gt;,
                             {dict,0,16,16,8,80,48,
                                   {[],[],[],[],[],[],[],[],[],[],[], 
[],[],[],
                                    [],[]},
                                   {{[],[],[],[],[],[],[],[],[],[],[], 
[],[],[],
                                     [],[]}}},
                             {dict,0,16,16,8,80,48,
                                   {[],[],[],[],[],[],[],[],[],[],[], 
[],[],[],
                                    [],[]},
                                   {{[],[],[],[],[],[],[],[],[],[],[], 
[],[],[],
                                     [],[]}}},
                             &lt;0.16121.0&gt;,
                             {state,none,undefined}}
** Reason for termination ==
** {badmatch,{error,enotconn}}




Le 10 sept. 10 &#224; 15:06, Marek Majkowski a &#233;crit :

&gt;<i> Romary,
</I>&gt;<i>
</I>&gt;<i> First, thank a lot for the feedback. For example the information about
</I>&gt;<i> SSL memory
</I>&gt;<i> usage is indeed very interesting. (if that is a big problem to you,
</I>&gt;<i> you may always
</I>&gt;<i> fall back to the old technique of using stunnel)
</I>&gt;<i>
</I>&gt;<i> The flow control was heavily modified between 1.8.1 and 2.0.0. In  
</I>&gt;<i> summary:
</I>&gt;<i> - 1.8.1 - we have send Channel.flow AMQP message to everyone once
</I>&gt;<i>   rabbit reached memory limit
</I>&gt;<i> - 2.0.0 - once we reach memory limit, the connections from which we  
</I>&gt;<i> hear
</I>&gt;<i>   publishes are stopped temporarily. We stop receiving bytes from  
</I>&gt;<i> tcp sockets.
</I>&gt;<i>   That 'stop' shouldn't take too long, as data should be swapped out  
</I>&gt;<i> to disk
</I>&gt;<i>   and memory pressure will drop pretty quickly.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Wed, Sep 8, 2010 at 11:49, Romary Kremer  
</I>&gt;<i> &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">romary.kremer at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> I've started playing a bit with the latest release 2.0.0 and I m  
</I>&gt;&gt;<i> affraid
</I>&gt;&gt;<i> that it looks like their are some regression or at least some  
</I>&gt;&gt;<i> semantic
</I>&gt;&gt;<i> updates.
</I>&gt;<i>
</I>&gt;<i> It's best if you upgraded both server and client library. Do you  
</I>&gt;<i> have any
</I>&gt;<i> particular problems? A lot was changed in 2.0.0 but we think it's  
</I>&gt;<i> fully
</I>&gt;<i> functional. If you found something that blocks you to migrate, you
</I>&gt;<i> could report a bug.
</I>&gt;<i>
</I>&gt;&gt;<i> It looks like any listener is called back  when the alarm handler  
</I>&gt;&gt;<i> is set or
</I>&gt;&gt;<i> cleared, while the producers are still paused / resumed
</I>&gt;&gt;<i> like their are to be.
</I>&gt;<i>
</I>&gt;<i> Interesting. Maybe we have a race there? Or maybe you're blocking
</I>&gt;<i> the main java client thread? (nothing blocking should be done from
</I>&gt;<i> the main thread)
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> during long running tests, we have encountered strange behaviour  
</I>&gt;&gt;&gt;<i> due to
</I>&gt;&gt;&gt;<i> flow control :
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The queue depth starts to increase linearly for about 2 hours,  
</I>&gt;&gt;&gt;<i> these is
</I>&gt;&gt;&gt;<i> coherent since the message throughput of the single consumer
</I>&gt;&gt;&gt;<i> is not enough to absorb message ingress. Memory occupation grow  
</I>&gt;&gt;&gt;<i> faster as
</I>&gt;&gt;&gt;<i> well, until the memory watermark is reached on the broker side.
</I>&gt;<i>
</I>&gt;<i> Are you sure your consumer is ACK-ing the messages it received?
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> From that point, the producers are indeed paused, as flow control  
</I>&gt;&gt;&gt;<i> request
</I>&gt;&gt;&gt;<i> has been issued by the broker, but the consumer seems to be blocked
</I>&gt;&gt;&gt;<i> as well. The queue level is flatten at its top value until the end  
</I>&gt;&gt;&gt;<i> of the
</I>&gt;&gt;&gt;<i> test, even when memory occupation lowered under the threshold.
</I>&gt;<i>
</I>&gt;<i> That's how 1.8.1 behaves. In 2.0.0 we introduced swapping out big  
</I>&gt;<i> queues
</I>&gt;<i> to disk, so the memory usage shouldn't be dependent on a queue size.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> By registering the FlowListener callback, we have noticed that not  
</I>&gt;&gt;&gt;<i> all of
</I>&gt;&gt;&gt;<i> the producers are notified all the time the alarm handler is set.
</I>&gt;&gt;&gt;<i> Does this mean that the broker applies some heuristic to try not  
</I>&gt;&gt;&gt;<i> to block
</I>&gt;&gt;&gt;<i> every body every time ?
</I>&gt;&gt;&gt;<i> Or does it mean that some of the channels have been somehow  
</I>&gt;&gt;&gt;<i> blacklisted by
</I>&gt;&gt;&gt;<i> the broker ?
</I>&gt;<i>
</I>&gt;<i> No, in 1.8.1 broker should send 'channel.flow' to all the channels.
</I>&gt;<i>
</I>&gt;&gt;&gt;<i> Could anybody explain how the blocking of consumer is assumed to be
</I>&gt;&gt;&gt;<i> implemented ?
</I>&gt;<i>
</I>&gt;<i> The best description is probably here:
</I>&gt;<i>  <A HREF="http://www.rabbitmq.com/extensions.html#memsup">http://www.rabbitmq.com/extensions.html#memsup</A>
</I>&gt;<i>
</I>&gt;<i> But it covers 2.0.0. I'd suggest an upgrade to 2.0.0 and monitoring
</I>&gt;<i> not only queue size but also number of unacknowledged messages
</I>&gt;<i> ('Msg unack' in status plugin). This number should be near zero.
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>  Marek Majkowski
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100915/f26d6487/attachment-0001.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100915/f26d6487/attachment-0001.htm</A>&gt;
</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009079.html">[rabbitmq-discuss] flow control issues
</A></li>
	<LI>Next message: <A HREF="008958.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8940">[ date ]</a>
              <a href="thread.html#8940">[ thread ]</a>
              <a href="subject.html#8940">[ subject ]</a>
              <a href="author.html#8940">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
