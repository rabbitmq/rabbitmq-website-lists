<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] flow control issues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3CFBFC0A10-7AAD-40FB-9C4F-9149E4B0A019%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008963.html">
   <LINK REL="Next"  HREF="008990.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] flow control issues</H1>
    <B>romary.kremer at gmail.com</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3CFBFC0A10-7AAD-40FB-9C4F-9149E4B0A019%40gmail.com%3E"
       TITLE="[rabbitmq-discuss] flow control issues">romary.kremer at gmail.com
       </A><BR>
    <I>Fri Sep 17 15:32:09 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="008963.html">[rabbitmq-discuss] flow control issues
</A></li>
        <LI>Next message: <A HREF="008990.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8973">[ date ]</a>
              <a href="thread.html#8973">[ thread ]</a>
              <a href="subject.html#8973">[ subject ]</a>
              <a href="author.html#8973">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Their are still some point I don't understand quite well with flow  
control.

As Marek told, in version previous to 2.0.0, the broker sends  
Channel.flow AMQP message to everyone once
rabbit reached memory limit. However, I still dont' understand how it  
came to block the production with that version.

In first, I thought that the client application should implement its  
own pause/resume logic, and that FlowListener interface would be the
way to do that. I realized only later that the producer was paused as  
well without the use of FlowListener, for instance using the
MultiCastMain sample in Java client 1.7.2.

Can you give us hints about how the production was indeed paused,  
other by stopping reading from the socket ?
Does the broker shut the connection or only the channel if a content- 
bearing message is sent after the flow.control ?

What is the meaning of status &quot;Blocked&quot; and &quot;Blocking&quot; that we can  
gather by listing connections ! I often noticed that
the connection of producer in status &quot;blocked&quot; lead the connection of  
the consumer to be &quot;Blocking&quot;.

Sharing the same connection for producer and consumer, by the use of  
Channel may not be safe, that is very sad !

Best regards,

Romary.

Le 16 sept. 10 &#224; 14:49, Marek Majkowski a &#233;crit :

&gt;<i> On Wed, Sep 15, 2010 at 19:11, <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">romary.kremer at gmail.com</A>
</I>&gt;<i> &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">romary.kremer at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> Yes. You will never hear &quot;FlowListener.handleFlow()&quot; and it may be  
</I>&gt;&gt;<i> possible
</I>&gt;&gt;<i> for
</I>&gt;&gt;<i> channel.publish to block (though I would need to consult the sources
</I>&gt;&gt;<i> to be sure).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It seems to me that FlowListener interface is likely to be  
</I>&gt;&gt;<i> deprecated so,
</I>&gt;&gt;<i> does'nt it ?
</I>&gt;<i>
</I>&gt;<i> It's more complex than that, but yes, you won't hear anything on  
</I>&gt;<i> that interface.
</I>&gt;<i>
</I>&gt;&gt;<i> Does not really matter for us anyway, cause we where on wrong idea  
</I>&gt;&gt;<i> using
</I>&gt;&gt;<i> that.
</I>&gt;&gt;<i> Does this new implementation keep the broker on track for  
</I>&gt;&gt;<i> compliance with
</I>&gt;&gt;<i> specification then ?
</I>&gt;<i>
</I>&gt;<i> Yes, the spec doesn't force us to send channel.flow. We implemented  
</I>&gt;<i> that
</I>&gt;<i> for a while but realized that it doesn't solve our problems.
</I>&gt;<i>
</I>&gt;&gt;<i> This would be acceptable for our needs, only if we can somehow  
</I>&gt;&gt;<i> guarantee
</I>&gt;&gt;<i> that's an upper boundary !
</I>&gt;<i>
</I>&gt;<i> Optimistically, the upper bouadary is not more than your memory usage
</I>&gt;<i> divided by the disk throughput.
</I>&gt;<i>
</I>&gt;&gt;<i> But it is possible to create a very pessimistic environment in  
</I>&gt;&gt;<i> which the
</I>&gt;&gt;<i> memory usage will not drop - and the connection could be stuck for  
</I>&gt;&gt;<i> a long
</I>&gt;&gt;<i> time.
</I>&gt;&gt;<i> (though it's pretty unlikely).
</I>&gt;<i>
</I>&gt;&gt;<i> ... Not that much unlikely, considering my little playing with the
</I>&gt;&gt;<i> MultiCastMain sample (see my previous reply about it for details).
</I>&gt;&gt;<i> I get 100 % times blocked connection.
</I>&gt;&gt;<i> What would be, based on your knowledge and your intuition, &quot;a very
</I>&gt;&gt;<i> pessimistic environment in which the memory usage will not drop&quot; ?
</I>&gt;&gt;<i> I think that the experimentation I've done on the MultiCastMain is  
</I>&gt;&gt;<i> maybe a
</I>&gt;&gt;<i> beginning of an answer for that question, although I would
</I>&gt;&gt;<i> never have considered that a single producer could have such power  
</I>&gt;&gt;<i> to flood
</I>&gt;&gt;<i> the broker.
</I>&gt;<i>
</I>&gt;<i> Okay. The memory can stay high due to a lot of reasons. If your  
</I>&gt;<i> metadata
</I>&gt;<i> that rabbit never releases is using more memory than threshold -
</I>&gt;<i> rabbit will just get stuck.
</I>&gt;<i>
</I>&gt;<i> Next thing. remember, we don't control how erlang eats memory - and it
</I>&gt;<i> has pretty
</I>&gt;<i> complex GC and memory allocation mechanisms.
</I>&gt;<i>
</I>&gt;<i> If you think that you have enough memory for all the connections,
</I>&gt;<i> queues, exchanges and bindings. And some memory for the messages.
</I>&gt;<i> And you still hit the limit when you get stuck - feel free to tune
</I>&gt;<i> Erlang GC internals:
</I>&gt;<i>  <A HREF="http://www.erlang.org/doc/man/erts_alloc.html">http://www.erlang.org/doc/man/erts_alloc.html</A>
</I>&gt;<i>
</I>&gt;&gt;<i> Weren't Channel design for that ? In our environment, we have  
</I>&gt;&gt;<i> (naively ?)
</I>&gt;&gt;<i> considered the use of Channel to
</I>&gt;&gt;<i> separate the message production from the consumption.
</I>&gt;&gt;<i> Since we are targeting 10 000 peers doing both production and  
</I>&gt;&gt;<i> consumption,
</I>&gt;&gt;<i> the fact of multiplying the number of
</I>&gt;&gt;<i> connections by 2 is not negligible at all, considering scalability.
</I>&gt;&gt;<i> Moreover, as I reported later on, we use SSL to authenticate the  
</I>&gt;&gt;<i> broker, and
</I>&gt;&gt;<i> we are still unclear about memory leaks
</I>&gt;&gt;<i> induce by SSL connections. Doubling the number of connections will  
</I>&gt;&gt;<i> not be
</I>&gt;&gt;<i> negligible at all considering memory occupation either.
</I>&gt;&gt;<i> In conclusion, we are not likely to implement our peers using 2  
</I>&gt;&gt;<i> connections
</I>&gt;&gt;<i> for the same broker.
</I>&gt;&gt;<i> What would you recommend to us then ? And could you give us a better
</I>&gt;&gt;<i> understanding on the use case of channels ?
</I>&gt;<i>
</I>&gt;<i> Yes, channels were designed exactly for that. On the other hand, AMQP
</I>&gt;<i> has few pretty serious issues. For example when you open channel
</I>&gt;<i> you're free to publish a message. And broker can't 'refuse' accepting
</I>&gt;<i> a message. Channel.flow can be sent from the broker to the client
</I>&gt;<i> but *after* channel is opened. So there is a window in which
</I>&gt;<i> you just can publish (after channel.open before channel.flow).  
</I>&gt;<i> Sorry, there
</I>&gt;<i> just isn't other way of forbidding publishes than by stopping the  
</I>&gt;<i> whole
</I>&gt;<i> connection. I also don't like it, but it's the only way.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> Marek
</I>
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008963.html">[rabbitmq-discuss] flow control issues
</A></li>
	<LI>Next message: <A HREF="008990.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8973">[ date ]</a>
              <a href="thread.html#8973">[ thread ]</a>
              <a href="subject.html#8973">[ subject ]</a>
              <a href="author.html#8973">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
