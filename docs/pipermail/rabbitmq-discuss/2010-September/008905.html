<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] flow control issues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3C66299676-639B-473C-92C5-62B60836DE35%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008887.html">
   <LINK REL="Next"  HREF="008942.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] flow control issues</H1>
    <B>romary.kremer at gmail.com</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20flow%20control%20issues&In-Reply-To=%3C66299676-639B-473C-92C5-62B60836DE35%40gmail.com%3E"
       TITLE="[rabbitmq-discuss] flow control issues">romary.kremer at gmail.com
       </A><BR>
    <I>Tue Sep 14 09:07:20 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="008887.html">[rabbitmq-discuss] flow control issues
</A></li>
        <LI>Next message: <A HREF="008942.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8905">[ date ]</a>
              <a href="thread.html#8905">[ thread ]</a>
              <a href="subject.html#8905">[ subject ]</a>
              <a href="author.html#8905">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks Marek for your reply.

Le 10 sept. 10 &#224; 15:06, Marek Majkowski a &#233;crit :

&gt;<i> Romary,
</I>&gt;<i>
</I>&gt;<i> First, thank a lot for the feedback. For example the information about
</I>&gt;<i> SSL memory
</I>&gt;<i> usage is indeed very interesting. (if that is a big problem to you,
</I>&gt;<i> you may always
</I>&gt;<i> fall back to the old technique of using stunnel)
</I>
Stunnel is not considered for now, We would rather ear your opinion  
and knowledge
of potential memory leak due to the use SSL (maybe from the Erlang  
stack itself).
It seems that memory is still growing even when the broker is running  
no activity
but connections. We ran a test in which we just open 10 000  
connections and do
noting for 2 hours but observing the memory occupation on the broker  
side to confirm it.

&gt;<i> The flow control was heavily modified between 1.8.1 and 2.0.0. In  
</I>&gt;<i> summary:
</I>&gt;<i> - 1.8.1 - we have send Channel.flow AMQP message to everyone once
</I>&gt;<i>   rabbit reached memory limit
</I>&gt;<i> - 2.0.0 - once we reach memory limit, the connections from which we  
</I>&gt;<i> hear
</I>&gt;<i>   publishes are stopped temporarily. We stop receiving bytes from  
</I>&gt;<i> tcp sockets.
</I>&gt;<i>   That 'stop' shouldn't take too long, as data should be swapped out  
</I>&gt;<i> to disk
</I>&gt;<i>   and memory pressure will drop pretty quickly.
</I>
Do you mean that in 2.0.0 the Channel.flow AMQP message is no longer  
sent to
the producer that are stopped temporarily ? So that would explain why
	1) Channel.publish() can be blocking on the client side when the  
broker stop
	reading from the socket !
	
	2) FlowListener.handleFlow() is no longer invoked on the registered  
listener when
	the alarm handler is set or cleared
Are my deduction wright ?

Do you have any figures to quantify &quot;should, not take too long&quot; ? Are  
their some
test reports available about that major evolution ?

&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Wed, Sep 8, 2010 at 11:49, Romary Kremer  
</I>&gt;<i> &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">romary.kremer at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> I've started playing a bit with the latest release 2.0.0 and I m  
</I>&gt;&gt;<i> affraid
</I>&gt;&gt;<i> that it looks like their are some regression or at least some  
</I>&gt;&gt;<i> semantic
</I>&gt;&gt;<i> updates.
</I>&gt;<i>
</I>&gt;<i> It's best if you upgraded both server and client library. Do you  
</I>&gt;<i> have any
</I>&gt;<i> particular problems? A lot was changed in 2.0.0 but we think it's  
</I>&gt;<i> fully
</I>&gt;<i> functional. If you found something that blocks you to migrate, you
</I>&gt;<i> could report a bug.
</I>
Sorry If I wasn't clear on the previous post ,we are already in 2.0.0  
for both broker and
client library.

&gt;<i>
</I>&gt;&gt;<i> It looks like any listener is called back  when the alarm handler  
</I>&gt;&gt;<i> is set or
</I>&gt;&gt;<i> cleared, while the producers are still paused / resumed
</I>&gt;&gt;<i> like their are to be.
</I>&gt;<i>
</I>&gt;<i> Interesting. Maybe we have a race there? Or maybe you're blocking
</I>&gt;<i> the main java client thread? (nothing blocking should be done from
</I>&gt;<i> the main thread)
</I>
I am quite sure I am not blocking the main thread, neither the  
Connection Thread. All
the message-related logic is in a particular thread (Some kind of  
ProducerGroup
pool of threads actually).
Consumer call back are running within the Connection thread if I refer  
to the Javadoc !

The same code using the library version 1.8.1, The callback where  
invoked when
alarm handler is set or cleared anyway.

&gt;<i>
</I>&gt;&gt;&gt;<i> during long running tests, we have encountered strange behaviour  
</I>&gt;&gt;&gt;<i> due to
</I>&gt;&gt;&gt;<i> flow control :
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The queue depth starts to increase linearly for about 2 hours,  
</I>&gt;&gt;&gt;<i> these is
</I>&gt;&gt;&gt;<i> coherent since the message throughput of the single consumer
</I>&gt;&gt;&gt;<i> is not enough to absorb message ingress. Memory occupation grow  
</I>&gt;&gt;&gt;<i> faster as
</I>&gt;&gt;&gt;<i> well, until the memory watermark is reached on the broker side.
</I>&gt;<i>
</I>&gt;<i> Are you sure your consumer is ACK-ing the messages it received?
</I>
The Consumer call back does ACK messages upon reception, one at a time  
(multiple == false).
Does the basic.ack() method is eligible to be blocked as well as  
publish() upon flow control ?

&gt;<i>
</I>&gt;&gt;&gt;<i> From that point, the producers are indeed paused, as flow control  
</I>&gt;&gt;&gt;<i> request
</I>&gt;&gt;&gt;<i> has been issued by the broker, but the consumer seems to be blocked
</I>&gt;&gt;&gt;<i> as well. The queue level is flatten at its top value until the end  
</I>&gt;&gt;&gt;<i> of the
</I>&gt;&gt;&gt;<i> test, even when memory occupation lowered under the threshold.
</I>&gt;<i>
</I>&gt;<i> That's how 1.8.1 behaves. In 2.0.0 we introduced swapping out big  
</I>&gt;<i> queues
</I>&gt;<i> to disk, so the memory usage shouldn't be dependent on a queue size.
</I>
Good new, because we had identified 2 scenarios in wich memory-based  
channel flow
was triggered :

	- the use of SSL
	- the use of larger message (4kb, same ingress)
Now I hope that the message size will not be that much determinant for  
flow controll,as soon
as consumers are able to handle these message regularly.

&gt;<i>
</I>&gt;&gt;&gt;<i> By registering the FlowListener callback, we have noticed that not  
</I>&gt;&gt;&gt;<i> all of
</I>&gt;&gt;&gt;<i> the producers are notified all the time the alarm handler is set.
</I>&gt;&gt;&gt;<i> Does this mean that the broker applies some heuristic to try not  
</I>&gt;&gt;&gt;<i> to block
</I>&gt;&gt;&gt;<i> every body every time ?
</I>&gt;&gt;&gt;<i> Or does it mean that some of the channels have been somehow  
</I>&gt;&gt;&gt;<i> blacklisted by
</I>&gt;&gt;&gt;<i> the broker ?
</I>&gt;<i>
</I>&gt;<i> No, in 1.8.1 broker should send 'channel.flow' to all the channels.
</I>Strange so, their must be some thing very weird.
&gt;<i>
</I>&gt;&gt;&gt;<i> Could anybody explain how the blocking of consumer is assumed to be
</I>&gt;&gt;&gt;<i> implemented ?
</I>&gt;<i>
</I>&gt;<i> The best description is probably here:
</I>&gt;<i>  <A HREF="http://www.rabbitmq.com/extensions.html#memsup">http://www.rabbitmq.com/extensions.html#memsup</A>
</I>&gt;<i>
</I>&gt;<i> But it covers 2.0.0. I'd suggest an upgrade to 2.0.0 and monitoring
</I>&gt;<i> not only queue size but also number of unacknowledged messages
</I>&gt;<i> ('Msg unack' in status plugin). This number should be near zero.
</I>&gt;<i>
</I>We are already with 2.0.0.
Where can I find some doc about the Status plugin anyway ?

Cheers, Romary.
&gt;<i> Cheers,
</I>&gt;<i>  Marek Majkowski
</I>
</PRE>















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008887.html">[rabbitmq-discuss] flow control issues
</A></li>
	<LI>Next message: <A HREF="008942.html">[rabbitmq-discuss] flow control issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8905">[ date ]</a>
              <a href="thread.html#8905">[ thread ]</a>
              <a href="subject.html#8905">[ subject ]</a>
              <a href="author.html#8905">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
