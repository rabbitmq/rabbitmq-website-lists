<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20auto-delete%20queue/exchanges%20and%20cluster%0A%09synchronization&In-Reply-To=%3CCACU-xnop25AC6RD0q66%3Dmj7sO%2BG3wjxC%3DBGqC2Ez9GSUbXJfCg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="035929.html">
   <LINK REL="Next"  HREF="036038.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization</H1>
    <B>mouad ben</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20auto-delete%20queue/exchanges%20and%20cluster%0A%09synchronization&In-Reply-To=%3CCACU-xnop25AC6RD0q66%3Dmj7sO%2BG3wjxC%3DBGqC2Ez9GSUbXJfCg%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization">mouadino at gmail.com
       </A><BR>
    <I>Fri May 16 10:42:57 BST 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="035929.html">[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization
</A></li>
        <LI>Next message: <A HREF="036038.html">[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36031">[ date ]</a>
              <a href="thread.html#36031">[ thread ]</a>
              <a href="subject.html#36031">[ subject ]</a>
              <a href="author.html#36031">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Tue, May 13, 2014 at 3:59 PM, Simon MacMullen &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">simon at rabbitmq.com</A>&gt; wrote:

&gt;<i> On 13/05/2014 14:25, mouad ben wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> RabbitMQ cluster (RabbitMQ 3.1.5,Erlang R14B04)
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> (Queues are also created with x-ha-policy set to all).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> As an aside, note that x-ha-policy only controls queue mirroring in 2.x!
</I>&gt;<i> In 3.x it does nothing at all. <A HREF="Seehttp://www.rabbitmq.com/ha.html">Seehttp://www.rabbitmq.com/ha.html</A> and
</I>&gt;<i> <A HREF="http://www.rabbitmq.com/blog/2012/11/19/breaking-things-with-rabbitmq-3-0/">http://www.rabbitmq.com/blog/2012/11/19/breaking-things-with-rabbitmq-3-0/</A>
</I>

Ohh thanks for the info, shamelessly i didn't knew that.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Of course, autodelete RPC queues quite possibly do not need to be HA.
</I>

Well apparently my &quot;chaos monkey&quot; wasn't able to reproduce this problem
when mirroring queue was enabled !? I am actually still not sure why is
this the case !? I am probably missing something obvious !


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> But in the same time if a node of the cluster go down the Queue consumer
</I>&gt;&gt;<i> that are created in this node will be deleted, the Queues with
</I>&gt;&gt;<i> auto-delete will end up being deleted too and the same thing with the
</I>&gt;&gt;<i> exchanges bounded to them which also have auto-delete, all of this will
</I>&gt;&gt;<i> be done **eventually** in all RabbitMQ nodes that are still up.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So in detail from neutron side we have:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> N1. Connect to node 2.
</I>&gt;&gt;<i> N2. Create Exchange X.
</I>&gt;&gt;<i> N3. Create Queue Q.
</I>&gt;&gt;<i> N4. Create Binding from Q to X.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  From cluster side we have:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> R1. Delete consumer.
</I>&gt;&gt;<i> R2. Delete Queue Q (Binding is deleted explicitly).
</I>&gt;&gt;<i> R3. Delete Exchange X.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This actually can lead to a race condition that will result of N4
</I>&gt;&gt;<i> failing with error stating that exchange doesn't exist because
</I>&gt;&gt;<i> apparently R3 action was executed after N2 and before N4.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That makes sense. But note that R2 and R3 are an atomic event.
</I>

Just to be sure, you don't mean that (R2+R3) group is an atomic event !?


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> A workaround that we have created is to retry creation if it fail as you
</I>&gt;&gt;<i> can see in the bug report in OpenStack side
</I>&gt;&gt;<i> <A HREF="https://bugs.launchpad.net/neutron/+bug/1318721.">https://bugs.launchpad.net/neutron/+bug/1318721.</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> And that would work as a workaround.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> But i think that this also a problem in RabbitMQ side, basically i
</I>&gt;&gt;<i> believe a more sane behavior will be for RabbitMQ to ignore **old**
</I>&gt;&gt;<i> delete if a newest exchange's declare was sent, instead of threading
</I>&gt;&gt;<i> this later as a no op.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Hmm. Newer than what? The queue delete R2 is not necessarily older than
</I>&gt;<i> then most recent exchange declare N2 in this scenario, is it? In fact,
</I>&gt;<i> isn't R2 always newer than N2?
</I>&gt;<i>
</I>
Not necessarily, I don't see why there should be any order between
unrelated operation from client versus cluster side, when the connection is
broken this will raise the sequence of events in both sides but who is
faster ! in the &quot;happy path&quot; the order will be R1 -&gt; R2 -&gt; R3 -&gt; N1 -&gt; N2
-&gt; N3 -&gt; N4, but in reality all orders are possible e.g. R1 -&gt; N1 -&gt; N2 -&gt;
R2 -&gt; N3 -&gt; R3 -&gt; N4, right ? BTW when i say order, i am taking as
reference the RabbitMQ cluster b/c operation are atomics right ?


&gt;<i>
</I>&gt;<i> (Also, doing this would require timestamps in queues, exchanges and
</I>&gt;<i> bindings, updated cluster-wide every time they are re-declared. That would
</I>&gt;<i> be a big problem for performance.)
</I>

Agree, timestamp are surely not that easy to manage in a distributed
environment b/c they require the clocks in the different nodes to be in
sync, vector clock may be another solution but well i am not well versed
enough in distributed system to give any real feedback on this, that was
just a dummy idea from my part anyway :)


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Does my analyze above make sense !?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> So I'm not sure it does.
</I>&gt;<i>
</I>&gt;<i> When reading also the AMQP 0-9-1 reference
</I>&gt;&gt;<i> (<A HREF="https://www.rabbitmq.com/amqp-0-9-1-reference.html">https://www.rabbitmq.com/amqp-0-9-1-reference.html</A>) i found that:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   * The server SHOULD allow for a reasonable delay between the point
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     when it determines that an exchange is not being used (or no longer
</I>&gt;&gt;<i>     used), and the point when it deletes the exchange. At the least it
</I>&gt;&gt;<i>     must allow a client to create an exchange and then bind a queue to
</I>&gt;&gt;<i>     it, with a small but non-zero delay between these two actions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Does my finding contradict this ? And how big is the delay ?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It does; there is no delay in RabbitMQ.
</I>&gt;<i>
</I>&gt;<i> Note that if there were a delay then you'd still have exactly the same
</I>&gt;<i> race anyway, it wouldn't solve anything.
</I>&gt;<i>
</I>&gt;<i> You can get a similar delay for the queue deletion, by using x-expires
</I>&gt;<i> instead of auto-delete. But once the queue goes, the bindings and exchange
</I>&gt;<i> all go atomically.
</I>&gt;<i>
</I>&gt;<i> So how to solve your problem? It sounds like each thing that can receive
</I>&gt;<i> RPC replies declares an exchange, queue and binding for that purpiose, with
</I>&gt;<i> the exchange and queue not linked in to anything else. Is that correct?
</I>&gt;<i>
</I>
Yes that's the main idea of how OpenStack implement RPC.


&gt;<i>
</I>&gt;<i> If that is so, why not only declare a queue, and have the RPC server
</I>&gt;<i> publish to that queue directly? The queue could still be auto-delete, and
</I>&gt;<i> everything would be simpler. Or is there some subtlety I'm not getting?
</I>

You mean by publishing to the &quot;nameless exchanger&quot;, that sounds much
easier, but i am not why that is not the case i need probably to ask in the
OpenStack mailing list first.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i> One last thing is the auto-delete deprecation from
</I>&gt;&gt;<i> <A HREF="http://www.rabbitmq.com/amqp-0-9-1-errata.html,">http://www.rabbitmq.com/amqp-0-9-1-errata.html,</A> point 25:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The 'auto-delete' flag on 'exchange.declare' got deprecated in 0-9-1.
</I>&gt;&gt;<i> Auto-delete exchanges are actually quite useful, so this flag should be
</I>&gt;&gt;<i> restored.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Does this mean the auto-delete flag will not be removed from RabbitMQ or
</I>&gt;&gt;<i> what ?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It means we will continue to support it, yes.
</I>&gt;<i>
</I>&gt;<i> Cheers, Simon
</I>&gt;<i>
</I>
Thanks for the quick answer too, and sorry for answering you directly
instead of answering to the mailing list, dummy mistake from my part :(


On Tue, May 13, 2014 at 3:59 PM, Simon MacMullen &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">simon at rabbitmq.com</A>&gt; wrote:

&gt;<i> On 13/05/2014 14:25, mouad ben wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> RabbitMQ cluster (RabbitMQ 3.1.5,Erlang R14B04)
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  (Queues are also created with x-ha-policy set to all).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> As an aside, note that x-ha-policy only controls queue mirroring in 2.x!
</I>&gt;<i> In 3.x it does nothing at all. See <A HREF="http://www.rabbitmq.com/ha.html">http://www.rabbitmq.com/ha.html</A> and
</I>&gt;<i> <A HREF="http://www.rabbitmq.com/blog/2012/11/19/breaking-things-with-rabbitmq-3-0/">http://www.rabbitmq.com/blog/2012/11/19/breaking-things-with-rabbitmq-3-0/</A>
</I>&gt;<i>
</I>&gt;<i> Of course, autodelete RPC queues quite possibly do not need to be HA.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  But in the same time if a node of the cluster go down the Queue consumer
</I>&gt;&gt;<i> that are created in this node will be deleted, the Queues with
</I>&gt;&gt;<i> auto-delete will end up being deleted too and the same thing with the
</I>&gt;&gt;<i> exchanges bounded to them which also have auto-delete, all of this will
</I>&gt;&gt;<i> be done **eventually** in all RabbitMQ nodes that are still up.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So in detail from neutron side we have:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> N1. Connect to node 2.
</I>&gt;&gt;<i> N2. Create Exchange X.
</I>&gt;&gt;<i> N3. Create Queue Q.
</I>&gt;&gt;<i> N4. Create Binding from Q to X.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  From cluster side we have:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> R1. Delete consumer.
</I>&gt;&gt;<i> R2. Delete Queue Q (Binding is deleted explicitly).
</I>&gt;&gt;<i> R3. Delete Exchange X.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This actually can lead to a race condition that will result of N4
</I>&gt;&gt;<i> failing with error stating that exchange doesn't exist because
</I>&gt;&gt;<i> apparently R3 action was executed after N2 and before N4.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That makes sense. But note that R2 and R3 are an atomic event.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  A workaround that we have created is to retry creation if it fail as you
</I>&gt;&gt;<i> can see in the bug report in OpenStack side
</I>&gt;&gt;<i> <A HREF="https://bugs.launchpad.net/neutron/+bug/1318721.">https://bugs.launchpad.net/neutron/+bug/1318721.</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> And that would work as a workaround.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  But i think that this also a problem in RabbitMQ side, basically i
</I>&gt;&gt;<i> believe a more sane behavior will be for RabbitMQ to ignore **old**
</I>&gt;&gt;<i> delete if a newest exchange's declare was sent, instead of threading
</I>&gt;&gt;<i> this later as a no op.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Hmm. Newer than what? The queue delete R2 is not necessarily older than
</I>&gt;<i> then most recent exchange declare N2 in this scenario, is it? In fact,
</I>&gt;<i> isn't R2 always newer than N2?
</I>&gt;<i>
</I>&gt;<i> (Also, doing this would require timestamps in queues, exchanges and
</I>&gt;<i> bindings, updated cluster-wide every time they are re-declared. That would
</I>&gt;<i> be a big problem for performance.)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  Does my analyze above make sense !?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> So I'm not sure it does.
</I>&gt;<i>
</I>&gt;<i>  When reading also the AMQP 0-9-1 reference
</I>&gt;&gt;<i> (<A HREF="https://www.rabbitmq.com/amqp-0-9-1-reference.html">https://www.rabbitmq.com/amqp-0-9-1-reference.html</A>) i found that:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   * The server SHOULD allow for a reasonable delay between the point
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     when it determines that an exchange is not being used (or no longer
</I>&gt;&gt;<i>     used), and the point when it deletes the exchange. At the least it
</I>&gt;&gt;<i>     must allow a client to create an exchange and then bind a queue to
</I>&gt;&gt;<i>     it, with a small but non-zero delay between these two actions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Does my finding contradict this ? And how big is the delay ?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It does; there is no delay in RabbitMQ.
</I>&gt;<i>
</I>&gt;<i> Note that if there were a delay then you'd still have exactly the same
</I>&gt;<i> race anyway, it wouldn't solve anything.
</I>&gt;<i>
</I>&gt;<i> You can get a similar delay for the queue deletion, by using x-expires
</I>&gt;<i> instead of auto-delete. But once the queue goes, the bindings and exchange
</I>&gt;<i> all go atomically.
</I>&gt;<i>
</I>&gt;<i> So how to solve your problem? It sounds like each thing that can receive
</I>&gt;<i> RPC replies declares an exchange, queue and binding for that purpiose, with
</I>&gt;<i> the exchange and queue not linked in to anything else. Is that correct?
</I>&gt;<i>
</I>&gt;<i> If that is so, why not only declare a queue, and have the RPC server
</I>&gt;<i> publish to that queue directly? The queue could still be auto-delete, and
</I>&gt;<i> everything would be simpler. Or is there some subtlety I'm not getting?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  One last thing is the auto-delete deprecation from
</I>&gt;&gt;<i> <A HREF="http://www.rabbitmq.com/amqp-0-9-1-errata.html,">http://www.rabbitmq.com/amqp-0-9-1-errata.html,</A> point 25:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The 'auto-delete' flag on 'exchange.declare' got deprecated in 0-9-1.
</I>&gt;&gt;<i> Auto-delete exchanges are actually quite useful, so this flag should be
</I>&gt;&gt;<i> restored.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Does this mean the auto-delete flag will not be removed from RabbitMQ or
</I>&gt;&gt;<i> what ?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It means we will continue to support it, yes.
</I>&gt;<i>
</I>&gt;<i> Cheers, Simon
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20140516/8f3c0458/attachment.html">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20140516/8f3c0458/attachment.html</A>&gt;
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="035929.html">[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization
</A></li>
	<LI>Next message: <A HREF="036038.html">[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36031">[ date ]</a>
              <a href="thread.html#36031">[ thread ]</a>
              <a href="subject.html#36031">[ subject ]</a>
              <a href="author.html#36031">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
