<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20auto-delete%20queue/exchanges%20and%20cluster%0A%09synchronization&In-Reply-To=%3C5375EE84.7040606%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="036031.html">
   <LINK REL="Next"  HREF="035924.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization</H1>
    <B>Simon MacMullen</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20auto-delete%20queue/exchanges%20and%20cluster%0A%09synchronization&In-Reply-To=%3C5375EE84.7040606%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization">simon at rabbitmq.com
       </A><BR>
    <I>Fri May 16 11:55:00 BST 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="036031.html">[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization
</A></li>
        <LI>Next message: <A HREF="035924.html">[rabbitmq-discuss] [rabbitmq_c] Infinite wait in	login_with_properties function
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36038">[ date ]</a>
              <a href="thread.html#36038">[ thread ]</a>
              <a href="subject.html#36038">[ subject ]</a>
              <a href="author.html#36038">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 16/05/14 10:42, mouad ben wrote:
&gt;<i> On Tue, May 13, 2014 at 3:59 PM, Simon MacMullen &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">simon at rabbitmq.com</A>
</I>&gt;<i>     Of course, autodelete RPC queues quite possibly do not need to be HA.
</I>&gt;<i>
</I>&gt;<i> Well apparently my &quot;chaos monkey&quot; wasn't able to reproduce this problem
</I>&gt;<i> when mirroring queue was enabled !? I am actually still not sure why is
</I>&gt;<i> this the case !? I am probably missing something obvious !
</I>
Possibly. Of course since this is a race anyway, the timings might have 
just changed. Especially since deleting an HA queue is quite a bit 
slower than deleting a non-HA one for obvious reasons.

&gt;<i>         But in the same time if a node of the cluster go down the Queue
</I>&gt;<i>         consumer
</I>&gt;<i>         that are created in this node will be deleted, the Queues with
</I>&gt;<i>         auto-delete will end up being deleted too and the same thing
</I>&gt;<i>         with the
</I>&gt;<i>         exchanges bounded to them which also have auto-delete, all of
</I>&gt;<i>         this will
</I>&gt;<i>         be done **eventually** in all RabbitMQ nodes that are still up.
</I>&gt;<i>
</I>&gt;<i>         So in detail from neutron side we have:
</I>&gt;<i>
</I>&gt;<i>         N1. Connect to node 2.
</I>&gt;<i>         N2. Create Exchange X.
</I>&gt;<i>         N3. Create Queue Q.
</I>&gt;<i>         N4. Create Binding from Q to X.
</I>&gt;<i>
</I>&gt;<i>           From cluster side we have:
</I>&gt;<i>
</I>&gt;<i>         R1. Delete consumer.
</I>&gt;<i>         R2. Delete Queue Q (Binding is deleted explicitly).
</I>&gt;<i>         R3. Delete Exchange X.
</I>&gt;<i>
</I>&gt;<i>         This actually can lead to a race condition that will result of N4
</I>&gt;<i>         failing with error stating that exchange doesn't exist because
</I>&gt;<i>         apparently R3 action was executed after N2 and before N4.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     That makes sense. But note that R2 and R3 are an atomic event.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Just to be sure, you don't mean that (R2+R3) group is an atomic event !?
</I>
I'm assuming here that &quot;Binding is deleted explicitly&quot; is a typo for 
&quot;Binding is deleted implicitly&quot; - that is, you explicitly delete the 
queue, which implicitly deletes the binding and thus auto-deletes the 
exchange. If so, then yes, that's atomic.

Or does your code explicitly delete the queue and the exchange? If so, 
the exchange.delete AMQP method will be ignored since deleting a 
non-existent exchange is now a no-op.

Sorry, I probably didn't explain that very clearly the first time round. 
Hope it's clearer now.

&gt;<i>         But i think that this also a problem in RabbitMQ side, basically i
</I>&gt;<i>         believe a more sane behavior will be for RabbitMQ to ignore **old**
</I>&gt;<i>         delete if a newest exchange's declare was sent, instead of threading
</I>&gt;<i>         this later as a no op.
</I>&gt;<i>
</I>&gt;<i>     Hmm. Newer than what? The queue delete R2 is not necessarily older
</I>&gt;<i>     than then most recent exchange declare N2 in this scenario, is it?
</I>&gt;<i>     In fact, isn't R2 always newer than N2?
</I>&gt;<i>
</I>&gt;<i> Not necessarily, I don't see why there should be any order between
</I>&gt;<i> unrelated operation from client versus cluster side, when the connection
</I>&gt;<i> is broken this will raise the sequence of events in both sides but who
</I>&gt;<i> is faster ! in the &quot;happy path&quot; the order will be R1 -&gt; R2 -&gt; R3 -&gt; N1
</I>&gt;<i> -&gt; N2 -&gt; N3 -&gt; N4, but in reality all orders are possible e.g. R1 -&gt; N1
</I>&gt;<i> -&gt; N2 -&gt; R2 -&gt; N3 -&gt; R3 -&gt; N4, right ?
</I>
Sorry, again I was unclear. When I said &quot;in this scenario&quot; I meant &quot;in 
the scenario where the breakage that you're observing occurs&quot;. Yes, 
other interleavings are of course possible :-)

&gt;<i> BTW when i say order, i am taking
</I>&gt;<i> as reference the RabbitMQ cluster b/c operation are atomics right ?
</I>
Yes.

&gt;<i>     So how to solve your problem? It sounds like each thing that can
</I>&gt;<i>     receive RPC replies declares an exchange, queue and binding for that
</I>&gt;<i>     purpiose, with the exchange and queue not linked in to anything
</I>&gt;<i>     else. Is that correct?
</I>&gt;<i>
</I>&gt;<i> Yes that's the main idea of how OpenStack implement RPC.
</I>&gt;<i>
</I>&gt;<i>     If that is so, why not only declare a queue, and have the RPC server
</I>&gt;<i>     publish to that queue directly? The queue could still be
</I>&gt;<i>     auto-delete, and everything would be simpler. Or is there some
</I>&gt;<i>     subtlety I'm not getting?
</I>&gt;<i>
</I>&gt;<i> You mean by publishing to the &quot;nameless exchanger&quot;, that sounds much
</I>&gt;<i> easier, but i am not why that is not the case i need probably to ask in
</I>&gt;<i> the OpenStack mailing list first.
</I>
Yes, that was what I meant.

Cheers, Simon

-- 
Simon MacMullen
RabbitMQ, Pivotal
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="036031.html">[rabbitmq-discuss] auto-delete queue/exchanges and cluster	synchronization
</A></li>
	<LI>Next message: <A HREF="035924.html">[rabbitmq-discuss] [rabbitmq_c] Infinite wait in	login_with_properties function
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36038">[ date ]</a>
              <a href="thread.html#36038">[ thread ]</a>
              <a href="subject.html#36038">[ subject ]</a>
              <a href="author.html#36038">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
