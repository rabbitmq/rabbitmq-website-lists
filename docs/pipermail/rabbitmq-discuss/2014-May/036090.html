<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] RabbitMQ and batch processing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20RabbitMQ%20and%20batch%20processing&In-Reply-To=%3CCAD6m6fEMZrmkXWMOytw32Sqw9pZqUezejM4YD54q%2BSjsBM4C%3DQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="036089.html">
   <LINK REL="Next"  HREF="036094.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] RabbitMQ and batch processing</H1>
    <B>Jason McIntosh</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20RabbitMQ%20and%20batch%20processing&In-Reply-To=%3CCAD6m6fEMZrmkXWMOytw32Sqw9pZqUezejM4YD54q%2BSjsBM4C%3DQ%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] RabbitMQ and batch processing">mcintoshj at gmail.com
       </A><BR>
    <I>Mon May 19 17:59:03 BST 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="036089.html">[rabbitmq-discuss] RabbitMQ and batch processing
</A></li>
        <LI>Next message: <A HREF="036094.html">[rabbitmq-discuss] RabbitMQ and batch processing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36090">[ date ]</a>
              <a href="thread.html#36090">[ thread ]</a>
              <a href="subject.html#36090">[ subject ]</a>
              <a href="author.html#36090">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Greg:

I thought I'd share a bit of experience I've got.  In general, we've had
very little problems with rabbit, but DEFINITELY make sure you're on the
latest version (at least, latest minor version).  For example, we had a
mirrored queue crash due to a bug when we were on 3.2.0 and 3.2.1 fixed
that bug.  Also, be very careful of your disk IO.  Rabbit doesn't seem to
handle long pauses on the disk very well (not many things do handle this
well).  I've had more problems where the disk sub system slows down than
anything else.

With those two things under consideration, we've had systems where we've
had almost a billion messages backlogged waiting to be processed and we've
been running fine under this load.  I'm looking at a queue right now with
persistent messages (and queue persistent) with over 12 million messages
waiting to be processed.  We're looking to increase the batch performance,
and what else we need to do to increase processing of these messages, but
rabbit is handling this fine.

There ARE numerous methods you can use to handle these kinds of situations.
 For example, x-consistent hashes to distribute messages to additional
queues that get routed to different servers in a &quot;tree&quot; style pattern, with
additional consumers and distributed processing.

Regarding partitioning - I've not hit a partition yet, but we keep our
rabbit clustered nodes really close together to try and prevent any kinds
of issues from occurring.  In general, they're at least on the same switch
or virtual switch.  We then use shovels to distribute the messages to
remote systems.  We setup LTM's in between the shovels and the remote
system with round-robin dispatching of connections.  Though not a precise
load balanced of the messages due to hashing keys and other issues, it gets
us a moderately balanced solution that scales really really well.  Our big
slow down has usually been the database we're writing to on the remote side.

Jason




On Mon, May 19, 2014 at 11:48 AM, Greg Poirier &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">greg.poirier at opower.com</A>&gt;wrote:

&gt;<i> Michael,
</I>&gt;<i>
</I>&gt;<i> Good to hear from you again. If you don't mind, I have a few questions
</I>&gt;<i> about your setup.
</I>&gt;<i>
</I>&gt;<i> I assume for the AMQP proxy, you are referring to something like your
</I>&gt;<i> Fabrik. Would that be correct? How is open sourcing that going? I've been
</I>&gt;<i> interested since your original post.
</I>&gt;<i>
</I>&gt;<i> Being short on resources, but working with developers who have resources,
</I>&gt;<i> I am inclined to introduce them to the idea of the middle layer and seeing
</I>&gt;<i> what we can come up with that is equitable for all.
</I>&gt;<i>
</I>&gt;<i> I think being able to not persist messages in RabbitMQ would be a big win
</I>&gt;<i> for us. This removes the bulk of the io, and I solves our still occasional
</I>&gt;<i> partitioning problems. I'm going to talk to other service owners about
</I>&gt;<i> persisting messages themselves in databases and passing only the ids of
</I>&gt;<i> their messages around. I don't think we can implement a unified middle
</I>&gt;<i> layer given some time constraints, but I'm going to propose that as well
</I>&gt;<i> (as I think it is the best way to approach this). Lacking the ability to
</I>&gt;<i> implement, does shifting persistence to databases and maintaining a batch
</I>&gt;<i> table (of ids in flight) seem like a reasonable interim solution? Or is
</I>&gt;<i> there another approach?
</I>&gt;<i>
</I>&gt;<i> A couple of our service owners already do this. Most do not and instead
</I>&gt;<i> pass entire documents via RabbitMQ to persistent queues. I have a hard time
</I>&gt;<i> identifying who some are but am working on that as well. I think providing
</I>&gt;<i> an API for them would make a huge difference in getting them to standardize
</I>&gt;<i> around a better use of RabbitMQ.
</I>&gt;<i>
</I>&gt;<i> I was toying with a simpler implementation of your cluster configuration,
</I>&gt;<i> but (and I think we discussed this) it will require that producers and
</I>&gt;<i> consumers connect to separate proxy hosts, correct? I am still largely
</I>&gt;<i> unfamiliar with how federation and shovel work--despite having read the
</I>&gt;<i> documentation. I am working on a test bed for myself in my spare time (ha).
</I>&gt;<i> It would be nice to have this proxy layer be single unclustered rabbit
</I>&gt;<i> nodes. I could then take do no downtime upgrades of RabbitMQ, add capacity
</I>&gt;<i> for certain vhosts, etc. Am I understanding federation and shovel
</I>&gt;<i> correctly? Is this even possible?
</I>&gt;<i>
</I>&gt;<i> The idea here being
</I>&gt;<i>
</I>&gt;<i> publisher - proxy - backing cluster - proxy - consumer
</I>&gt;<i>
</I>&gt;<i> Where consumers take messages from queues bound to exchanges to which
</I>&gt;<i> publishers are connected.
</I>&gt;<i>
</I>&gt;<i> I think this requires a database for persistence, because if you publish
</I>&gt;<i> to a proxy exchange and no consumers are connected, then the message gets
</I>&gt;<i> lost.
</I>&gt;<i>
</I>&gt;<i> Is there a reasonable way to avoid this without Fabrik? Publisher confirms
</I>&gt;<i> don't help if no queues are bound. And if we are sharing a database between
</I>&gt;<i> producer and consumer, why bother with RabbitMQ at all?
</I>&gt;<i>
</I>&gt;<i> The beauty of message buses is the ability to pass arbitrary messages over
</I>&gt;<i> them. Without that, what are they for? I realize that we don't want to pass
</I>&gt;<i> large documents in them, but a small JSON blob seems perfectly reasonable.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sunday, May 18, 2014, Laing, Michael &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">michael.laing at nytimes.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> I'll respond inline w our experience:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Sun, May 18, 2014 at 2:55 PM, Greg Poirier &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">greg.poirier at opower.com</A>&gt;wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I mentioned this on Twitter and a couple of people have requested that I
</I>&gt;&gt;&gt;<i> bring this up on the mailing list.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It seems to be a given that RabbitMQ was not designed for the batch
</I>&gt;&gt;&gt;<i> processing use case (i.e. using RabbitMQ as a buffer between large serial
</I>&gt;&gt;&gt;<i> steps). We have a system in place that attempts to do just that, however.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is not a 'given' as far as we are concerned. We have some processes
</I>&gt;&gt;<i> that result in a million or more messages being queued within a minute or
</I>&gt;&gt;<i> so. These messages are processed over the ensuing several minutes (for
</I>&gt;&gt;<i> 'dismissals' of news items from individual devices) to several hours (for
</I>&gt;&gt;<i> lower-priority individualized  'offers'). This is the new 'batch'.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I have been working with the developers of the software involved in an
</I>&gt;&gt;&gt;<i> attempt to help them redesign around a more ideal use of RabbitMQ (or to
</I>&gt;&gt;&gt;<i> help them move to a different bus altogether -- database or something like
</I>&gt;&gt;&gt;<i> kafka) and some of them have been able to simply operate in smaller batch
</I>&gt;&gt;&gt;<i> sizes (thus keeping their queues relatively small).
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We put large message bodies in S3 and pass them by reference. We never
</I>&gt;&gt;<i> use RabbitMQ persistence and compensate for that with replication. For
</I>&gt;&gt;<i> 'real' persistence we use Cassandra. Most importantly, none of our internal
</I>&gt;&gt;<i> users know this, as we provide them with an abstracted interface.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> However, I cannot stem the tide of improper RabbitMQ use.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We try to make it easier to use us than not. We work hard to be the most
</I>&gt;&gt;<i> reliable, fastest, most scalable, most flexible and cheapest component of
</I>&gt;&gt;<i> our customers technology mix.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> When things go poorly, millions of messages end up in the queues.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We target zero length queues. If they grow unexpectedly we: 1) autoscale,
</I>&gt;&gt;<i> 2) shift load, 3) start new regions - usually all those. Then we diagnose.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In 3.1.x we saw this regularly cause our clusters to partition.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We have never had a partition in production because we always
</I>&gt;&gt;<i> overprovision RabbitMQ so it can maintain cluster communications. We
</I>&gt;&gt;<i> basically avoid disk IO due to the risk of IO wait interfering w the
</I>&gt;&gt;<i> cluster heartbeat.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In 3.1.x and 3.2.x when we would delete large queues (5+ million
</I>&gt;&gt;&gt;<i> messages enqueued), this would cause the cluster to become unresponsive,
</I>&gt;&gt;&gt;<i> run out of memory, and then crash.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> When we have tested situations like this, we found it best to just wipe
</I>&gt;&gt;<i> out the cluster and restart. Before doing this, we shift the load to other
</I>&gt;&gt;<i> regions operating in parallel.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> During the 3.1 -&gt; 3.2 upgrade, we had to completely rebuild our
</I>&gt;&gt;&gt;<i> clusters. When 3.2 came up, it soon crashed.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We have not had that problem.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In the most recent upgrade, we saw a 3.2.3 cluster in our dev
</I>&gt;&gt;&gt;<i> environment crash. I performed an opportunistic upgrade to 3.3.1, because
</I>&gt;&gt;&gt;<i> hey... downtime already, so let's see if 3.3.1 addresses some of the issues
</I>&gt;&gt;&gt;<i> we've been seeing.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> <A HREF="https://gist.github.com/grepory/384410ac90186ed0ce2a">https://gist.github.com/grepory/384410ac90186ed0ce2a</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> After the upgrade, 3.3.1 would not startup at all. I removed
</I>&gt;&gt;&gt;<i> /var/lib/rabbitmq/mnesia on all of the nodes and brought RabbitMQ back up.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We are not yet in production w 3.3.1 but 3.2.4 is running solidly in
</I>&gt;&gt;<i> stage and we will upgrade stage to 3.3.1 this coming week.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> 3.3.1 has been up and running alright so far, but we haven't done
</I>&gt;&gt;&gt;<i> another end-to-end test in our development environment in a while. One of
</I>&gt;&gt;&gt;<i> these tests can lead to at least a million messages in the queue over a
</I>&gt;&gt;&gt;<i> period of time on average.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A million is not that many - depending on size of course. As I said - our
</I>&gt;&gt;<i> target is 0, but really the question is: what's your rate of change? I try
</I>&gt;&gt;<i> to have enough 'headroom' to easily handle the surges - volumes can vary 20
</I>&gt;&gt;<i> to 1 depending on the news of the moment etc. If a queue builds and stays
</I>&gt;&gt;<i> high we add resources until it goes down and then investigate.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> So, I guess my question is:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> If I know that I have people using RabbitMQ like this, and there is
</I>&gt;&gt;&gt;<i> nothing I can do to change that fact... what do I do?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You need enough resource. And it is good to be able to autoscale.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A specific suggestion I would make for any internal service provider is
</I>&gt;&gt;<i> to use an amqp proxy. We locate proxy clusters that we control in our
</I>&gt;&gt;<i> internal customers' computing environments. They publish to and subscribe
</I>&gt;&gt;<i> from these proxies. We control the shoveling/federation of the proxies
</I>&gt;&gt;<i> to/from our core pipelines in regions, redirecting as needed. The proxies
</I>&gt;&gt;<i> are an additional buffer and also allow us to 'launder' incoming messages,
</I>&gt;&gt;<i> e.g. by forcing persistence off.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We also track and account for every message using metadata, and can
</I>&gt;&gt;<i> charge back... We are cheap but not free.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Anyway, I hope this helps.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ml
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;<i> rabbitmq-discuss mailing list
</I>&gt;&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>

-- 
Jason McIntosh
<A HREF="https://github.com/jasonmcintosh/">https://github.com/jasonmcintosh/</A>
573-424-7612
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20140519/42f4a713/attachment.html">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20140519/42f4a713/attachment.html</A>&gt;
</PRE>



































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="036089.html">[rabbitmq-discuss] RabbitMQ and batch processing
</A></li>
	<LI>Next message: <A HREF="036094.html">[rabbitmq-discuss] RabbitMQ and batch processing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#36090">[ date ]</a>
              <a href="thread.html#36090">[ thread ]</a>
              <a href="subject.html#36090">[ subject ]</a>
              <a href="author.html#36090">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
