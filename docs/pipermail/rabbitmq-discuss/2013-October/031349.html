<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Feature Req / Bug list
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Feature%20Req%20/%20Bug%20list&In-Reply-To=%3C526A49E0.3010707%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031340.html">
   <LINK REL="Next"  HREF="031355.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Feature Req / Bug list</H1>
    <B>Simon MacMullen</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Feature%20Req%20/%20Bug%20list&In-Reply-To=%3C526A49E0.3010707%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] Feature Req / Bug list">simon at rabbitmq.com
       </A><BR>
    <I>Fri Oct 25 11:37:20 BST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="031340.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
        <LI>Next message: <A HREF="031355.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31349">[ date ]</a>
              <a href="thread.html#31349">[ thread ]</a>
              <a href="subject.html#31349">[ subject ]</a>
              <a href="author.html#31349">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>First of all, thank you for taking the time to generate a test case. I 
haven't reproduced anything yet, but rest assured that I will attempt to 
do so.

I do have some quibbles with a couple of your assertions though:

On 24/10/2013 7:30PM, Graeme N wrote:
&gt;<i> - Bug: even though node and management port listeners are specified, the
</I>&gt;<i> first instance started will still incorrectly bind to port 55672 for the
</I>&gt;<i> management interface.
</I>
Any node with the management plugin will attempt to bind to this port to 
serve an HTTP redirect to the new port (55672 was the old mgmt port in 2.x).

Note that unlike all the other port bindings this will not prevent the 
server from starting up if it fails to bind (we changed it from 55672 
since there were problems binding sometimes).

So yeah, this is pretty hard coded, but it's meant as a fairly invisible 
usability / migration thing. If it bothers you, you can turn it off by 
modifying your script to:

-rabbitmq_management listener [{port,4444$n},{redirect_old_port,false}]

This redirect port will be going away in 3.3.0.

&gt;<i> - populate queues with 1000 messages each in parallel: ./populate_queues.sh
</I>&gt;<i> - Note: shows low delivery rates noted before on spinning disks (60-80
</I>&gt;<i> msgs/sec), even though my VM storage is on btrfs RAID10 capable of
</I>&gt;<i> sustained block writes &gt; 200MB/s. iostat shows the VM is only generating
</I>&gt;<i> 1-8 MB/s of IO. Looking at messages under
</I>&gt;<i> /var/lib/rabbitmq/mnesia/<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbit2 at localhost</A>/queues, they seem to be
</I>&gt;<i> chunked into 64, 68, 72, and 84 kiB files before being delivered to the
</I>&gt;<i> 16MiB msg_store_persistent/*.rdq files. This implies a lot of random IO
</I>&gt;<i> while delivering messages, which explains why the performance problems
</I>&gt;<i> disappear when switching to SSDs, even just two SSDs in RAID1. Typically
</I>&gt;<i> with other data stores we'd expect to see on-disk chunks that are
</I>&gt;<i> multiples of 128 MiB to properly leverage RAID block IO, in both
</I>&gt;<i> incoming and finalized data stores. The effect of this is that it takes
</I>&gt;<i> ~20m to load ~32 MiB of messages, which is pretty awful.
</I>
Err, your script invokes amqp-publish(1) in a loop. 100,000 times. I 
suspect most of the slowness is due to the time taken to fork that many 
processes, open and close that many AMQP connections, and so on. I would 
guess this goes faster on an SSD because you can fork() faster.

Certainly I can populate 100 queues with 1,000 messages each in a rather 
small fraction of a second with the PerfTest tool 
(<A HREF="http://www.rabbitmq.com/java-tools.html">http://www.rabbitmq.com/java-tools.html</A>) if the same message goes to 
all queues 1,000 times, or in less than 10 seconds if each message is 
distinct.

Cheers, Simon

-- 
Simon MacMullen
RabbitMQ, Pivotal
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031340.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
	<LI>Next message: <A HREF="031355.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31349">[ date ]</a>
              <a href="thread.html#31349">[ thread ]</a>
              <a href="subject.html#31349">[ subject ]</a>
              <a href="author.html#31349">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
