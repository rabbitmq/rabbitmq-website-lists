<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Feature Req / Bug list
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Feature%20Req%20/%20Bug%20list&In-Reply-To=%3CCAJ4uuZYha2foXMiQhMKQRdTFDEJ63K8y6e%2B2XbLK%2Bw-goZSthg%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030667.html">
   <LINK REL="Next"  HREF="031340.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Feature Req / Bug list</H1>
    <B>Graeme N</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Feature%20Req%20/%20Bug%20list&In-Reply-To=%3CCAJ4uuZYha2foXMiQhMKQRdTFDEJ63K8y6e%2B2XbLK%2Bw-goZSthg%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] Feature Req / Bug list">graeme at sudo.ca
       </A><BR>
    <I>Fri Oct  4 19:32:33 BST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="030667.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
        <LI>Next message: <A HREF="031340.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30726">[ date ]</a>
              <a href="thread.html#30726">[ thread ]</a>
              <a href="subject.html#30726">[ subject ]</a>
              <a href="author.html#30726">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Oct 4, 2013 at 1:54 AM, Tim Watson &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">watson.timothy at gmail.com</A>&gt; wrote:

&gt;<i> &gt; All items below were discovered while deploying 3.1.5 over the past few
</I>&gt;<i> days. Hosts in question have 24 sandy bridge HT cores, 64GB of RAM, XFS
</I>&gt;<i> filesystem, running on CentOS 6. Cluster is 5 nodes, with a default HA
</I>&gt;<i> policy on all queues of exact/3/automatic-sync.
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i> That's a very strong consistency and redundency guarantee for every queue.
</I>&gt;<i> Do you really need such strong guarantees for all of them? There is a cost
</I>&gt;<i> to doing ha.
</I>&gt;<i>
</I>
Yes, it's very important we never lose a message if it gets accepted for
delivery. We're more than willing to pay the overhead in terms of more
hardware as necessary. The 5 node count is just for initial deployment, I'd
expect us to double the cluster size every year for the next 3-5 years to
deal with our workload growth, even counting improvements in individual
server processing power.


&gt;<i>  &gt; - expected queues to be distributed evenly among cluster machines,
</I>&gt;<i> instead got all queues on first 3 machines in the cluster, nothing on the
</I>&gt;<i> last 2.
</I>&gt;<i>
</I>&gt;<i> Distributed evenly in what regard? Randomly, or based on some metric?
</I>&gt;<i>
</I>
Doesn't matter. Random or round robin would be sufficient. We use in the
order of 100s of queues, and so even with ~10% having a somewhat higher
workload, any distribution scheme would balance the load out between
machines reasonably evenly.

 &gt; - expected message reads from a mirror machine for a queue to do the
&gt;<i> read i/o locally, so as to spread out workload, but it appears to always go
</I>&gt;<i> to the host where the queue was created.
</I>&gt;<i>
</I>&gt;<i> That's expected behaviour. In a master-slave configuration, writes have to
</I>&gt;<i> go to the master. Odd though it may sound, reads from a queue involve
</I>&gt;<i> writes, since we have to do accounting (of e.g.,  pending ACKs, position in
</I>&gt;<i> the queue, etc), so all requests are handled by the master.
</I>&gt;<i>
</I>
Yeah, I understand the logic around needing to do queue management and
requiring locks and writing. It just doesn't make sense to me that the read
can't happen locally if the data exists locally, after all appropriate
queue locks and bookkeeping have completed. I imagine this is just for code
simplicity rather than any technical limitation, and it's something that
really isn't an issue if we can evenly balance queues between cluster
hosts. I also imagine it isn't an issue for people who aren't trying to
send large, persistent, binary messages through the queueing system, since
they probably never run into IO limitations.

 &gt; - this led to a single node with ~35k active open filehandles, and 4
&gt;<i> nodes with ~90. not an optimum distribution of read workload.
</I>&gt;<i>
</I>&gt;<i> Agreed. Simon or Marthias may be able to elaborate on various things we're
</I>&gt;<i> working on to improve workload distribution.
</I>&gt;<i>
</I>
Great! We're doing some work on our code to manually distribute queues at
creation time, but it'd be a lot better if there was a switch to pull on
the rabbit end to just make it happen.


&gt;<i>  &gt; - expected that if system a queue was created on is permanently removed
</I>&gt;<i> (shut down and &quot;rabbitmqctl forget_cluster_node hostname&quot;'d), automatic
</I>&gt;<i> sync would ensure there's the right number of copies replicated, but
</I>&gt;<i> instead it just left every single queue under replicated.
</I>&gt;<i>
</I>&gt;<i> That doesn't sound right. It's not automatic sync we're talking here
</I>&gt;<i> either - that sounds like the policy isn't getting applied properly.
</I>&gt;<i>
</I>
Hmm... Well, we're just applying a global policy with the pattern &quot;.*&quot;, and
it shows as being applied in the queue information API and on the web page.
I'm not sure how to check if it's fully applied otherwise, so if you've got
something I can run to check that, I can definitely do some digging.


&gt;<i>  &gt; - when a new policy is applied that defines specific replication nodes,
</I>&gt;<i> or a number of copies using 'exact, and auto-sync is set, sometimes it just
</I>&gt;<i> syncs the first replica and leaves any others unsynced and calls it job
</I>&gt;<i> done. This is bad.
</I>&gt;<i>
</I>&gt;<i> Can you provide us with a way to reproduce this? How did you detect that
</I>&gt;<i> the remaining replicas were not sync'ed?
</I>&gt;<i>
</I>
Detection was just by looking at the queue page in the management web GUI.
It shows a big blue +1 and a big red +1 next to maybe 10% of queues after
applying the global queue policy after all sync ops complete. If I issue a
manual sync operation on all the problem queues, then they correctly finish
syncing up the 3rd data copy. I'll see if I can script up a way to
reproduce it on clean set of nodes, since I'm trying not to break my prod
cluster any more than I have this week. I'll e-mail the list once I've got
a reproducible test case.


&gt;<i>  &gt; - Attempted to create small per-queue policies to redistribute messages
</I>&gt;<i> and then delete the per-queue policies, but this often leads to a
</I>&gt;<i> inconsistent cluster state where queues continued to show as being part of
</I>&gt;<i> a policy that was already deleted, attempt to resync, and get stuck, unable
</I>&gt;<i> to complete or switch back to the global default policy.
</I>&gt;<i>
</I>&gt;<i> Again, it would be helpful if you could help us to replicate this.
</I>&gt;<i>
</I>
This is 100% reproducible on our prod cluster. I've got a python script
that attempts the rebalancing on a cluster, so I'll add some logic to get
it to generate and populate queues to reproduce this on a fresh cluster,
and e-mail that out.


&gt;<i>  &gt; - sometimes the cluster refuses to accept any more policy commands.
</I>&gt;<i> Have to fully shut down and restart the cluster to clear this condition.
</I>&gt;<i>
</I>&gt;<i> And this. Can you provide a run down of these policies and the order in
</I>&gt;<i> which you're trying to apply them? Also, how busy are the queues whilst the
</I>&gt;<i> policy changes are happening? We may need to extend our test beds to
</I>&gt;<i> reliably reproduce such problems.
</I>&gt;<i>
</I>
This case happens after attempting a bunch of policy operations from the
previous mentioned script, so it should be easy enough to see it in action
once I've got a script to reproduce the previous issue. We saw this
happening with as low as 5 messages/sec on the whole cluster, so it doesn't
seem to be load related.


&gt;<i> &gt; - sometimes policies applied to empty and inactive queues don't get
</I>&gt;<i> correctly applied, and the queue hangs on &quot;resyncing / 100%&quot;.l
</I>&gt;<i>
</I>&gt;<i> What!?
</I>&gt;<i>
</I>
Yeah. That was my reaction as well. We saw this after removing the
per-queue polices created with the previous mentioned script, after the
queues reverted to the global exact/3/autosync policy. I had to actually
kill all of my rabbitmq instances as they wouldn't nicely shut down, and
then bring the whole cluster back up to clear this.


&gt;<i>  &gt; this makes no sense, given the queue is empty, and requires a full
</I>&gt;<i> cluster restart to clear.
</I>&gt;<i>
</I>&gt;<i> Please provide the commands you invoked to get this to happen.
</I>&gt;<i>
</I>
Again, this are all things noticed after running the script mentioned above
to do the per-queue policies. I didn't intentionally do anything to make
these errors occur, but once I've got a script to reproduce the first set
of errors on a fresh cluster, it should be easy enough to see some of these
other issues, since they seem to cascade from the first set of problems.


&gt;<i>  &gt; - I've managed to get the cluster into an inconsistent state a /lot/
</I>&gt;<i> using the HA features, so it feels like they need more automated stress
</I>&gt;<i> testing and bulletproofing.
</I>&gt;<i>
</I>&gt;<i> If you can help us repoduce these errors, I can assure you that they'll
</I>&gt;<i> get included in our integration tests!
</I>&gt;<i>
</I>
Great. I'll get to work on being able to solidly reproduce at least the
first set of issues I encountered, and hopefully that'll lead to a
reproduction path for some of the other ones.


&gt;<i>  &gt; Persistent message storage:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; - it appears as if messages are put into very small batch files on the
</I>&gt;<i> filesystem (1-20 MB)
</I>&gt;<i> &gt; - this causes the filesystem to thrash if your IO isn't good at random
</I>&gt;<i> IO (SATA disks) and you have lots of persistent messages (&gt;200k messages
</I>&gt;<i> 500kB-1MB in size) that don't fit in RAM.
</I>&gt;<i> &gt; - this caused CentOS 6 kernel to kill erlang after stalling the XFS
</I>&gt;<i> filesystem for &gt; 120s.
</I>&gt;<i>
</I>&gt;<i> Iirc this is tuneable, though we don't recommend changing it. Not at u
</I>&gt;<i> desk right now though, so I can't remember the exact details.
</I>&gt;<i>
</I>
It doesn't seem to be an issue since we've switched to SSDs, so I'm not
going to spend a lot of time worrying about it. It'd just be nice to see
some supported tuning options for this make a dev roadmap for the future.


&gt;<i>  &gt; - if a node crashes, Rabbit seems to rescan the entire on-disk
</I>&gt;<i> datastore before continuing, instead of using some sort of checkpointing or
</I>&gt;<i> journaling system to quickly recover from a crash.
</I>&gt;<i> &gt; - all of above should be solvable by using an existing append-only
</I>&gt;<i> datastore like eLevelDB or Bitcask.
</I>&gt;<i>
</I>&gt;<i> On our todo list already, at least for the message store index.
</I>&gt;<i>
</I>
Great, glad to hear it.

There's probably a lot of performance improvements to be had by using
something like eleveldb or bitcask, since they do a lot to optimize disk
seeks and RAM buffering, but I imagine that's a fairly ambitious amount of
work that isn't high particularly high priority for you guys. Just a
suggestion to think about in the long term, or to put an intern on testing.
;)

In any case, I'm going to get working on reproducible test cases for all
the issues we've been discussing. I'll update this thread when I have
something concrete for you.

Graeme
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20131004/ee9abb52/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20131004/ee9abb52/attachment.htm</A>&gt;
</PRE>












<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030667.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
	<LI>Next message: <A HREF="031340.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30726">[ date ]</a>
              <a href="thread.html#30726">[ thread ]</a>
              <a href="subject.html#30726">[ subject ]</a>
              <a href="author.html#30726">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
