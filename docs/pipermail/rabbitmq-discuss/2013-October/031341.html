<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Feature Req / Bug list
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Feature%20Req%20/%20Bug%20list&In-Reply-To=%3CCANXOX8_N%3DKBpzGd-rOZso_RXvo3xNhwutEUhiZBxZs77M_RhzA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030730.html">
   <LINK REL="Next"  HREF="031343.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Feature Req / Bug list</H1>
    <B>Guido Stepken</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Feature%20Req%20/%20Bug%20list&In-Reply-To=%3CCANXOX8_N%3DKBpzGd-rOZso_RXvo3xNhwutEUhiZBxZs77M_RhzA%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] Feature Req / Bug list">gstepken at googlemail.com
       </A><BR>
    <I>Thu Oct 24 19:34:54 BST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="030730.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
        <LI>Next message: <A HREF="031343.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31341">[ date ]</a>
              <a href="thread.html#31341">[ thread ]</a>
              <a href="subject.html#31341">[ subject ]</a>
              <a href="author.html#31341">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&quot;single node with ~35k active open filehandles&quot;

I assume, all those file handles point to same content? If this would be
the case, programmers should go back to school, learn from scratch.

Where does this come from?
Am 03.10.2013 23:04 schrieb &quot;Graeme N&quot; &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">graeme at sudo.ca</A>&gt;:

&gt;<i> Hey everyone,
</I>&gt;<i>
</I>&gt;<i> I've recently been doing a deployment of a 5 node rabbit cluster, and
</I>&gt;<i> found some rough edges I thought I should share. I realize many of these
</I>&gt;<i> are feature reqs, but I'm hoping that I just haven't discovered the proper
</I>&gt;<i> configuration to deal with some of these issues, or have misunderstood
</I>&gt;<i> Rabbit's behaviour. If not, hopefully they can become feature req items
</I>&gt;<i> that'll make a dev schedule at some point.
</I>&gt;<i>
</I>&gt;<i> All items below were discovered while deploying 3.1.5 over the past few
</I>&gt;<i> days. Hosts in question have 24 sandy bridge HT cores, 64GB of RAM, XFS
</I>&gt;<i> filesystem, running on CentOS 6. Cluster is 5 nodes, with a default HA
</I>&gt;<i> policy on all queues of exact/3/automatic-sync.
</I>&gt;<i>
</I>&gt;<i> HA / Clustering:
</I>&gt;<i>
</I>&gt;<i> - expected queues to be distributed evenly among cluster machines, instead
</I>&gt;<i> got all queues on first 3 machines in the cluster, nothing on the last 2.
</I>&gt;<i> - expected message reads from a mirror machine for a queue to do the read
</I>&gt;<i> i/o locally, so as to spread out workload, but it appears to always go to
</I>&gt;<i> the host where the queue was created.
</I>&gt;<i> - this led to a single node with ~35k active open filehandles, and 4 nodes
</I>&gt;<i> with ~90. not an optimum distribution of read workload.
</I>&gt;<i> - expected that if system a queue was created on is permanently removed
</I>&gt;<i> (shut down and &quot;rabbitmqctl forget_cluster_node hostname&quot;'d), automatic
</I>&gt;<i> sync would ensure there's the right number of copies replicated, but
</I>&gt;<i> instead it just left every single queue under replicated.
</I>&gt;<i> - when a new policy is applied that defines specific replication nodes, or
</I>&gt;<i> a number of copies using 'exact, and auto-sync is set, sometimes it just
</I>&gt;<i> syncs the first replica and leaves any others unsynced and calls it job
</I>&gt;<i> done. This is bad.
</I>&gt;<i> - had to add a new global HA policy and delete the existing one before
</I>&gt;<i> rabbit fixed my queue replication.
</I>&gt;<i> - Attempted to create small per-queue policies to redistribute messages
</I>&gt;<i> and then delete the per-queue policies, but this often leads to a
</I>&gt;<i> inconsistent cluster state where queues continued to show as being part of
</I>&gt;<i> a policy that was already deleted, attempt to resync, and get stuck, unable
</I>&gt;<i> to complete or switch back to the global default policy.
</I>&gt;<i> - sometimes the cluster refuses to accept any more policy commands. Have
</I>&gt;<i> to fully shut down and restart the cluster to clear this condition.
</I>&gt;<i> - sometimes policies applied to empty and inactive queues don't get
</I>&gt;<i> correctly applied, and the queue hangs on &quot;resyncing / 100%&quot;. this makes no
</I>&gt;<i> sense, given the queue is empty, and requires a full cluster restart to
</I>&gt;<i> clear.
</I>&gt;<i> - would like to see a tool to redistribute queues amongst available
</I>&gt;<i> cluster machines according to HA policy. Ideally something that happens
</I>&gt;<i> automatically on queue creation, cluster membership and policy changes, but
</I>&gt;<i> would take something manual I could run out of cron.
</I>&gt;<i> - I've managed to get the cluster into an inconsistent state a /lot/ using
</I>&gt;<i> the HA features, so it feels like they need more automated stress testing
</I>&gt;<i> and bulletproofing.
</I>&gt;<i>
</I>&gt;<i> Persistent message storage:
</I>&gt;<i>
</I>&gt;<i> - it appears as if messages are put into very small batch files on the
</I>&gt;<i> filesystem (1-20 MB)
</I>&gt;<i> - this causes the filesystem to thrash if your IO isn't good at random IO
</I>&gt;<i> (SATA disks) and you have lots of persistent messages (&gt;200k messages
</I>&gt;<i> 500kB-1MB in size) that don't fit in RAM.
</I>&gt;<i> - this caused CentOS 6 kernel to kill erlang after stalling the XFS
</I>&gt;<i> filesystem for &gt; 120s.
</I>&gt;<i> - if a node crashes, Rabbit seems to rescan the entire on-disk datastore
</I>&gt;<i> before continuing, instead of using some sort of checkpointing or
</I>&gt;<i> journaling system to quickly recover from a crash.
</I>&gt;<i> - all of above should be solvable by using an existing append-only
</I>&gt;<i> datastore like eLevelDB or Bitcask.
</I>&gt;<i> - we solved for now by using SSDs, but this bumps up the cost of each RMQ
</I>&gt;<i> node, and doesn't solve the node crash recovery problem, just speeds up the
</I>&gt;<i> process somewhat.
</I>&gt;<i>
</I>&gt;<i> Web API:
</I>&gt;<i> - API seems to block when cluster is busy, even for informational GETs, so
</I>&gt;<i> you can't determine what's going on with the cluster.
</I>&gt;<i> - Some API operations seem to block until they complete (like putting a
</I>&gt;<i> new policy), while others return immediately even though they're definitely
</I>&gt;<i> not completed yet (like deleting a policy). It's not documented which have
</I>&gt;<i> which behaviour, or why they don't just all block until op is completed.
</I>&gt;<i>
</I>&gt;<i> Hopefully you guys can educate me on what I'm doing wrong in some of these
</I>&gt;<i> scenarios, or how to mitigate some of these issues. Any issue that requires
</I>&gt;<i> taking down and restarting the cluster to fix is especially troubling.
</I>&gt;<i>
</I>&gt;<i> Thanks,
</I>&gt;<i> Graeme
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20131024/3dda04bb/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20131024/3dda04bb/attachment.htm</A>&gt;
</PRE>
























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030730.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
	<LI>Next message: <A HREF="031343.html">[rabbitmq-discuss] Feature Req / Bug list
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31341">[ date ]</a>
              <a href="thread.html#31341">[ thread ]</a>
              <a href="subject.html#31341">[ subject ]</a>
              <a href="author.html#31341">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
