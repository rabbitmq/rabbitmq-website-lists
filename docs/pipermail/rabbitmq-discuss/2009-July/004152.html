<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Headers Exchange Logic
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Headers%20Exchange%20Logic&In-Reply-To=269388e30907170730t37c03a7tb45a55c87fd39ccb%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004148.html">
   <LINK REL="Next"  HREF="004149.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Headers Exchange Logic</H1>
    <B>Darien Kindlund</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Headers%20Exchange%20Logic&In-Reply-To=269388e30907170730t37c03a7tb45a55c87fd39ccb%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Headers Exchange Logic">darien at kindlund.com
       </A><BR>
    <I>Fri Jul 17 15:55:07 BST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="004148.html">[rabbitmq-discuss] Headers Exchange Logic
</A></li>
        <LI>Next message: <A HREF="004149.html">[rabbitmq-discuss] Headers Exchange Logic
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4152">[ date ]</a>
              <a href="thread.html#4152">[ thread ]</a>
              <a href="subject.html#4152">[ subject ]</a>
              <a href="author.html#4152">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Ben,

&gt;<i> We did look at this briefly, but decided to shelve this feature
</I>&gt;<i> because it is very difficult to implement on the broker side because
</I>&gt;<i> of the multi-dimensional indexes you'd have to maintain.
</I>&gt;<i>
</I>&gt;<i> Having said that, maybe implementing it on the broker side is perhaps
</I>&gt;<i> being a bit too fancy - maybe you can just trade off network bandwidth
</I>&gt;<i> for broker side query complexity.
</I>&gt;<i>
</I>&gt;<i> Having said this though, you'd probably want a way to reject messages
</I>&gt;<i> without having to nuke the channel.
</I>
Understood.  Thanks for the clarification.  So currently, custom
header processing such as this would require all applicable consumers
receive a copy of the message with the expectation that 1 consumer
will process the message, while the remaining consumers would simply
drop it on the floor.  Yes, essentially, that would work -- the only
downside is the additional CPU processing required by each consumer
(that evaluated and dropped the message, so N-1 consumers total),
along with the network bandwidth associated with sending the messages
to the (N-1) consumers.

This solution is feasible, as long as N remains relatively small.
There's a point, though, where N becomes large enough to want this
functionality pushed to the AMQP server.

Hi Tony,

&gt;<i> Absolutely -- there's a hugely rich vein of possible exchange behaviours
</I>&gt;<i> waiting to be explored. Streaming SQL? Javascript-based message
</I>&gt;<i> matching? The sky's the limit :)
</I>
Okay, I'm glad it's something on your radar.  I realize this type of
support can quickly become extremely complicated, so I understand why
it's not developed just yet.  One thing to keep in mind is that as you
support more complicated evaluations, you'll require the AMQP server
to generate more and more CPU cycles per message.  If you're in an
environment where you don't entirely trust all the consumers, then you
probably want some sort of sanity checking on the evaluation logic
each consumer supplies the server during a bind request.  For example,
if the pseudo code for the bind header were something like:
&quot;while(true) { header &gt; 2; }&quot; then the first evaluation becomes a DoS
attack.  Thus, you'd probably want to set a max evaluation timeout and
if during any message processing, the eval logic takes more than X
amount of time --- *keep* the message in the queue, but *destroy* the
queue/binding of the offending consumer, so that the consumer is
penalized but the message can still be (potentially) reliably
delivered.

I'm sure there's a lot more complexity to deal with than just this
example, but I hope it helps.

Regards,
-- Darien


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004148.html">[rabbitmq-discuss] Headers Exchange Logic
</A></li>
	<LI>Next message: <A HREF="004149.html">[rabbitmq-discuss] Headers Exchange Logic
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4152">[ date ]</a>
              <a href="thread.html#4152">[ thread ]</a>
              <a href="subject.html#4152">[ subject ]</a>
              <a href="author.html#4152">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
