<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Fwd:  One Producer,	X Consumers where X can change
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Fwd%3A%20%20One%20Producer%2C%0A%09X%20Consumers%20where%20X%20can%20change&In-Reply-To=%3C9589A02B-642D-4235-A43F-D558956EC09D%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024903.html">
   <LINK REL="Next"  HREF="024910.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Fwd:  One Producer,	X Consumers where X can change</H1>
    <B>Tim Watson</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Fwd%3A%20%20One%20Producer%2C%0A%09X%20Consumers%20where%20X%20can%20change&In-Reply-To=%3C9589A02B-642D-4235-A43F-D558956EC09D%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] Fwd:  One Producer,	X Consumers where X can change">tim at rabbitmq.com
       </A><BR>
    <I>Mon Jan 14 15:15:29 GMT 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="024903.html">[rabbitmq-discuss] Publishing binary data using the java client
</A></li>
        <LI>Next message: <A HREF="024910.html">[rabbitmq-discuss] newbie with data feed application to Rabbit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24909">[ date ]</a>
              <a href="thread.html#24909">[ thread ]</a>
              <a href="subject.html#24909">[ subject ]</a>
              <a href="author.html#24909">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Putting the list back on CC - I didn't realise I hadn't hit reply-all.

Begin forwarded message:

&gt;<i> From: &quot;Ryan R.&quot; &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ryan.rajkomar at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [rabbitmq-discuss] One Producer, X Consumers where X can change
</I>&gt;<i> Date: 14 January 2013 10:21:48 GMT
</I>&gt;<i> To: Tim Watson &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">tim at rabbitmq.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> Hi,
</I>&gt;<i> 
</I>&gt;<i> First of all thanks for the quick reply,
</I>&gt;<i> 
</I>&gt;<i> I'm well aware that trying to use such solution as many issues (mostly the data integrity should a error arise somewhere along the process) and that is indeed problematic.
</I>&gt;<i> I was actually just looking for a potential way of doing what I need : I have one (or more) webservices whose objects might contains references to objects of another webservice (ideally each WS has its own DB on a different server)
</I>&gt;<i> 
</I>&gt;<i> The issue here is how to keep data integrity when trying to delete the referenced element : if one of the references can't be deleted (for any reason) nothing should be deleted. However here, since data on on different database/webservices/server, I can't do a simple DB transaction.
</I>&gt;<i> 
</I>&gt;<i> Initially I did not really intend to use rabbitMQ for this but only for a notifications system.
</I>&gt;<i> But I figured, since having a delay in my deletion process between the request and the actual deletion wasn't an issue, maybe I might be able to find a solution there.
</I>&gt;<i> 
</I>&gt;<i> Finally, and this has nothing to do with my research, for some reason I do not see your post in google groups. How come?
</I>&gt;<i> 
</I>&gt;<i> Thanks again,
</I>&gt;<i> Cheers.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 2013/1/14 Tim Watson &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">tim at rabbitmq.com</A>&gt;
</I>&gt;<i> Hi,
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On 01/14/2013 08:34 AM, Shadowalker wrote:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Hi again, 
</I>&gt;&gt;<i> Been doing a lot of googling on the queue/topic/listening for consumed messages count an found this on activemq : 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> <A HREF="http://activemq.apache.org/cms/handling-advisory-messages.html">http://activemq.apache.org/cms/handling-advisory-messages.html</A>
</I>&gt;&gt;<i> It allows one to check the count of currently listening consumer a queue/topic. 
</I>&gt;&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> I would not recommend an architecture for distributed resource tracking based on that. What happens if a consumer is temporarily disconnected when you go into the check, but reconnects after (or whilst) the rest of the participants are being updated? You've introduced even more possibilities for race conditions than before.
</I>&gt;<i> 
</I>&gt;<i> What I would suggest is that you carefully consider whether you actually need synchronous communications here, as messaging based architectures inherently de-couple producers from consumers, yet you've repeatedly attempted to force some 'awareness' of consumers into the producer whilst discussing this design. I would like to posit that this reveals an 'impedance mismatch' between your requirements and the inherently disconnected nature of a queue based solution. Of course distributed locking is often implemented using asynchronous communication protocols, but this is usually done at a *much lower protocol level* - I'd suggest researching Paxos or similar distributed consensus algorithms to get an idea of what's involved in designing a reliable solution to this kind of problem.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Is there anything like this in rabbit mq ?
</I>&gt;<i> 
</I>&gt;<i> Not that I know of, although it's possible to use the HTTP APIs in order to track consumers but that is, as I mentioned above, subject to lots of *nasty* race conditions. You *could* look at using Tony G's presence exchange (<A HREF="https://github.com/tonyg/presence-exchange">https://github.com/tonyg/presence-exchange</A>) to track bindings - although this would complicate your topology quite a lot, it might make tracking the various participants plausibly useful, providing you use a known set of binding keys.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> This might allow me to create a listener that would only send a message to notify the first manager that the references were removed.
</I>&gt;<i> 
</I>&gt;<i> I'm not clear on how that helps!? I did have a bit of an early start this morning though... ;)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i> Another could be to define the &quot;delete referenrences&quot; message to live for x consumptions (x being the number of listener on the &quot;delete references&quot; queue) and add an advisory listener on the deletion of the message from the queue to process deletion of initial data.
</I>&gt;<i> 
</I>&gt;<i> That doesn't help at all unless you've actually tracked the number of acquired messages in the first place. Plus you *can* do that without 'detecting' the number of consumers. You just insist on getting a 'make-ref' message from the consumer (with some unique id) before incrementing the reference count. There's no real difference between *detecting* the consumer's connection/channel and providing a ref/lock acquisition queue, except that the latter is probably more structured, architecturally clearer and quite likely to be more reliable.
</I>&gt;<i> 
</I>&gt;<i> Even if you used ActiveMQ's detection functionality or RabbitMQ's management HTTP APIs, the fundamental problem of race conditions wouldn't go away. Before we go much further discussing various ways you can design a solution - and I *am* interested in this discussion BTW - please read <A HREF="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance#Byzantine_failures">http://en.wikipedia.org/wiki/Byzantine_fault_tolerance#Byzantine_failures</A> and make sure you've understood the consequences of nodes *just disappearing* and then *maybe* coming back later on.
</I>&gt;<i> 
</I>&gt;<i> You've also still not explained what the consequences of loosing track of resources actually are. If one of your nodes dies, when it comes back to life has any state been persisted and will that state thus be used to try and re-acquire or release the 'lock count' for this resource? What happens if your node sends an 'acquire' request asynchronously, then starts to write the resource/lock state to its own local database and dies (e.g., the machine crashes) before committing the transaction? Because the 'acquire' request was not synchronous, the master now thinks that your node holds the lock, whilst the node does *not* think the same. If you bring the node back online and then start asking for the resource lock, you're breaking the contract for lock acquisition on that node unless you're willing to make 'acquire' idempotent, which has its own pitfalls. If you don't make 'acquire' idempotent, then acquisition will fail. If you try to handle this by making 'acquire' re-entrant and then try to release the node's locl, the master will be confused as it thinks you hold the lock twice and the *lost lock acquisition* will never be released.
</I>&gt;<i> 
</I>&gt;<i> tldr; this is not a simple problem.
</I>&gt;<i> 
</I>&gt;<i> Cheers,
</I>&gt;<i> Tim
</I>&gt;<i> 
</I>&gt;<i> 
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130114/3fd592bd/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130114/3fd592bd/attachment.htm</A>&gt;
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024903.html">[rabbitmq-discuss] Publishing binary data using the java client
</A></li>
	<LI>Next message: <A HREF="024910.html">[rabbitmq-discuss] newbie with data feed application to Rabbit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24909">[ date ]</a>
              <a href="thread.html#24909">[ thread ]</a>
              <a href="subject.html#24909">[ subject ]</a>
              <a href="author.html#24909">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
