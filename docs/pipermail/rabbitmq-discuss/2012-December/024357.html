<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Creating an auth plugin (Kerberos)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Creating%20an%20auth%20plugin%20%28Kerberos%29&In-Reply-To=%3C24509631-CA1C-4A55-8E66-87E11E4E5D83%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024355.html">
   <LINK REL="Next"  HREF="024358.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Creating an auth plugin (Kerberos)</H1>
    <B>Tim Watson</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Creating%20an%20auth%20plugin%20%28Kerberos%29&In-Reply-To=%3C24509631-CA1C-4A55-8E66-87E11E4E5D83%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] Creating an auth plugin (Kerberos)">tim at rabbitmq.com
       </A><BR>
    <I>Wed Dec  5 14:48:07 GMT 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="024355.html">[rabbitmq-discuss] Creating an auth plugin (Kerberos)
</A></li>
        <LI>Next message: <A HREF="024358.html">[rabbitmq-discuss] Creating an auth plugin (Kerberos)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24357">[ date ]</a>
              <a href="thread.html#24357">[ thread ]</a>
              <a href="subject.html#24357">[ subject ]</a>
              <a href="author.html#24357">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Simon,

This is why I suggested using an insulator process. The process that calls open_port is the controlling process and when the port is closed, it will send the controlling process and exit signal. You override that by passing exit_status, but you also supply 'eof' and the ordering between the eof and exit_status messages is not guaranteed. When you time out in the after clause, you have *no idea* whether or not the port program is still running, which could lead to any of

- leaking resources such as file descriptors used for the port
- erroneous messages sent to the reader process (such as the 'EXIT' that is arriving when you call port_close)

I would strongly suggest considering an insulator process for this. Do you need some pointers to doing that? Let me cook something up for you.....

In this code, notice that the command I'm running is guaranteed to finish within the 2000 ms timeout. I don't care about that, because it is only the exit status that matters to me. If you need to examine the stdio, then that's another matter but you aren't currently doing that. 

Now if you change the command to something that will run for a *long* time such as `ls -laR /` it will *not* finish quickly enough and yes all is still well and there are no stray messages. BUT ..... that command `ls -laR /` will not respond to stdin and will therefore *continue running even AFTER the port is closed* - so you need to be very careful to ensure that your program will actually terminate. I use hack to enforce this sometimes:

Cmd = &quot;/usr/bin/env sh -c \&quot;(cat; kill 0) | &quot; ++ Exec ++ &quot; \&quot;&quot;

Anyway, here is the module. Note that lots of the wait_for_this and that is just to demonstrate what's going on. Hope this helps.

&lt;code&gt;

-module(foo).

-export([main/1]).

main(_) -&gt;
    Result = run_insulator(),
    io:format(&quot;Result = ~p~n&quot;, [Result]),
    wait_for_stray_messages().

wait_for_stray_messages() -&gt;
    receive
        Any -&gt; io:format(&quot;got stray message ~p~n&quot;, [Any]),
               wait_for_stray_messages()
    after 5000 -&gt;
        io:format(&quot;we're done - no stray messages/EXIT's and we're good to go...~n&quot;)
    end.

run_insulator() -&gt;
    {Pid, MRef} = spawn_monitor(fun insulated/0),
    receive
        {'DOWN', MRef, process, Pid, Reason} -&gt;
            case Reason of
                {done, Result} -&gt; Result;
                Other          -&gt; {error, Other}
            end
    after 2000 -&gt;
        %% get rid of any pending monitor notifications
        erlang:demonitor(MRef, [flush]),
        exit(Pid, shutdown),
        false
    end.

insulated() -&gt;
    process_flag(trap_exit, true),
    Port = open_port({spawn, &quot;ls -la&quot;}, [
                     exit_status, use_stdio, eof,
                     {line, 1024}]),
    Result = loop(Port),
    erlang:port_close(Port),
    exit({done, Result}).

loop(Port) -&gt;
    Self = self(),
    receive
        %% we do not appear to care about the stdio
        {Port, {data, {_, _}}}    -&gt; loop(Port);
        {Port, eof}               -&gt; loop(Port);
        {Port, {exit_status, 0}}  -&gt; true;
        {Port, {exit_status, _N}} -&gt; false;
        {'EXIT', Self, shutdown}  -&gt; false
    end.

&lt;/code&gt;

Cheers,

Tim

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024355.html">[rabbitmq-discuss] Creating an auth plugin (Kerberos)
</A></li>
	<LI>Next message: <A HREF="024358.html">[rabbitmq-discuss] Creating an auth plugin (Kerberos)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24357">[ date ]</a>
              <a href="thread.html#24357">[ thread ]</a>
              <a href="subject.html#24357">[ subject ]</a>
              <a href="author.html#24357">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
