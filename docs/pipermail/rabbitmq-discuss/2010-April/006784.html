<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Old consumer tags delivered after	re-subscribing to a queue
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Old%20consumer%20tags%20delivered%20after%0A%09re-subscribing%20to%20a%20queue&In-Reply-To=20100402165432.GL11613%40wellquite.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006783.html">
   <LINK REL="Next"  HREF="006785.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Old consumer tags delivered after	re-subscribing to a queue</H1>
    <B>Juan Wajnerman</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Old%20consumer%20tags%20delivered%20after%0A%09re-subscribing%20to%20a%20queue&In-Reply-To=20100402165432.GL11613%40wellquite.org"
       TITLE="[rabbitmq-discuss] Old consumer tags delivered after	re-subscribing to a queue">juan.wajnerman at gmail.com
       </A><BR>
    <I>Fri Apr  2 19:01:37 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="006783.html">[rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue
</A></li>
        <LI>Next message: <A HREF="006785.html">[rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6784">[ date ]</a>
              <a href="thread.html#6784">[ thread ]</a>
              <a href="subject.html#6784">[ subject ]</a>
              <a href="author.html#6784">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Apr 2, 2010, at 1:54 PM, Matthew Sackman wrote:

&gt;<i> Actually, I think you'll see this bug if you just do: subscribe,
</I>&gt;<i> unsubscribe, recover. The second subscription should be unnecessary.
</I>
Yes, you're right. 



&gt;<i> 
</I>&gt;<i> Yes. There's probably an argument for saying that in the absence of a
</I>&gt;<i> valid consumer tag, the messages should be sent to the client as a
</I>&gt;<i> sequence of basic.get-oks, or at least a basic.deliver with a very
</I>&gt;<i> special ctag to indicate to the clients that they shouldn't be suprised
</I>&gt;<i> by these deliveries which are apparently appearing outside of the scope
</I>&gt;<i> of any subscription it knows about. This really seems to be a bug in the
</I>&gt;<i> spec rather than our implementation or the client.
</I>&gt;<i> 
</I>&gt;<i> At the very least, the basic.recover_ok should contain a new ctag (which
</I>&gt;<i> for symmetry suggests the client should be able to specify one in
</I>&gt;<i> basic.recover to mirror basic.consume and basic.consume_ok) which the
</I>&gt;<i> client can then use to identify these deliveries and route them
</I>&gt;<i> accordingly.
</I>
At this point I should go and read the full specs to try to understand the reasons for this
design. However, I don't see the reason for redelivering messages to a consumer that
already said explicitly that it doesn't want to receive messages from that queue anymore.
Why don't just redeliver the messages to other possible subscribers after the subscription
cancel was received? Ok, maybe the consumer can subscribe again using the same ctag (the library
should allow to do so) or the server should understand the change of ctag, given that there
cannot be two consumers for the same queue on the same channel, right?

I just have a couple of weeks of experience with AMQP and RabbitMQ and I'm still
trying to figure out the architecture patters that I should follow for our design. One thing
that still results strange to me is that the recover operates only at a channel level and there
is no way to recover messages just for one queue.

&gt;<i> I would recommend that you don't use recover without also setting
</I>&gt;<i> requeue=true, thus ensuring the messages are inserted back into the
</I>&gt;<i> queue and can hence be redelivered to any valid consumer again (at
</I>&gt;<i> which point the ctag will be set correctly). Hopefully you'll at
</I>&gt;<i> least get unsurprising behaviour! I will raise some bugs to cover the
</I>&gt;<i> issues uncovered - many thanks for the report.
</I>
Yes! this solved my issue.

- Juan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100402/afe1c7a5/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100402/afe1c7a5/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006783.html">[rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue
</A></li>
	<LI>Next message: <A HREF="006785.html">[rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6784">[ date ]</a>
              <a href="thread.html#6784">[ thread ]</a>
              <a href="subject.html#6784">[ subject ]</a>
              <a href="author.html#6784">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
