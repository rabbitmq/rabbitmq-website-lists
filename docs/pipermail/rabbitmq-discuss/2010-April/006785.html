<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Old%20consumer%20tags%20delivered%20after%0A%20re-subscribing%20to%20a%20queue&In-Reply-To=D5D26DD6-522A-4719-9A13-77FBFBF4297F%40gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006784.html">
   <LINK REL="Next"  HREF="006789.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue</H1>
    <B>Matthew Sackman</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Old%20consumer%20tags%20delivered%20after%0A%20re-subscribing%20to%20a%20queue&In-Reply-To=D5D26DD6-522A-4719-9A13-77FBFBF4297F%40gmail.com"
       TITLE="[rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue">matthew at lshift.net
       </A><BR>
    <I>Fri Apr  2 20:46:59 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="006784.html">[rabbitmq-discuss] Old consumer tags delivered after	re-subscribing to a queue
</A></li>
        <LI>Next message: <A HREF="006789.html">[rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6785">[ date ]</a>
              <a href="thread.html#6785">[ thread ]</a>
              <a href="subject.html#6785">[ subject ]</a>
              <a href="author.html#6785">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Apr 02, 2010 at 03:01:37PM -0300, Juan Wajnerman wrote:
&gt;<i> At this point I should go and read the full specs to try to understand the reasons for this
</I>&gt;<i> design. However, I don't see the reason for redelivering messages to a consumer that
</I>&gt;<i> already said explicitly that it doesn't want to receive messages from that queue anymore.
</I>
Well, the consumer also said &quot;send me messages, and I'll ack them when
I'm done with them&quot;. If you don't want them any more, use recover with
requeue=true (which you now have done). It's also possible that you
should be setting qos to some lowish value - between 1 and 10 which will
limit the number of messages that get buffered in the client - i.e. it
should result in fewer messages arriving at the client between you sending
off the cancel and getting the cancel_ok back (in fact, if you're acking
explicitly then it would mean you can't ever receive more messages per
consumer than you have qos set to).

&gt;<i> Why don't just redeliver the messages to other possible subscribers after the subscription
</I>&gt;<i> cancel was received?
</I>
Because you might want to say &quot;consume, then I'm going to take the next
N messages, stop consuming, but I'm still going to process those N
messages in my leisure and I'll ack them in due course - but whilst I'm
processing those, I don't want to be receiving any further messages&quot;.

&gt;<i> Ok, maybe the consumer can subscribe again using the same ctag (the library
</I>&gt;<i> should allow to do so) or the server should understand the change of ctag, given that there
</I>&gt;<i> cannot be two consumers for the same queue on the same channel, right?
</I>
Not with the same ctag. There are all sorts of complications due to the
provision for user-supplied ctags. I wish all ctags were only supplied
by the server, but that's another issue really.

&gt;<i> I just have a couple of weeks of experience with AMQP and RabbitMQ and I'm still
</I>&gt;<i> trying to figure out the architecture patters that I should follow for our design. One thing
</I>&gt;<i> that still results strange to me is that the recover operates only at a channel level and there
</I>&gt;<i> is no way to recover messages just for one queue.
</I>
Well that's because recover operates at the channel level, not the queue
level, and that's a design. Really, not many people use recover and not
just because of the reasons you've come across. Also, I would generally
advise that you create new channels for each subscription to a queue you
make - it's not necessary, by any means, but it does keep things like
this a little simpler.

I'm glad the recover with requeue=true worked for you.

Matthew


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006784.html">[rabbitmq-discuss] Old consumer tags delivered after	re-subscribing to a queue
</A></li>
	<LI>Next message: <A HREF="006789.html">[rabbitmq-discuss] Old consumer tags delivered after re-subscribing to a queue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6785">[ date ]</a>
              <a href="thread.html#6785">[ thread ]</a>
              <a href="subject.html#6785">[ subject ]</a>
              <a href="author.html#6785">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
