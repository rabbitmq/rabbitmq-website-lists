<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Messages disappearing
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Messages%20disappearing&In-Reply-To=%3CF3E9C1826A037A4A84F4D58424D54D7B02E19D4A%40AMSPRD0302MB111.eurprd03.prod.outlook.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016340.html">
   <LINK REL="Next"  HREF="016365.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Messages disappearing</H1>
    <B>Nick Pateman</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Messages%20disappearing&In-Reply-To=%3CF3E9C1826A037A4A84F4D58424D54D7B02E19D4A%40AMSPRD0302MB111.eurprd03.prod.outlook.com%3E"
       TITLE="[rabbitmq-discuss] Messages disappearing">nick.pateman at certivox.com
       </A><BR>
    <I>Fri Nov 18 13:35:46 GMT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="016340.html">[rabbitmq-discuss] Messages disappearing
</A></li>
        <LI>Next message: <A HREF="016365.html">[rabbitmq-discuss] Messages disappearing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16361">[ date ]</a>
              <a href="thread.html#16361">[ thread ]</a>
              <a href="subject.html#16361">[ subject ]</a>
              <a href="author.html#16361">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hey Simon,

I do have message receipt code but I'm not actually running it yet, it's in a completely separate application I'm developing and It's definitely not loaded yet.  The code for my message sending application, which is the only one that I am currently running at the moment is....


#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;syslog.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdint.h&gt;
#include &lt;amqp.h&gt;
#include &lt;amqp_framing.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;

#define SUMMARY_EVERY_US 1000000

const amqp_bytes_t amqp_empty_bytes = { 0, NULL };
const amqp_table_t amqp_empty_table = { 0, NULL };

uint64_t now_microseconds(void)
{
  struct timeval tv;
  gettimeofday(&amp;tv, NULL);
  return (uint64_t) tv.tv_sec * 1000000 + (uint64_t) tv.tv_usec;
}

void microsleep(int usec)
{
  usleep(usec);
}

void die_on_error(int x, char const *context) {
  if (x &lt; 0) {
    char *errstr = amqp_error_string(-x);
    fprintf(stderr, &quot;%s: %s\n&quot;, context, errstr);
    free(errstr);
    exit(1);
  }
}

void die_on_amqp_error(amqp_rpc_reply_t x, char const *context) {
  switch (x.reply_type) {
    case AMQP_RESPONSE_NORMAL:
      return;

    case AMQP_RESPONSE_NONE:
      fprintf(stderr, &quot;%s: missing RPC reply type!\n&quot;, context);
      break;

    case AMQP_RESPONSE_LIBRARY_EXCEPTION:
      fprintf(stderr, &quot;%s: %s\n&quot;, context, amqp_error_string(x.library_error));
      break;

    case AMQP_RESPONSE_SERVER_EXCEPTION:
      switch (x.reply.id) {
	case AMQP_CONNECTION_CLOSE_METHOD: {
	  amqp_connection_close_t *m = (amqp_connection_close_t *) x.reply.decoded;
	  fprintf(stderr, &quot;%s: server connection error %d, message: %.*s\n&quot;,
		  context,
		  m-&gt;reply_code,
		  (int) m-&gt;reply_text.len, (char *) m-&gt;reply_text.bytes);
	  break;  FILE* pFilFile = fopen(&quot;cekencapsulatereq.js&quot;, &quot;r&quot;);
	}
	case AMQP_CHANNEL_CLOSE_METHOD: {
	  amqp_channel_close_t *m = (amqp_channel_close_t *) x.reply.decoded;
	  fprintf(stderr, &quot;%s: server channel error %d, message: %.*s\n&quot;,
		  context,
		  m-&gt;reply_code,
		  (int) m-&gt;reply_text.len, (char *) m-&gt;reply_text.bytes);
	  break;
	}
	default:
	  fprintf(stderr, &quot;%s: unknown server error, method id 0x%08X\n&quot;, context, x.reply.id);
	  break;
      }
      break;
  }

  exit(1);
}

static void dump_row(long count, int numinrow, int *chs) {
  int i;

  printf(&quot;%08lX:&quot;, count - numinrow);

  if (numinrow &gt; 0) {
    for (i = 0; i &lt; numinrow; i++) {
      if (i == 8)
	printf(&quot; :&quot;);
      printf(&quot; %02X&quot;, chs[i]);
    }
    for (i = numinrow; i &lt; 16; i++) {
      if (i == 8)
	printf(&quot; :&quot;);
      printf(&quot;   &quot;);
    }
    printf(&quot;  &quot;);
    for (i = 0; i &lt; numinrow; i++) {
      if (isprint(chs[i]))
	printf(&quot;%c&quot;, chs[i]);
      else
	printf(&quot;.&quot;);
    }
  }
  printf(&quot;\n&quot;);
}

static int rows_eq(int *a, int *b) {
  int i;

  for (i=0; i&lt;16; i++)
    if (a[i] != b[i])
      return 0;

  return 1;
}

void amqp_dump(void const *buffer, size_t len) {
  unsigned char *buf = (unsigned char *) buffer;
  long count = 0;
  int numinrow = 0;
  int chs[16];
  int oldchs[16];
  int showed_dots = 0;
  int i;

  for (i = 0; i &lt; len; i++) {
    int ch = buf[i];

    if (numinrow == 16) {
      int i;

      if (rows_eq(oldchs, chs)) {
	if (!showed_dots) {
	  showed_dots = 1;
	  printf(&quot;          .. .. .. .. .. .. .. .. : .. .. .. .. .. .. .. ..\n&quot;);
	}
      } else {
	showed_dots = 0;
	dump_row(count, numinrow, chs);
      }

      for (i=0; i&lt;16; i++)
	oldchs[i] = chs[i];

      numinrow = 0;
    }

    count++;
    chs[numinrow++] = ch;
  }

  dump_row(count, numinrow, chs);

  if (numinrow != 0)
    printf(&quot;%08lX:\n&quot;, count);
}

/**************************************************************************
    Function: main

    Description:
        The c standard 'main' entry point function.

    Returns:
        returns integer which is passed back to the parent process
**************************************************************************/
int main(int argc, char *argv[]) {

    char const *hostname;
    int port;
    char const *exchange;
    char const *bindingkey;

    int sockfd;
    amqp_connection_state_t conn;

    amqp_bytes_t queuename = amqp_cstring_bytes(&quot;testing&quot;);

    hostname = &quot;localhost&quot;;
    port = 5672;

    conn = amqp_new_connection();

    die_on_error(sockfd = amqp_open_socket(hostname, port),
    		&quot;Opening socket&quot;);

    amqp_set_sockfd(conn, sockfd);
    die_on_amqp_error(amqp_login(conn, &quot;/&quot;, 0, 131072, 0, AMQP_SASL_METHOD_PLAIN, &quot;guest&quot;, &quot;guest&quot;),
  		    &quot;Logging in&quot;);

    amqp_channel_open(conn, 1);
    die_on_amqp_error(amqp_get_rpc_reply(conn),
    		&quot;Opening channel&quot;);

    amqp_basic_consume(conn, 1, queuename, amqp_empty_bytes, 0, 0, 0, amqp_empty_table);
    die_on_amqp_error(amqp_get_rpc_reply(conn),
    		&quot;Consuming&quot;);

    //****************************************************
    // TODO: Insert core of your message queueing code here
    //****************************************************
    send_batch(conn, (char*)queuename.bytes, 10, 1000);

    //****************************************************
    // TODO: Free any allocated resources before exiting
    //****************************************************
    die_on_amqp_error(amqp_channel_close(conn, 1, AMQP_REPLY_SUCCESS),
    		&quot;Closing channel&quot;);

    die_on_amqp_error(amqp_connection_close(conn, AMQP_REPLY_SUCCESS),
    		&quot;Closing connection&quot;);

    die_on_error(amqp_destroy_connection(conn),
    		&quot;Ending connection&quot;);

    exit(0);
}

void send_batch(amqp_connection_state_t conn,
		       char const *queue_name,
		       int rate_limit,
		       int message_count)
{
  uint64_t start_time = now_microseconds();
  int i;
  int sent = 0;
  int previous_sent = 0;
  uint64_t previous_report_time = start_time;
  uint64_t next_summary_time = start_time + SUMMARY_EVERY_US;

  for (i = 0; i &lt; message_count; i++) {
    uint64_t now = now_microseconds();

    amqp_basic_properties_t props;
    props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG | AMQP_BASIC_DELIVERY_MODE_FLAG;
    props.content_type = amqp_cstring_bytes(&quot;text/plain&quot;);
    props.delivery_mode = 2; /* persistent delivery mode */
    die_on_error(amqp_basic_publish(conn,
    		1,
    		amqp_cstring_bytes(&quot;&quot;),
    		amqp_cstring_bytes(queue_name),
    		0,
    		0,
    		&amp;props,
    		amqp_cstring_bytes(&quot;Hello world!&quot;)),
    		&quot;Publishing&quot;);

    sent++;
    if (now &gt; next_summary_time) {
      int countOverInterval = sent - previous_sent;
      double intervalRate = countOverInterval / ((now - previous_report_time) / 1000000.0);
      printf(&quot;%d ms: Sent %d - %d since last report (%d Hz)\n&quot;,
	     (int)(now - start_time) / 1000, sent, countOverInterval, (int) intervalRate);

      previous_sent = sent;
      previous_report_time = now;
      next_summary_time += SUMMARY_EVERY_US;
    }

    while (((i * 1000000.0) / (now - start_time)) &gt; rate_limit) {
      microsleep(20  FILE* pFilFile = fopen(&quot;cekencapsulatereq.js&quot;, &quot;r&quot;);00);
      now = now_microseconds();
    }
  }

  {
    uint64_t stop_time = now_microseconds();
    int total_delta = stop_time - start_time;

    printf(&quot;PRODUCER - Message count: %d\n&quot;, message_count);
    printf(&quot;Total time, milliseconds: %d\n&quot;, total_delta / 1000);
    printf(&quot;Overall messages-per-second: %g\n&quot;, (message_count / (total_delta / 1000000.0)));
  }
}



-----Original Message-----
From: <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss-bounces at lists.rabbitmq.com</A> [mailto:<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss-bounces at lists.rabbitmq.com</A>] On Behalf Of Simon MacMullen
Sent: 17 November 2011 15:44
To: <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
Subject: Re: [rabbitmq-discuss] Messages disappearing

On 17/11/11 15:38, Nick Pateman wrote:
&gt;<i> I've set no_ack to 0 in my amq_basic_consume call and the messages are 
</I>&gt;<i> now appearing in the queue but as unacknowledged.
</I>
So all this sounds like the messages are being sent to your application:

no_ack = 1 -&gt; messages are sent to your app, RabbitMQ forgets about them immediately.

no_ack = 0 -&gt; messages are sent to your app, RabbitMQ treats them as unacknowledged until you ack.

The source code you posted doesn't show any code that actually handles received message frames - you do have some right?

Can you post your whole source somewhere? It's quite difficult to tell what is going on looking at fragments.

Cheers, Simon

--
Simon MacMullen
RabbitMQ, VMware
_______________________________________________
rabbitmq-discuss mailing list
<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>


</PRE>





























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016340.html">[rabbitmq-discuss] Messages disappearing
</A></li>
	<LI>Next message: <A HREF="016365.html">[rabbitmq-discuss] Messages disappearing
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16361">[ date ]</a>
              <a href="thread.html#16361">[ thread ]</a>
              <a href="subject.html#16361">[ subject ]</a>
              <a href="author.html#16361">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
