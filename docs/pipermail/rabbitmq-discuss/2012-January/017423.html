<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Clarification on semantics of publisher	confirms
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Clarification%20on%20semantics%20of%20publisher%0A%09confirms&In-Reply-To=%3C4F155C00.8070202%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017413.html">
   <LINK REL="Next"  HREF="017414.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Clarification on semantics of publisher	confirms</H1>
    <B>Simon MacMullen</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Clarification%20on%20semantics%20of%20publisher%0A%09confirms&In-Reply-To=%3C4F155C00.8070202%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] Clarification on semantics of publisher	confirms">simon at rabbitmq.com
       </A><BR>
    <I>Tue Jan 17 11:31:12 GMT 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="017413.html">[rabbitmq-discuss] Clarification on semantics of publisher confirms
</A></li>
        <LI>Next message: <A HREF="017414.html">[rabbitmq-discuss] X-expires not working in 0-8-0 clients
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17423">[ date ]</a>
              <a href="thread.html#17423">[ thread ]</a>
              <a href="subject.html#17423">[ subject ]</a>
              <a href="author.html#17423">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 16/01/12 22:12, Simone Busoli wrote:
&gt;<i> Hi, while using the Federation plugin with publisher confirms during
</I>&gt;<i> some load tests I noticed a behavior I wasn't expecting after the link
</I>&gt;<i> between two brokers with a federated exchange went down:
</I>
Hi Simone.

&gt;<i>     * The link stayed down for several hours, and around 100k messages
</I>&gt;<i>       accumulated on the upstream broker
</I>
I hope you mean &quot;The network was down for several hours&quot; not &quot;RabbitMQ 
took several hours to re-establish the link&quot;.

&gt;<i>     * The upstream kept publishing messages at a rate of 10/s during the
</I>&gt;<i>       network failure
</I>&gt;<i>     * The downstream had 5 channels with consumers consuming each from a
</I>&gt;<i>       queue
</I>&gt;<i>     * Every queue/exchange is durable messages are persistent and
</I>&gt;<i>       autoack is off on the clients
</I>&gt;<i>     * Using the default unbounded prefetch thresholds both for the
</I>&gt;<i>       federation and the client channels
</I>&gt;<i>
</I>&gt;<i> Once the connection has restored I noticed several things:
</I>&gt;<i>
</I>&gt;<i>     * the upstream started delivering messages to the downstream,
</I>&gt;<i>       apparently overflowing it since its CPU stayed at 100% for several
</I>&gt;<i>       minutes
</I>&gt;<i>     * none of the clients connected to the downstream received anything
</I>&gt;<i>       for quite some time, not sure when they exactly started receiving
</I>&gt;<i>       messages
</I>&gt;<i>     * the UI interface kept showing lots of undelivered and unconfirmed
</I>&gt;<i>       messages on the federation outbound queue
</I>
It is currently possible to overload a RabbitMQ server by sending it a 
huge number of small messages very fast. The symptoms are as you 
describe (since the messages get backed up before they get to a queue in 
the downstream broker). Eventually if you keep sending messages the 
memory alarm will go off and then the broker will have time to sort 
itself out, but this can lead to quite a delay.

We're looking to improve this situation in the next release.

&gt;<i> After some time, around two hours, the upstream broker completed
</I>&gt;<i> delivering all the messages to the downstream and the downstream
</I>&gt;<i> confirmed all of them. The clients are currently still catching up with
</I>&gt;<i> the backlog.
</I>
However, I'm surprised that it took two hours to churn through just 100k 
messages. That should be a few seconds worth on average hardware. Was 
the downstream broker particularly small?

&gt;<i> Now any insight in what RabbitMQ was actually doing during this time is
</I>&gt;<i> appreciated, but I am specifically interested in how publisher confirms
</I>&gt;<i> behave in general. From the docs:
</I>&gt;<i>
</I>&gt;<i> Persistent messages are confirmed when all queues have either delivered
</I>&gt;<i> the message and received an acknowledgement (if required), or persisted
</I>&gt;<i> the message
</I>&gt;<i>
</I>&gt;<i> What is not clear to me is whether there is a chance for one or more
</I>&gt;<i> slow consumers, as in this case, to slow down the entire federation due
</I>&gt;<i> to the downstream broker waiting for their acknowledge for delivered
</I>&gt;<i> messages, which they are not able to give soon as they are still trying
</I>&gt;<i> to catch up with the backlog. So if the federation uses publisher
</I>&gt;<i> confirms and the downstream is not acking messages to the upstream
</I>&gt;<i> because the clients have not all acknowledge them, then also the
</I>&gt;<i> upstream will be slowed down and its outbound queue not emptied as long
</I>&gt;<i> as consumers on the downstream ack their messages. If this is the case I
</I>&gt;<i> would think it is a bit weird for slow consumers on a broker to also
</I>&gt;<i> affect what happens on another broker.
</I>&gt;<i>
</I>&gt;<i> When and how does the broker decide whether to confirm messages because
</I>&gt;<i> they were &quot;delivered and acked&quot; or &quot;persisted&quot;? I would rather prefer it
</I>&gt;<i> did it when persisting them, rather than when delivering them to clients
</I>&gt;<i> which cannot acknowledge them in time.
</I>
The broker will deliver the message and also schedule it to be 
persisted. It will then send back a confirm when *either* it has 
received an ack from the client *or* an fsync from the disk. So slow 
consumers should not be able to slow down a federation.

So I think the problem you were seeing was due to messages building up 
before they got to the queues on the downstream broker. But I'm 
surprised only 100k messages could do this.

Cheers, Simon

-- 
Simon MacMullen
RabbitMQ, VMware
</PRE>







































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017413.html">[rabbitmq-discuss] Clarification on semantics of publisher confirms
</A></li>
	<LI>Next message: <A HREF="017414.html">[rabbitmq-discuss] X-expires not working in 0-8-0 clients
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17423">[ date ]</a>
              <a href="thread.html#17423">[ thread ]</a>
              <a href="subject.html#17423">[ subject ]</a>
              <a href="author.html#17423">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
