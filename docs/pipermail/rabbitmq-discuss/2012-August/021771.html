<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] TCP Backpressure / Flow Control in C# producer
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20TCP%20Backpressure%20/%20Flow%20Control%20in%20C%23%0A%20producer&In-Reply-To=%3C50225BB9.9010006%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="021770.html">
   <LINK REL="Next"  HREF="021772.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] TCP Backpressure / Flow Control in C# producer</H1>
    <B>Matthias Radestock</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20TCP%20Backpressure%20/%20Flow%20Control%20in%20C%23%0A%20producer&In-Reply-To=%3C50225BB9.9010006%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] TCP Backpressure / Flow Control in C# producer">matthias at rabbitmq.com
       </A><BR>
    <I>Wed Aug  8 13:29:45 BST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="021770.html">[rabbitmq-discuss] TCP Backpressure / Flow Control in C# producer
</A></li>
        <LI>Next message: <A HREF="021772.html">[rabbitmq-discuss] TCP Backpressure / Flow Control in C# producer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21771">[ date ]</a>
              <a href="thread.html#21771">[ thread ]</a>
              <a href="subject.html#21771">[ subject ]</a>
              <a href="author.html#21771">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ulli,

On 08/08/12 12:55, Ulli Berthold - Exactag GmbH wrote:
&gt;<i> well, it does happen here... There are times when our queues grow to
</I>&gt;<i> a couple of million messages (which actually was not a problem in
</I>&gt;<i> 2.7.1), in 2.8.4 it went into flow control mode when the CPU load got
</I>&gt;<i> higher though not limiting out.
</I>
When the management plug-in says that a connection is in 'flow' mode, 
that does *not* mean that it is no longer accepting messages. It only 
indicates that in the last ~10 seconds flow control got triggered at 
least once.

Also, when you say the CPU load wasn't limiting out, bear in mind that 
on a multi-core machine rabbit will not necessarily be able to utilise 
all cores - depends very much on the workload.

Are you actually experiencing publishing delays at the client?

&gt;<i> Our problem is that we constantly produce lots of messages which have
</I>&gt;<i> to be forwarded within milliseconds or we will run into frontend
</I>&gt;<i> delays which should not occur.
</I>
Yes, I understand that.

&gt;<i> I'm looking for a way to keep the queueing server accepting messages
</I>&gt;<i> at the highest possible rate no matter what, for as long as it's not
</I>&gt;<i> &quot;full&quot; (memory, disk, cpu).
</I>
One way to increase the buffering capacity is to increase the tcp buffer 
sizes in the kernel.

&gt;<i> And when we finally reach a point where the server is almost full,
</I>&gt;<i> I'd curious if the flow control events of the C# driver will ever be
</I>&gt;<i> fired? As I said, that would enable us to use a file-based fallback
</I>&gt;<i> that's mostly intended for queuing server downtimes.
</I>&gt;<i>
</I>&gt;<i> channel = connection.CreateModel(); channel.ChannelFlow(true);
</I>&gt;<i> channel.FlowControl += new
</I>&gt;<i> RabbitMQ.Client.Events.FlowControlEventHandler(channel_FlowControl);
</I>
RabbitMQ does not send channel.flow commands, so no, these events won't 
fire.

We were sending channel.flow from rabbit a few years ago but had to 
abandon that because a) it proved to be way too slow to react to 
critical server conditions, and b) many clients weren't handling 
channel.flow correctly.


I still think my client-side mini queue idea would work well for you. It 
provides a high degree of control over when to trigger a fallback 
publishing path and has the added advantage that it will also cope with 
temporary network disruptions - i.e. conditions that stall (but not 
kill) tcp connections - which no server-generated signal could do.


Regards,

Matthias.
</PRE>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="021770.html">[rabbitmq-discuss] TCP Backpressure / Flow Control in C# producer
</A></li>
	<LI>Next message: <A HREF="021772.html">[rabbitmq-discuss] TCP Backpressure / Flow Control in C# producer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21771">[ date ]</a>
              <a href="thread.html#21771">[ thread ]</a>
              <a href="subject.html#21771">[ subject ]</a>
              <a href="author.html#21771">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
