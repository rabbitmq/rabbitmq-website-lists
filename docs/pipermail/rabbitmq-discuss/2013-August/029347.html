<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Tornado Consumer example problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Tornado%20Consumer%20example%20problem&In-Reply-To=%3CCAKgmDnFLm73szhOL-heFNS1kbtjGrDZFVO33-%3DMeGCNmfBfWhA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029345.html">
   <LINK REL="Next"  HREF="029348.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Tornado Consumer example problem</H1>
    <B>Laing, Michael</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Tornado%20Consumer%20example%20problem&In-Reply-To=%3CCAKgmDnFLm73szhOL-heFNS1kbtjGrDZFVO33-%3DMeGCNmfBfWhA%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] Tornado Consumer example problem">michael.laing at nytimes.com
       </A><BR>
    <I>Thu Aug 15 15:25:23 BST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="029345.html">[rabbitmq-discuss] Tornado Consumer example problem
</A></li>
        <LI>Next message: <A HREF="029348.html">[rabbitmq-discuss] Tornado Consumer example problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29347">[ date ]</a>
              <a href="thread.html#29347">[ thread ]</a>
              <a href="subject.html#29347">[ subject ]</a>
              <a href="author.html#29347">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The connect method doesn't apear to return a connection...


On Thu, Aug 15, 2013 at 9:51 AM, Priyanki Vashi &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">vashi.priyanki at gmail.com</A>&gt;wrote:

&gt;<i> Hi ,
</I>&gt;<i>
</I>&gt;<i> on_connection_open, is a callback method, which will be called when
</I>&gt;<i> connection is opened with rabbitmq. It opens channel inturn. So it's little
</I>&gt;<i> unlikely that it has 'None' value but I am not 100% sure.
</I>&gt;<i>
</I>&gt;<i> Here is my code. Could you quickly have a look.
</I>&gt;<i> It's the same example from pika site for tornado consumer except that I
</I>&gt;<i> have tried to use connection parameters instead of URL.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> from pika import adapters
</I>&gt;<i> import pika
</I>&gt;<i> import logging
</I>&gt;<i>
</I>&gt;<i> LOG_FORMAT = ('%(levelname) -10s %(asctime)s %(name) -30s %(funcName) '
</I>&gt;<i>               '-35s %(lineno) -5d: %(message)s')
</I>&gt;<i> LOGGER = logging.getLogger(__name__)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> class ExampleConsumer(object):
</I>&gt;<i>     &quot;&quot;&quot;This is an example consumer that will handle unexpected interactions
</I>&gt;<i>     with RabbitMQ such as channel and connection closures.
</I>&gt;<i>
</I>&gt;<i>     If RabbitMQ closes the connection, it will reopen it. You should
</I>&gt;<i>     look at the output, as there are limited reasons why the connection may
</I>&gt;<i>     be closed, which usually are tied to permission related issues or
</I>&gt;<i>     socket timeouts.
</I>&gt;<i>
</I>&gt;<i>     If the channel is closed, it will indicate a problem with one of the
</I>&gt;<i>     commands that were issued and that should surface in the output as
</I>&gt;<i> well.
</I>&gt;<i>
</I>&gt;<i>     &quot;&quot;&quot;
</I>&gt;<i>     EXCHANGE = 'message'
</I>&gt;<i>     EXCHANGE_TYPE = 'topic'
</I>&gt;<i>     QUEUE = 'text'
</I>&gt;<i>     ROUTING_KEY = 'example.text'
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     def __init__(self, host, port, username, password):
</I>&gt;<i>         &quot;&quot;&quot;Setup the example publisher object, passing in the URL we will
</I>&gt;<i> use
</I>&gt;<i>         to connect to RabbitMQ.
</I>&gt;<i>
</I>&gt;<i>         :param str amqp_url: The URL for connecting to RabbitMQ
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>
</I>&gt;<i>         self._connection = None
</I>&gt;<i>         self._channel = None
</I>&gt;<i>         self._closing = False
</I>&gt;<i>         self._consumer_tag = None
</I>&gt;<i>         #self._url = amqp_url
</I>&gt;<i>
</I>&gt;<i>         self.credentials = pika.PlainCredentials(username=username,
</I>&gt;<i> password=password)
</I>&gt;<i>         self.parameters = pika.ConnectionParameters(host=host, port=port,
</I>&gt;<i> credentials=self.credentials)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>     def connect(self):
</I>&gt;<i>         &quot;&quot;&quot;This method connects to RabbitMQ, returning the connection
</I>&gt;<i> handle.
</I>&gt;<i>         When the connection is established, the on_connection_open method
</I>&gt;<i>         will be invoked by pika.
</I>&gt;<i>
</I>&gt;<i>         :rtype: pika.SelectConnection
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         #LOGGER.info('Connecting to %s', self._url)
</I>&gt;<i>         adapters.TornadoConnection(self.parameters,
</I>&gt;<i> on_open_callback=self.on_connection_open, stop_ioloop_on_close=False)
</I>&gt;<i>         #return
</I>&gt;<i> adapters.TornadoConnection(pika.URLParameters(self._url),self.on_connection_open)
</I>&gt;<i>
</I>&gt;<i>     def close_connection(self):
</I>&gt;<i>         &quot;&quot;&quot;This method closes the connection to RabbitMQ.&quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Closing connection')
</I>&gt;<i>         self._connection.close()
</I>&gt;<i>
</I>&gt;<i>     def add_on_connection_close_callback(self):
</I>&gt;<i>         &quot;&quot;&quot;This method adds an on close callback that will be invoked by
</I>&gt;<i> pika
</I>&gt;<i>         when RabbitMQ closes the connection to the publisher unexpectedly.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Adding connection close callback')
</I>&gt;<i>         self._connection.add_on_close_callback(self.on_connection_closed)
</I>&gt;<i>
</I>&gt;<i>     def on_connection_closed(self, connection, reply_code, reply_text):
</I>&gt;<i>         &quot;&quot;&quot;This method is invoked by pika when the connection to RabbitMQ
</I>&gt;<i> is
</I>&gt;<i>         closed unexpectedly. Since it is unexpected, we will reconnect to
</I>&gt;<i>         RabbitMQ if it disconnects.
</I>&gt;<i>
</I>&gt;<i>         :param pika.connection.Connection connection: The closed
</I>&gt;<i> connection obj
</I>&gt;<i>         :param int reply_code: The server provided reply_code if given
</I>&gt;<i>         :param str reply_text: The server provided reply_text if given
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         self._channel = None
</I>&gt;<i>         if self._closing:
</I>&gt;<i>             self._connection.ioloop.stop()
</I>&gt;<i>         else:
</I>&gt;<i>             LOGGER.warning('Connection closed, reopening in 5 seconds:
</I>&gt;<i> (%s) %s',
</I>&gt;<i>                            reply_code, reply_text)
</I>&gt;<i>             self._connection.add_timeout(5, self.reconnect)
</I>&gt;<i>
</I>&gt;<i>     def on_connection_open(self, unused_connection):
</I>&gt;<i>         &quot;&quot;&quot;This method is called by pika once the connection to RabbitMQ
</I>&gt;<i> has
</I>&gt;<i>         been established. It passes the handle to the connection object in
</I>&gt;<i>         case we need it, but in this case, we'll just mark it unused.
</I>&gt;<i>
</I>&gt;<i>         :type unused_connection: pika.SelectConnection
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Connection opened')
</I>&gt;<i>         self.add_on_connection_close_callback()
</I>&gt;<i>         self.open_channel()
</I>&gt;<i>
</I>&gt;<i>     def reconnect(self):
</I>&gt;<i>         &quot;&quot;&quot;Will be invoked by the IOLoop timer if the connection is
</I>&gt;<i>         closed. See the on_connection_closed method.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         # This is the old connection IOLoop instance, stop its ioloop
</I>&gt;<i>         self._connection.ioloop.stop()
</I>&gt;<i>
</I>&gt;<i>         if not self._closing:
</I>&gt;<i>
</I>&gt;<i>             # Create a new connection
</I>&gt;<i>             self._connection = self.connect()
</I>&gt;<i>
</I>&gt;<i>             # There is now a new connection, needs a new ioloop to run
</I>&gt;<i>             self._connection.ioloop.start()
</I>&gt;<i>
</I>&gt;<i>     def add_on_channel_close_callback(self):
</I>&gt;<i>         &quot;&quot;&quot;This method tells pika to call the on_channel_closed method if
</I>&gt;<i>         RabbitMQ unexpectedly closes the channel.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Adding channel close callback')
</I>&gt;<i>         self._channel.add_on_close_callback(self.on_channel_closed)
</I>&gt;<i>
</I>&gt;<i>     def on_channel_closed(self, channel, reply_code, reply_text):
</I>&gt;<i>         &quot;&quot;&quot;Invoked by pika when RabbitMQ unexpectedly closes the channel.
</I>&gt;<i>         Channels are usually closed if you attempt to do something that
</I>&gt;<i>         violates the protocol, such as re-declare an exchange or queue with
</I>&gt;<i>         different parameters. In this case, we'll close the connection
</I>&gt;<i>         to shutdown the object.
</I>&gt;<i>
</I>&gt;<i>         :param pika.channel.Channel: The closed channel
</I>&gt;<i>         :param int reply_code: The numeric reason the channel was closed
</I>&gt;<i>         :param str reply_text: The text reason the channel was closed
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.warning('Channel %i was closed: (%s) %s',
</I>&gt;<i>                        channel, reply_code, reply_text)
</I>&gt;<i>         self._connection.close()
</I>&gt;<i>
</I>&gt;<i>     def on_channel_open(self, channel):
</I>&gt;<i>         &quot;&quot;&quot;This method is invoked by pika when the channel has been opened.
</I>&gt;<i>         The channel object is passed in so we can make use of it.
</I>&gt;<i>
</I>&gt;<i>         Since the channel is now open, we'll declare the exchange to use.
</I>&gt;<i>
</I>&gt;<i>         :param pika.channel.Channel channel: The channel object
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Channel opened')
</I>&gt;<i>         self._channel = channel
</I>&gt;<i>         self.add_on_channel_close_callback()
</I>&gt;<i>         self.setup_exchange(self.EXCHANGE)
</I>&gt;<i>
</I>&gt;<i>     def setup_exchange(self, exchange_name):
</I>&gt;<i>         &quot;&quot;&quot;Setup the exchange on RabbitMQ by invoking the Exchange.Declare
</I>&gt;<i> RPC
</I>&gt;<i>         command. When it is complete, the on_exchange_declareok method will
</I>&gt;<i>         be invoked by pika.
</I>&gt;<i>
</I>&gt;<i>         :param str|unicode exchange_name: The name of the exchange to
</I>&gt;<i> declare
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Declaring exchange %s', exchange_name)
</I>&gt;<i>         self._channel.exchange_declare(self.on_exchange_declareok,
</I>&gt;<i>                                        exchange_name,
</I>&gt;<i>                                        self.EXCHANGE_TYPE)
</I>&gt;<i>
</I>&gt;<i>     def on_exchange_declareok(self, unused_frame):
</I>&gt;<i>         &quot;&quot;&quot;Invoked by pika when RabbitMQ has finished the Exchange.Declare
</I>&gt;<i> RPC
</I>&gt;<i>         command.
</I>&gt;<i>
</I>&gt;<i>         :param pika.Frame.Method unused_frame: Exchange.DeclareOk response
</I>&gt;<i> frame
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Exchange declared')
</I>&gt;<i>         self.setup_queue(self.QUEUE)
</I>&gt;<i>
</I>&gt;<i>     def setup_queue(self, queue_name):
</I>&gt;<i>         &quot;&quot;&quot;Setup the queue on RabbitMQ by invoking the Queue.Declare RPC
</I>&gt;<i>         command. When it is complete, the on_queue_declareok method will
</I>&gt;<i>         be invoked by pika.
</I>&gt;<i>
</I>&gt;<i>         :param str|unicode queue_name: The name of the queue to declare.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Declaring queue %s', queue_name)
</I>&gt;<i>         self._channel.queue_declare(self.on_queue_declareok, queue_name)
</I>&gt;<i>
</I>&gt;<i>     def on_queue_declareok(self, method_frame):
</I>&gt;<i>         &quot;&quot;&quot;Method invoked by pika when the Queue.Declare RPC call made in
</I>&gt;<i>         setup_queue has completed. In this method we will bind the queue
</I>&gt;<i>         and exchange together with the routing key by issuing the
</I>&gt;<i> Queue.Bind
</I>&gt;<i>         RPC command. When this command is complete, the on_bindok method
</I>&gt;<i> will
</I>&gt;<i>         be invoked by pika.
</I>&gt;<i>
</I>&gt;<i>         :param pika.frame.Method method_frame: The Queue.DeclareOk frame
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Binding %s to %s with %s',
</I>&gt;<i>                     self.EXCHANGE, self.QUEUE, self.ROUTING_KEY)
</I>&gt;<i>         self._channel.queue_bind(self.on_bindok, self.QUEUE,
</I>&gt;<i>                                  self.EXCHANGE, self.ROUTING_KEY)
</I>&gt;<i>
</I>&gt;<i>     def add_on_cancel_callback(self):
</I>&gt;<i>         &quot;&quot;&quot;Add a callback that will be invoked if RabbitMQ cancels the
</I>&gt;<i> consumer
</I>&gt;<i>         for some reason. If RabbitMQ does cancel the consumer,
</I>&gt;<i>         on_consumer_cancelled will be invoked by pika.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Adding consumer cancellation callback')
</I>&gt;<i>         self._channel.add_on_cancel_callback(self.on_consumer_cancelled)
</I>&gt;<i>
</I>&gt;<i>     def on_consumer_cancelled(self, method_frame):
</I>&gt;<i>         &quot;&quot;&quot;Invoked by pika when RabbitMQ sends a Basic.Cancel for a
</I>&gt;<i> consumer
</I>&gt;<i>         receiving messages.
</I>&gt;<i>
</I>&gt;<i>         :param pika.frame.Method method_frame: The Basic.Cancel frame
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Consumer was cancelled remotely, shutting down: %r',
</I>&gt;<i>                     method_frame)
</I>&gt;<i>         if self._channel:
</I>&gt;<i>             self._channel.close()
</I>&gt;<i>
</I>&gt;<i>     def acknowledge_message(self, delivery_tag):
</I>&gt;<i>         &quot;&quot;&quot;Acknowledge the message delivery from RabbitMQ by sending a
</I>&gt;<i>         Basic.Ack RPC method for the delivery tag.
</I>&gt;<i>
</I>&gt;<i>         :param int delivery_tag: The delivery tag from the Basic.Deliver
</I>&gt;<i> frame
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Acknowledging message %s', delivery_tag)
</I>&gt;<i>         self._channel.basic_ack(delivery_tag)
</I>&gt;<i>
</I>&gt;<i>     def on_message(self, unused_channel, basic_deliver, properties, body):
</I>&gt;<i>         &quot;&quot;&quot;Invoked by pika when a message is delivered from RabbitMQ. The
</I>&gt;<i>         channel is passed for your convenience. The basic_deliver object
</I>&gt;<i> that
</I>&gt;<i>         is passed in carries the exchange, routing key, delivery tag and
</I>&gt;<i>         a redelivered flag for the message. The properties passed in is an
</I>&gt;<i>         instance of BasicProperties with the message properties and the
</I>&gt;<i> body
</I>&gt;<i>         is the message that was sent.
</I>&gt;<i>
</I>&gt;<i>         :param pika.channel.Channel unused_channel: The channel object
</I>&gt;<i>         :param pika.Spec.Basic.Deliver: basic_deliver method
</I>&gt;<i>         :param pika.Spec.BasicProperties: properties
</I>&gt;<i>         :param str|unicode body: The message body
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Received message # %s from %s: %s',
</I>&gt;<i>                     basic_deliver.delivery_tag, properties.app_id, body)
</I>&gt;<i>         self.acknowledge_message(basic_deliver.delivery_tag)
</I>&gt;<i>
</I>&gt;<i>     def on_cancelok(self, unused_frame):
</I>&gt;<i>         &quot;&quot;&quot;This method is invoked by pika when RabbitMQ acknowledges the
</I>&gt;<i>         cancellation of a consumer. At this point we will close the
</I>&gt;<i> channel.
</I>&gt;<i>         This will invoke the on_channel_closed method once the channel has
</I>&gt;<i> been
</I>&gt;<i>         closed, which will in-turn close the connection.
</I>&gt;<i>
</I>&gt;<i>         :param pika.frame.Method unused_frame: The Basic.CancelOk frame
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('RabbitMQ acknowledged the cancellation of the
</I>&gt;<i> consumer')
</I>&gt;<i>         self.close_channel()
</I>&gt;<i>
</I>&gt;<i>     def stop_consuming(self):
</I>&gt;<i>         &quot;&quot;&quot;Tell RabbitMQ that you would like to stop consuming by sending
</I>&gt;<i> the
</I>&gt;<i>         Basic.Cancel RPC command.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         if self._channel:
</I>&gt;<i>             LOGGER.info('Sending a Basic.Cancel RPC command to RabbitMQ')
</I>&gt;<i>             self._channel.basic_cancel(self.on_cancelok,
</I>&gt;<i> self._consumer_tag)
</I>&gt;<i>
</I>&gt;<i>     def start_consuming(self):
</I>&gt;<i>         &quot;&quot;&quot;This method sets up the consumer by first calling
</I>&gt;<i>         add_on_cancel_callback so that the object is notified if RabbitMQ
</I>&gt;<i>         cancels the consumer. It then issues the Basic.Consume RPC command
</I>&gt;<i>         which returns the consumer tag that is used to uniquely identify
</I>&gt;<i> the
</I>&gt;<i>         consumer with RabbitMQ. We keep the value to use it when we want to
</I>&gt;<i>         cancel consuming. The on_message method is passed in as a callback
</I>&gt;<i> pika
</I>&gt;<i>         will invoke when a message is fully received.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Issuing consumer related RPC commands')
</I>&gt;<i>         self.add_on_cancel_callback()
</I>&gt;<i>         self._consumer_tag = self._channel.basic_consume(self.on_message,
</I>&gt;<i>                                                          self.QUEUE)
</I>&gt;<i>
</I>&gt;<i>      def on_bindok(self, unused_frame):
</I>&gt;<i>         &quot;&quot;&quot;Invoked by pika when the Queue.Bind method has completed. At
</I>&gt;<i> this
</I>&gt;<i>         point we will start consuming messages by calling start_consuming
</I>&gt;<i>         which will invoke the needed RPC commands to start the process.
</I>&gt;<i>
</I>&gt;<i>         :param pika.frame.Method unused_frame: The Queue.BindOk response
</I>&gt;<i> frame
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Queue bound')
</I>&gt;<i>         self.start_consuming()
</I>&gt;<i>
</I>&gt;<i>     def close_channel(self):
</I>&gt;<i>         &quot;&quot;&quot;Call to close the channel with RabbitMQ cleanly by issuing the
</I>&gt;<i>         Channel.Close RPC command.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Closing the channel')
</I>&gt;<i>         self._channel.close()
</I>&gt;<i>
</I>&gt;<i>     def open_channel(self):
</I>&gt;<i>         &quot;&quot;&quot;Open a new channel with RabbitMQ by issuing the Channel.Open RPC
</I>&gt;<i>         command. When RabbitMQ responds that the channel is open, the
</I>&gt;<i>         on_channel_open callback will be invoked by pika.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Creating a new channel')
</I>&gt;<i>         self._connection.channel(on_open_callback=self.on_channel_open)
</I>&gt;<i>
</I>&gt;<i>     def run(self):
</I>&gt;<i>         &quot;&quot;&quot;Run the example consumer by connecting to RabbitMQ and then
</I>&gt;<i>         starting the IOLoop to block and allow the SelectConnection to
</I>&gt;<i> operate.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         self._connection = self.connect()
</I>&gt;<i>         self._connection.ioloop.start()
</I>&gt;<i>
</I>&gt;<i>     def stop(self):
</I>&gt;<i>         &quot;&quot;&quot;Cleanly shutdown the connection to RabbitMQ by stopping the
</I>&gt;<i> consumer
</I>&gt;<i>         with RabbitMQ. When RabbitMQ confirms the cancellation, on_cancelok
</I>&gt;<i>         will be invoked by pika, which will then closing the channel and
</I>&gt;<i>         connection. The IOLoop is started again because this method is
</I>&gt;<i> invoked
</I>&gt;<i>         when CTRL-C is pressed raising a KeyboardInterrupt exception. This
</I>&gt;<i>         exception stops the IOLoop which needs to be running for pika to
</I>&gt;<i>         communicate with RabbitMQ. All of the commands issued prior to
</I>&gt;<i> starting
</I>&gt;<i>         the IOLoop will be buffered but not processed.
</I>&gt;<i>
</I>&gt;<i>         &quot;&quot;&quot;
</I>&gt;<i>         LOGGER.info('Stopping')
</I>&gt;<i>         self._closing = True
</I>&gt;<i>         self.stop_consuming()
</I>&gt;<i>         self._connection.ioloop.start()
</I>&gt;<i>         LOGGER.info('Stopped')
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> def main():
</I>&gt;<i>     logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
</I>&gt;<i>     example = ExampleConsumer('mqserver10', 5672, 'guest', 'guest')
</I>&gt;<i>     try:
</I>&gt;<i>         example.run()
</I>&gt;<i>     except KeyboardInterrupt:
</I>&gt;<i>         example.stop()
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> if __name__ == '__main__':
</I>&gt;<i>     main()
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Thu, Aug 15, 2013 at 3:25 PM, Ask Solem &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ask at rabbitmq.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Aug 15, 2013, at 1:20 PM, Priyanki Vashi &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">vashi.priyanki at gmail.com</A>&gt;
</I>&gt;&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; Hi There ,
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; This might be very basic error but since I am trying to use Tornado
</I>&gt;&gt;<i> connection for the first time, help on this would be appreciated.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; I was trying to use Tornado consumer example given on following pika
</I>&gt;&gt;<i> site.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; <A HREF="https://pika.readthedocs.org/en/0.9.13/examples/tornado_consumer.html">https://pika.readthedocs.org/en/0.9.13/examples/tornado_consumer.html</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; I am running into following error. The example is with URL connection
</I>&gt;&gt;<i> method.
</I>&gt;&gt;<i> &gt; But I also tried to use hostname and port method as well as tried
</I>&gt;&gt;<i> changing to IP address instead of hostname but still it's the same error.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; I have pika 0.9.13 library installed. My consumer &amp; Producer works fine
</I>&gt;&gt;<i> with select.connection method so I believe library is correctly installed.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Do I need to do something additional to get tornado connection working
</I>&gt;&gt;<i> for both producer and consumer with pika?
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Please suggest.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">mq1 at mqserver1</A>:~/Producer_Receiver/Latest$ python tornedo_c_1.py
</I>&gt;&gt;<i> &gt; Traceback (most recent call last):
</I>&gt;&gt;<i> &gt;   File &quot;tornedo_c_1.py&quot;, line 357, in &lt;module&gt;
</I>&gt;&gt;<i> &gt;     main()
</I>&gt;&gt;<i> &gt;   File &quot;tornedo_c_1.py&quot;, line 351, in main
</I>&gt;&gt;<i> &gt;     example.run()
</I>&gt;&gt;<i> &gt;   File &quot;tornedo_c_1.py&quot;, line 326, in run
</I>&gt;&gt;<i> &gt;     self._connection = self.connect()
</I>&gt;&gt;<i> &gt;   File &quot;tornedo_c_1.py&quot;, line 59, in connect
</I>&gt;&gt;<i> &gt;     adapters.TornadoConnection(self.parameters,
</I>&gt;&gt;<i> self.on_connection_open, stop_ioloop_on_close=False)
</I>&gt;&gt;<i> &gt; TypeError: 'NoneType' object is not callable
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Maybe you passed None as a callback somewhere?  What is the value of
</I>&gt;&gt;<i> on_connection_open for example?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> rabbitmq-discuss mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130815/63ba333b/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130815/63ba333b/attachment.htm</A>&gt;
</PRE>


























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029345.html">[rabbitmq-discuss] Tornado Consumer example problem
</A></li>
	<LI>Next message: <A HREF="029348.html">[rabbitmq-discuss] Tornado Consumer example problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29347">[ date ]</a>
              <a href="thread.html#29347">[ thread ]</a>
              <a href="subject.html#29347">[ subject ]</a>
              <a href="author.html#29347">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
