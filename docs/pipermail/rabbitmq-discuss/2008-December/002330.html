<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] [Q] best way to add a sequencer to the broker
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20%5BQ%5D%20best%20way%20to%20add%20a%20sequencer%20to%20the%20broker&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002329.html">
   <LINK REL="Next"  HREF="002331.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] [Q] best way to add a sequencer to the broker</H1>
    <B>Chuck Remes</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20%5BQ%5D%20best%20way%20to%20add%20a%20sequencer%20to%20the%20broker&In-Reply-To="
       TITLE="[rabbitmq-discuss] [Q] best way to add a sequencer to the broker">cremes.devlist at mac.com
       </A><BR>
    <I>Mon Dec 29 14:04:21 GMT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="002329.html">[rabbitmq-discuss] [A] compiling java client lib fails on OSX
</A></li>
        <LI>Next message: <A HREF="002331.html">[rabbitmq-discuss] [Q] best way to add a sequencer to the broker
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2330">[ date ]</a>
              <a href="thread.html#2330">[ thread ]</a>
              <a href="subject.html#2330">[ subject ]</a>
              <a href="author.html#2330">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>In my application I would like to stamp each message on the bus with a  
sequence number. Doing so allows me to replay events in order (amongst  
other benefits). Some services will be publishing latency-sensitive  
information.

Each service connecting to the broker will publish to a topic  
exchange. One to N other services may subscribe to the published data.  
I foresee a topic hierarchy like so:

out.topic1 (passive, durable)
out.topic2 (passive, non-durable)
out.topic3.subtopic1 (passive, non-durable)
out.topic3.subtopic2 (passive, durable)
etc.

These exchanges are named with dot notation for simplicity of parsing  
for regular expressions. I realize the exchange name doesn't need the  
dot notation whereas that is a requirement for routing keys.

All of my data is serialized as a JSON object prior to publishing. The  
object (hash) contains a key called :sequence which is set to 0 by the  
publisher. The sequencer service will subscribe to all out.# topics  
(with '#' as the routing key so it gets everything), read the content  
body as a Map, and set the map :sequence value to i++ where 'i' is a  
32-bit (or 64-bit) integer. It will then republish the JSON object to  
a new topic of the form &quot;in.topicX&quot; and pass through the original  
routing key. It's routing between, for example, out.topic1 and  
in.topic1 and adding a sequence number as a side effect.

I played around with the examples SimpleTopicPublisher and  
SimpleTopicConsumer as a basis for a new class. I was able to add a  
JSONReader and JSONWriter to the new java class I call Sequencer. It  
successfully performs the work as described in the prior paragraph.  
RIght now I statically declare the in &amp; out exchanges, but I see how I  
could declare the &quot;in&quot; exchange based on the contents of the &quot;out&quot;  
exchange name received in the envelope.

I have a few outstanding questions that I'm hoping some more  
experienced folks can help answer.

1. This code will likely start before other services, so it will  
declare the exchanges and block on them while waiting for traffic. The  
topic Consumer/Producer examples all illustrate how to do this with a  
single exchange. How do I accomplish this task with multiple  
exchanges? Do I need a separate thread and channel for each exchange?

2. Is there a better way to accomplish this task? I've read some notes  
about future releases of rabbitmq allowing for &quot;internal&quot; clients that  
run inside the rabbitmq memory space. I think this is an ideal use of  
that capability. Am I right or barking up the wrong tree? And does  
that internal client need to be written in erlang or can it be java/c/ 
whatever?

3. Is there a way to make this more dynamic so I do not have to  
declare all the exchanges up-front in this sequencer code? Ideally  
this service could detect that new exchanges were declared by other  
services and automatically subscribe to them to do the sequence  
stamping and routing.

Thanks for any feedback.

cr



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002329.html">[rabbitmq-discuss] [A] compiling java client lib fails on OSX
</A></li>
	<LI>Next message: <A HREF="002331.html">[rabbitmq-discuss] [Q] best way to add a sequencer to the broker
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2330">[ date ]</a>
              <a href="thread.html#2330">[ thread ]</a>
              <a href="subject.html#2330">[ subject ]</a>
              <a href="author.html#2330">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
