<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] [java-client] Parallelizing message consumption from a single queue
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20%5Bjava-client%5D%20Parallelizing%20message%0A%20consumption%20from%20a%20single%20queue&In-Reply-To=%3C25697157.291.1332805747355.JavaMail.geo-discussion-forums%40pbcvg9%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019132.html">
   <LINK REL="Next"  HREF="019187.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] [java-client] Parallelizing message consumption from a single queue</H1>
    <B>Josh Stone</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20%5Bjava-client%5D%20Parallelizing%20message%0A%20consumption%20from%20a%20single%20queue&In-Reply-To=%3C25697157.291.1332805747355.JavaMail.geo-discussion-forums%40pbcvg9%3E"
       TITLE="[rabbitmq-discuss] [java-client] Parallelizing message consumption from a single queue">pacesysjosh at gmail.com
       </A><BR>
    <I>Tue Mar 27 00:49:07 BST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="019132.html">[rabbitmq-discuss] [java-client] Parallelizing message	consumption from a single queue
</A></li>
        <LI>Next message: <A HREF="019187.html">[rabbitmq-discuss] [java-client] Parallelizing message	consumption from a single queue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19150">[ date ]</a>
              <a href="thread.html#19150">[ thread ]</a>
              <a href="subject.html#19150">[ subject ]</a>
              <a href="author.html#19150">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for the response. My response is inline below:

On Monday, March 26, 2012 7:11:13 AM UTC-7, Steve Powell wrote:
&gt;<i>
</I>&gt;<i> Hi Josh,
</I>&gt;<i>
</I>&gt;<i> In the absence of the experts -- you get me :-)
</I>&gt;<i>
</I>&gt;<i> Questions that start 'what is the best way to...' often have no
</I>&gt;<i> definitive answer, I'm afraid; but here goes.
</I>&gt;<i>
</I>&gt;<i> First, I'm going to have to explain what I *think* you are asking about,
</I>&gt;<i> before trying to answer it.
</I>&gt;<i>
</I>&gt;<i>   I assume you are asking about multiple Consumers, in a Java client, all
</I>&gt;<i>   consuming from the same queue, allowing 'parallel' consumption -- which
</I>&gt;<i>   I take to mean multi-threaded -- within the same Java client. You want
</I>&gt;<i>   the 'best' application structure which achieves 'parallel' processing of 
</I>&gt;<i>   messages from the queue.
</I>&gt;<i>
</I>Yes - I have one client that is consuming from a single queue, and 
basically want to achieve the best throughput possible, whatever that means 
in terms of one or more connections, channels, consumers, and threads 
making use of these. This is the part I'm not sure about.
 

&gt;<i> Well, there is nothing to stop you 'registering' the same Consumer
</I>&gt;<i> instance more than once, with different consumer tags, so it is easy to
</I>&gt;<i> drive multiple 'identical' Consumers. However, if you register
</I>&gt;<i> (Channel.basicConsume()) on the same channel, the consumers will be
</I>&gt;<i> called serially (this is done to preserve the ordering of messages
</I>&gt;<i> processed on a channel).
</I>&gt;<i>
</I>&gt;<i> No doubt you've read the blurb on the Java Client API doc pages
</I>&gt;<i> (<A HREF="http://www.rabbitmq.com/api-guide.html#consuming">http://www.rabbitmq.com/api-guide.html#consuming</A>) which says:
</I>&gt;<i>
</I>&gt;<i> &gt; Callbacks to Consumers are dispatched on a thread separate from the
</I>&gt;<i> &gt; thread managed by the Connection. This means that Consumers can safely
</I>&gt;<i> &gt; call blocking methods on the Connection or Channel, such asqueueDeclare,
</I>&gt;<i> &gt; txCommit, basicCancel or basicPublish.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Each Channel has its own dispatch thread. For the most common use case
</I>&gt;<i> &gt; of one Consumer per Channel, this means Consumers do not hold up other
</I>&gt;<i> &gt; Consumers. If you have multiple Consumers per Channel be aware that a
</I>&gt;<i> &gt; long-running Consumer may hold up dispatch of callbacks to other
</I>&gt;<i> &gt; Consumers on that Channel.
</I>&gt;<i>
</I>&gt;<i> and the section on advanced connection options mentions a thread-pool
</I>&gt;<i> (by default containing 5 threads) associated with the connection.
</I>&gt;<i>
</I>&gt;<i> What this all means is that *on each channel* Consumer callbacks are
</I>&gt;<i> called serially. No overlapping there, so no chance to consume 'in
</I>&gt;<i> parallel', so distinct *channels* (on the same connection) are allowed
</I>&gt;<i> to run their consumers in parallel (up to five may run concurrently, in
</I>&gt;<i> the default case).
</I>&gt;<i>
</I>&gt;<i> So, to 'consume' messages in parallel from a single queue you need to
</I>&gt;<i> have the consumers on separate channels. Now, if you define a single
</I>&gt;<i> Consumer instance, and get it to be invoked on multiple threads
</I>&gt;<i> concurrently (on separate channels) you have to be careful -- the code
</I>&gt;<i> in your Consumer must be thread-safe, and probably more than just that,
</I>&gt;<i> too. I'll assume you know what you are doing. 
</I>&gt;<i>
</I> 

&gt;<i> If you create one Consumer
</I>&gt;<i> instance for each channel, RabbitMQ will guarantee that each channel's
</I>&gt;<i> Consumer is running on one thread, so the rules are simpler.
</I>&gt;<i>
</I>&gt;<i> There is another option. Provided you are prepared to separate
</I>&gt;<i> consumption from processing (and possibly acknowledgement) you can
</I>&gt;<i> register a single consumer which does very little except pass the
</I>&gt;<i> message to another (worker) thread to do the actual processing.
</I>&gt;<i>
</I>The
&gt;<i> Consumer doesn't have to be sophisticated, but your dispatching
</I>&gt;<i> mechanism needs to be: you mustn't lose messages, and you must ensure
</I>&gt;<i> that you acknowledge them at some point (which may not be straight
</I>&gt;<i> away). Still, if you are adept at Java concurrent programming these are
</I>&gt;<i> all achievable. 
</I>&gt;<i>
</I>This is the approach I've taken so far. I have a single Connection, Channel 
and Consumer and a single thread that loop on consumer.nextDelivery(). As 
soon as consumer.nextDelivery() returns, the message is acknowledged and 
handed off to a separate thread pool for processing, allowing the thread to 
move on to the next delivery. 
 

&gt;<i> By managing your own worker threads you can achieve your
</I>&gt;<i> own dispatching and resource management rules, and by setting the
</I>&gt;<i> pre-fetch count (Qos) and managing acknowledgements you can gate the
</I>&gt;<i> amount of work done in parallel, and even decide which workers get which
</I>&gt;<i> messages.
</I>&gt;<i>
</I>&gt;<i> Which of these is 'best' depends a lot on your requirements. If you need
</I>&gt;<i> just a little more control over the processing threads but don't want to
</I>&gt;<i> 'roll-your-own' dispatcher mechanism there is an option for you to
</I>&gt;<i> supply your own ExecutorService for the RabbitMQ Connection to use, and
</I>&gt;<i> Java supplies some standard ExecutorService implementations which allow
</I>&gt;<i> you to do some of the management without considerable effort.
</I>&gt;<i>
</I>
My requirements are simply to maximize throughput of my message 
consumption. Rolling my own dispatcher is probably a bit much. Any 
alternative configuration recommendations (to the single Connection, 
Channel, Consumer setup), for maximizing throughput would be appreciated.

Thanks,
Josh
 

&gt;<i> My general advice is that this might be a lot of work, and you should
</I>&gt;<i> consider investing in a sophisticated system only if you have determined
</I>&gt;<i> that you really need the advantages it might bring. Be aware that these
</I>&gt;<i> may not include faster throughput, and might upset any ordering
</I>&gt;<i> guarantees you may be relying upon at present.
</I>&gt;<i>
</I>&gt;<i> I hope this helps.
</I>&gt;<i>
</I>&gt;<i> Steve Powell  (a happy kitten)
</I>&gt;<i> ----------some more definitions from the SPD----------
</I>&gt;<i> chinchilla (n.) Cooling device for the lower jaw.
</I>&gt;<i> socialcast (n.) Someone to whom everyone is speaking but nobody likes.
</I>&gt;<i> literacy (n.) A textually transmitted disease usually contracted in 
</I>&gt;<i> childhood.
</I>&gt;<i>
</I>&gt;<i> On 22 Mar 2012, at 18:20, Josh Stone wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; I wanted to ask the experts since it's not clear to me - what is the 
</I>&gt;<i> best way to parallelize message consumption from a single queue, using the 
</I>&gt;<i> Java client? 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Thanks,
</I>&gt;<i> &gt; Josh
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>On Monday, March 26, 2012 7:11:13 AM UTC-7, Steve Powell wrote:
&gt;<i>
</I>&gt;<i> Hi Josh,
</I>&gt;<i>
</I>&gt;<i> In the absence of the experts -- you get me :-)
</I>&gt;<i>
</I>&gt;<i> Questions that start 'what is the best way to...' often have no
</I>&gt;<i> definitive answer, I'm afraid; but here goes.
</I>&gt;<i>
</I>&gt;<i> First, I'm going to have to explain what I *think* you are asking about,
</I>&gt;<i> before trying to answer it.
</I>&gt;<i>
</I>&gt;<i>   I assume you are asking about multiple Consumers, in a Java client, all
</I>&gt;<i>   consuming from the same queue, allowing 'parallel' consumption -- which
</I>&gt;<i>   I take to mean multi-threaded -- within the same Java client. You want
</I>&gt;<i>   the 'best' application structure which achieves 'parallel' processing of 
</I>&gt;<i>   messages from the queue.
</I>&gt;<i>
</I>&gt;<i> Well, there is nothing to stop you 'registering' the same Consumer
</I>&gt;<i> instance more than once, with different consumer tags, so it is easy to
</I>&gt;<i> drive multiple 'identical' Consumers. However, if you register
</I>&gt;<i> (Channel.basicConsume()) on the same channel, the consumers will be
</I>&gt;<i> called serially (this is done to preserve the ordering of messages
</I>&gt;<i> processed on a channel).
</I>&gt;<i>
</I>&gt;<i> No doubt you've read the blurb on the Java Client API doc pages
</I>&gt;<i> (<A HREF="http://www.rabbitmq.com/api-guide.html#consuming">http://www.rabbitmq.com/api-guide.html#consuming</A>) which says:
</I>&gt;<i>
</I>&gt;<i> &gt; Callbacks to Consumers are dispatched on a thread separate from the
</I>&gt;<i> &gt; thread managed by the Connection. This means that Consumers can safely
</I>&gt;<i> &gt; call blocking methods on the Connection or Channel, such asqueueDeclare,
</I>&gt;<i> &gt; txCommit, basicCancel or basicPublish.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Each Channel has its own dispatch thread. For the most common use case
</I>&gt;<i> &gt; of one Consumer per Channel, this means Consumers do not hold up other
</I>&gt;<i> &gt; Consumers. If you have multiple Consumers per Channel be aware that a
</I>&gt;<i> &gt; long-running Consumer may hold up dispatch of callbacks to other
</I>&gt;<i> &gt; Consumers on that Channel.
</I>&gt;<i>
</I>&gt;<i> and the section on advanced connection options mentions a thread-pool
</I>&gt;<i> (by default containing 5 threads) associated with the connection.
</I>&gt;<i>
</I>&gt;<i> What this all means is that *on each channel* Consumer callbacks are
</I>&gt;<i> called serially. No overlapping there, so no chance to consume 'in
</I>&gt;<i> parallel', so distinct *channels* (on the same connection) are allowed
</I>&gt;<i> to run their consumers in parallel (up to five may run concurrently, in
</I>&gt;<i> the default case).
</I>&gt;<i>
</I>&gt;<i> So, to 'consume' messages in parallel from a single queue you need to
</I>&gt;<i> have the consumers on separate channels. Now, if you define a single
</I>&gt;<i> Consumer instance, and get it to be invoked on multiple threads
</I>&gt;<i> concurrently (on separate channels) you have to be careful -- the code
</I>&gt;<i> in your Consumer must be thread-safe, and probably more than just that,
</I>&gt;<i> too. I'll assume you know what you are doing. If you create one Consumer
</I>&gt;<i> instance for each channel, RabbitMQ will guarantee that each channel's
</I>&gt;<i> Consumer is running on one thread, so the rules are simpler.
</I>&gt;<i>
</I>&gt;<i> There is another option. Provided you are prepared to separate
</I>&gt;<i> consumption from processing (and possibly acknowledgement) you can
</I>&gt;<i> register a single consumer which does very little except pass the
</I>&gt;<i> message to another (worker) thread to do the actual processing. The
</I>&gt;<i> Consumer doesn't have to be sophisticated, but your dispatching
</I>&gt;<i> mechanism needs to be: you mustn't lose messages, and you must ensure
</I>&gt;<i> that you acknowledge them at some point (which may not be straight
</I>&gt;<i> away). Still, if you are adept at Java concurrent programming these are
</I>&gt;<i> all achievable. By managing your own worker threads you can achieve your
</I>&gt;<i> own dispatching and resource management rules, and by setting the
</I>&gt;<i> pre-fetch count (Qos) and managing acknowledgements you can gate the
</I>&gt;<i> amount of work done in parallel, and even decide which workers get which
</I>&gt;<i> messages.
</I>&gt;<i>
</I>&gt;<i> Which of these is 'best' depends a lot on your requirements. If you need
</I>&gt;<i> just a little more control over the processing threads but don't want to
</I>&gt;<i> 'roll-your-own' dispatcher mechanism there is an option for you to
</I>&gt;<i> supply your own ExecutorService for the RabbitMQ Connection to use, and
</I>&gt;<i> Java supplies some standard ExecutorService implementations which allow
</I>&gt;<i> you to do some of the management without considerable effort.
</I>&gt;<i>
</I>&gt;<i> My general advice is that this might be a lot of work, and you should
</I>&gt;<i> consider investing in a sophisticated system only if you have determined
</I>&gt;<i> that you really need the advantages it might bring. Be aware that these
</I>&gt;<i> may not include faster throughput, and might upset any ordering
</I>&gt;<i> guarantees you may be relying upon at present.
</I>&gt;<i>
</I>&gt;<i> I hope this helps.
</I>&gt;<i>
</I>&gt;<i> Steve Powell  (a happy kitten)
</I>&gt;<i> ----------some more definitions from the SPD----------
</I>&gt;<i> chinchilla (n.) Cooling device for the lower jaw.
</I>&gt;<i> socialcast (n.) Someone to whom everyone is speaking but nobody likes.
</I>&gt;<i> literacy (n.) A textually transmitted disease usually contracted in 
</I>&gt;<i> childhood.
</I>&gt;<i>
</I>&gt;<i> On 22 Mar 2012, at 18:20, Josh Stone wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; I wanted to ask the experts since it's not clear to me - what is the 
</I>&gt;<i> best way to parallelize message consumption from a single queue, using the 
</I>&gt;<i> Java client? 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Thanks,
</I>&gt;<i> &gt; Josh
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>On Monday, March 26, 2012 7:11:13 AM UTC-7, Steve Powell wrote:
&gt;<i>
</I>&gt;<i> Hi Josh,
</I>&gt;<i>
</I>&gt;<i> In the absence of the experts -- you get me :-)
</I>&gt;<i>
</I>&gt;<i> Questions that start 'what is the best way to...' often have no
</I>&gt;<i> definitive answer, I'm afraid; but here goes.
</I>&gt;<i>
</I>&gt;<i> First, I'm going to have to explain what I *think* you are asking about,
</I>&gt;<i> before trying to answer it.
</I>&gt;<i>
</I>&gt;<i>   I assume you are asking about multiple Consumers, in a Java client, all
</I>&gt;<i>   consuming from the same queue, allowing 'parallel' consumption -- which
</I>&gt;<i>   I take to mean multi-threaded -- within the same Java client. You want
</I>&gt;<i>   the 'best' application structure which achieves 'parallel' processing of 
</I>&gt;<i>   messages from the queue.
</I>&gt;<i>
</I>&gt;<i> Well, there is nothing to stop you 'registering' the same Consumer
</I>&gt;<i> instance more than once, with different consumer tags, so it is easy to
</I>&gt;<i> drive multiple 'identical' Consumers. However, if you register
</I>&gt;<i> (Channel.basicConsume()) on the same channel, the consumers will be
</I>&gt;<i> called serially (this is done to preserve the ordering of messages
</I>&gt;<i> processed on a channel).
</I>&gt;<i>
</I>&gt;<i> No doubt you've read the blurb on the Java Client API doc pages
</I>&gt;<i> (<A HREF="http://www.rabbitmq.com/api-guide.html#consuming">http://www.rabbitmq.com/api-guide.html#consuming</A>) which says:
</I>&gt;<i>
</I>&gt;<i> &gt; Callbacks to Consumers are dispatched on a thread separate from the
</I>&gt;<i> &gt; thread managed by the Connection. This means that Consumers can safely
</I>&gt;<i> &gt; call blocking methods on the Connection or Channel, such asqueueDeclare,
</I>&gt;<i> &gt; txCommit, basicCancel or basicPublish.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Each Channel has its own dispatch thread. For the most common use case
</I>&gt;<i> &gt; of one Consumer per Channel, this means Consumers do not hold up other
</I>&gt;<i> &gt; Consumers. If you have multiple Consumers per Channel be aware that a
</I>&gt;<i> &gt; long-running Consumer may hold up dispatch of callbacks to other
</I>&gt;<i> &gt; Consumers on that Channel.
</I>&gt;<i>
</I>&gt;<i> and the section on advanced connection options mentions a thread-pool
</I>&gt;<i> (by default containing 5 threads) associated with the connection.
</I>&gt;<i>
</I>&gt;<i> What this all means is that *on each channel* Consumer callbacks are
</I>&gt;<i> called serially. No overlapping there, so no chance to consume 'in
</I>&gt;<i> parallel', so distinct *channels* (on the same connection) are allowed
</I>&gt;<i> to run their consumers in parallel (up to five may run concurrently, in
</I>&gt;<i> the default case).
</I>&gt;<i>
</I>&gt;<i> So, to 'consume' messages in parallel from a single queue you need to
</I>&gt;<i> have the consumers on separate channels. Now, if you define a single
</I>&gt;<i> Consumer instance, and get it to be invoked on multiple threads
</I>&gt;<i> concurrently (on separate channels) you have to be careful -- the code
</I>&gt;<i> in your Consumer must be thread-safe, and probably more than just that,
</I>&gt;<i> too. I'll assume you know what you are doing. If you create one Consumer
</I>&gt;<i> instance for each channel, RabbitMQ will guarantee that each channel's
</I>&gt;<i> Consumer is running on one thread, so the rules are simpler.
</I>&gt;<i>
</I>&gt;<i> There is another option. Provided you are prepared to separate
</I>&gt;<i> consumption from processing (and possibly acknowledgement) you can
</I>&gt;<i> register a single consumer which does very little except pass the
</I>&gt;<i> message to another (worker) thread to do the actual processing. The
</I>&gt;<i> Consumer doesn't have to be sophisticated, but your dispatching
</I>&gt;<i> mechanism needs to be: you mustn't lose messages, and you must ensure
</I>&gt;<i> that you acknowledge them at some point (which may not be straight
</I>&gt;<i> away). Still, if you are adept at Java concurrent programming these are
</I>&gt;<i> all achievable. By managing your own worker threads you can achieve your
</I>&gt;<i> own dispatching and resource management rules, and by setting the
</I>&gt;<i> pre-fetch count (Qos) and managing acknowledgements you can gate the
</I>&gt;<i> amount of work done in parallel, and even decide which workers get which
</I>&gt;<i> messages.
</I>&gt;<i>
</I>&gt;<i> Which of these is 'best' depends a lot on your requirements. If you need
</I>&gt;<i> just a little more control over the processing threads but don't want to
</I>&gt;<i> 'roll-your-own' dispatcher mechanism there is an option for you to
</I>&gt;<i> supply your own ExecutorService for the RabbitMQ Connection to use, and
</I>&gt;<i> Java supplies some standard ExecutorService implementations which allow
</I>&gt;<i> you to do some of the management without considerable effort.
</I>&gt;<i>
</I>&gt;<i> My general advice is that this might be a lot of work, and you should
</I>&gt;<i> consider investing in a sophisticated system only if you have determined
</I>&gt;<i> that you really need the advantages it might bring. Be aware that these
</I>&gt;<i> may not include faster throughput, and might upset any ordering
</I>&gt;<i> guarantees you may be relying upon at present.
</I>&gt;<i>
</I>&gt;<i> I hope this helps.
</I>&gt;<i>
</I>&gt;<i> Steve Powell  (a happy kitten)
</I>&gt;<i> ----------some more definitions from the SPD----------
</I>&gt;<i> chinchilla (n.) Cooling device for the lower jaw.
</I>&gt;<i> socialcast (n.) Someone to whom everyone is speaking but nobody likes.
</I>&gt;<i> literacy (n.) A textually transmitted disease usually contracted in 
</I>&gt;<i> childhood.
</I>&gt;<i>
</I>&gt;<i> On 22 Mar 2012, at 18:20, Josh Stone wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; I wanted to ask the experts since it's not clear to me - what is the 
</I>&gt;<i> best way to parallelize message consumption from a single queue, using the 
</I>&gt;<i> Java client? 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Thanks,
</I>&gt;<i> &gt; Josh
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>On Monday, March 26, 2012 7:11:13 AM UTC-7, Steve Powell wrote:
&gt;<i>
</I>&gt;<i> Hi Josh,
</I>&gt;<i>
</I>&gt;<i> In the absence of the experts -- you get me :-)
</I>&gt;<i>
</I>&gt;<i> Questions that start 'what is the best way to...' often have no
</I>&gt;<i> definitive answer, I'm afraid; but here goes.
</I>&gt;<i>
</I>&gt;<i> First, I'm going to have to explain what I *think* you are asking about,
</I>&gt;<i> before trying to answer it.
</I>&gt;<i>
</I>&gt;<i>   I assume you are asking about multiple Consumers, in a Java client, all
</I>&gt;<i>   consuming from the same queue, allowing 'parallel' consumption -- which
</I>&gt;<i>   I take to mean multi-threaded -- within the same Java client. You want
</I>&gt;<i>   the 'best' application structure which achieves 'parallel' processing of 
</I>&gt;<i>   messages from the queue.
</I>&gt;<i>
</I>&gt;<i> Well, there is nothing to stop you 'registering' the same Consumer
</I>&gt;<i> instance more than once, with different consumer tags, so it is easy to
</I>&gt;<i> drive multiple 'identical' Consumers. However, if you register
</I>&gt;<i> (Channel.basicConsume()) on the same channel, the consumers will be
</I>&gt;<i> called serially (this is done to preserve the ordering of messages
</I>&gt;<i> processed on a channel).
</I>&gt;<i>
</I>&gt;<i> No doubt you've read the blurb on the Java Client API doc pages
</I>&gt;<i> (<A HREF="http://www.rabbitmq.com/api-guide.html#consuming">http://www.rabbitmq.com/api-guide.html#consuming</A>) which says:
</I>&gt;<i>
</I>&gt;<i> &gt; Callbacks to Consumers are dispatched on a thread separate from the
</I>&gt;<i> &gt; thread managed by the Connection. This means that Consumers can safely
</I>&gt;<i> &gt; call blocking methods on the Connection or Channel, such asqueueDeclare,
</I>&gt;<i> &gt; txCommit, basicCancel or basicPublish.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Each Channel has its own dispatch thread. For the most common use case
</I>&gt;<i> &gt; of one Consumer per Channel, this means Consumers do not hold up other
</I>&gt;<i> &gt; Consumers. If you have multiple Consumers per Channel be aware that a
</I>&gt;<i> &gt; long-running Consumer may hold up dispatch of callbacks to other
</I>&gt;<i> &gt; Consumers on that Channel.
</I>&gt;<i>
</I>&gt;<i> and the section on advanced connection options mentions a thread-pool
</I>&gt;<i> (by default containing 5 threads) associated with the connection.
</I>&gt;<i>
</I>&gt;<i> What this all means is that *on each channel* Consumer callbacks are
</I>&gt;<i> called serially. No overlapping there, so no chance to consume 'in
</I>&gt;<i> parallel', so distinct *channels* (on the same connection) are allowed
</I>&gt;<i> to run their consumers in parallel (up to five may run concurrently, in
</I>&gt;<i> the default case).
</I>&gt;<i>
</I>&gt;<i> So, to 'consume' messages in parallel from a single queue you need to
</I>&gt;<i> have the consumers on separate channels. Now, if you define a single
</I>&gt;<i> Consumer instance, and get it to be invoked on multiple threads
</I>&gt;<i> concurrently (on separate channels) you have to be careful -- the code
</I>&gt;<i> in your Consumer must be thread-safe, and probably more than just that,
</I>&gt;<i> too. I'll assume you know what you are doing. If you create one Consumer
</I>&gt;<i> instance for each channel, RabbitMQ will guarantee that each channel's
</I>&gt;<i> Consumer is running on one thread, so the rules are simpler.
</I>&gt;<i>
</I>&gt;<i> There is another option. Provided you are prepared to separate
</I>&gt;<i> consumption from processing (and possibly acknowledgement) you can
</I>&gt;<i> register a single consumer which does very little except pass the
</I>&gt;<i> message to another (worker) thread to do the actual processing. The
</I>&gt;<i> Consumer doesn't have to be sophisticated, but your dispatching
</I>&gt;<i> mechanism needs to be: you mustn't lose messages, and you must ensure
</I>&gt;<i> that you acknowledge them at some point (which may not be straight
</I>&gt;<i> away). Still, if you are adept at Java concurrent programming these are
</I>&gt;<i> all achievable. By managing your own worker threads you can achieve your
</I>&gt;<i> own dispatching and resource management rules, and by setting the
</I>&gt;<i> pre-fetch count (Qos) and managing acknowledgements you can gate the
</I>&gt;<i> amount of work done in parallel, and even decide which workers get which
</I>&gt;<i> messages.
</I>&gt;<i>
</I>&gt;<i> Which of these is 'best' depends a lot on your requirements. If you need
</I>&gt;<i> just a little more control over the processing threads but don't want to
</I>&gt;<i> 'roll-your-own' dispatcher mechanism there is an option for you to
</I>&gt;<i> supply your own ExecutorService for the RabbitMQ Connection to use, and
</I>&gt;<i> Java supplies some standard ExecutorService implementations which allow
</I>&gt;<i> you to do some of the management without considerable effort.
</I>&gt;<i>
</I>&gt;<i> My general advice is that this might be a lot of work, and you should
</I>&gt;<i> consider investing in a sophisticated system only if you have determined
</I>&gt;<i> that you really need the advantages it might bring. Be aware that these
</I>&gt;<i> may not include faster throughput, and might upset any ordering
</I>&gt;<i> guarantees you may be relying upon at present.
</I>&gt;<i>
</I>&gt;<i> I hope this helps.
</I>&gt;<i>
</I>&gt;<i> Steve Powell  (a happy kitten)
</I>&gt;<i> ----------some more definitions from the SPD----------
</I>&gt;<i> chinchilla (n.) Cooling device for the lower jaw.
</I>&gt;<i> socialcast (n.) Someone to whom everyone is speaking but nobody likes.
</I>&gt;<i> literacy (n.) A textually transmitted disease usually contracted in 
</I>&gt;<i> childhood.
</I>&gt;<i>
</I>&gt;<i> On 22 Mar 2012, at 18:20, Josh Stone wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; I wanted to ask the experts since it's not clear to me - what is the 
</I>&gt;<i> best way to parallelize message consumption from a single queue, using the 
</I>&gt;<i> Java client? 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Thanks,
</I>&gt;<i> &gt; Josh
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>On Monday, March 26, 2012 7:11:13 AM UTC-7, Steve Powell wrote:
&gt;<i>
</I>&gt;<i> Hi Josh,
</I>&gt;<i>
</I>&gt;<i> In the absence of the experts -- you get me :-)
</I>&gt;<i>
</I>&gt;<i> Questions that start 'what is the best way to...' often have no
</I>&gt;<i> definitive answer, I'm afraid; but here goes.
</I>&gt;<i>
</I>&gt;<i> First, I'm going to have to explain what I *think* you are asking about,
</I>&gt;<i> before trying to answer it.
</I>&gt;<i>
</I>&gt;<i>   I assume you are asking about multiple Consumers, in a Java client, all
</I>&gt;<i>   consuming from the same queue, allowing 'parallel' consumption -- which
</I>&gt;<i>   I take to mean multi-threaded -- within the same Java client. You want
</I>&gt;<i>   the 'best' application structure which achieves 'parallel' processing of 
</I>&gt;<i>   messages from the queue.
</I>&gt;<i>
</I>&gt;<i> Well, there is nothing to stop you 'registering' the same Consumer
</I>&gt;<i> instance more than once, with different consumer tags, so it is easy to
</I>&gt;<i> drive multiple 'identical' Consumers. However, if you register
</I>&gt;<i> (Channel.basicConsume()) on the same channel, the consumers will be
</I>&gt;<i> called serially (this is done to preserve the ordering of messages
</I>&gt;<i> processed on a channel).
</I>&gt;<i>
</I>&gt;<i> No doubt you've read the blurb on the Java Client API doc pages
</I>&gt;<i> (<A HREF="http://www.rabbitmq.com/api-guide.html#consuming">http://www.rabbitmq.com/api-guide.html#consuming</A>) which says:
</I>&gt;<i>
</I>&gt;<i> &gt; Callbacks to Consumers are dispatched on a thread separate from the
</I>&gt;<i> &gt; thread managed by the Connection. This means that Consumers can safely
</I>&gt;<i> &gt; call blocking methods on the Connection or Channel, such asqueueDeclare,
</I>&gt;<i> &gt; txCommit, basicCancel or basicPublish.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Each Channel has its own dispatch thread. For the most common use case
</I>&gt;<i> &gt; of one Consumer per Channel, this means Consumers do not hold up other
</I>&gt;<i> &gt; Consumers. If you have multiple Consumers per Channel be aware that a
</I>&gt;<i> &gt; long-running Consumer may hold up dispatch of callbacks to other
</I>&gt;<i> &gt; Consumers on that Channel.
</I>&gt;<i>
</I>&gt;<i> and the section on advanced connection options mentions a thread-pool
</I>&gt;<i> (by default containing 5 threads) associated with the connection.
</I>&gt;<i>
</I>&gt;<i> What this all means is that *on each channel* Consumer callbacks are
</I>&gt;<i> called serially. No overlapping there, so no chance to consume 'in
</I>&gt;<i> parallel', so distinct *channels* (on the same connection) are allowed
</I>&gt;<i> to run their consumers in parallel (up to five may run concurrently, in
</I>&gt;<i> the default case).
</I>&gt;<i>
</I>&gt;<i> So, to 'consume' messages in parallel from a single queue you need to
</I>&gt;<i> have the consumers on separate channels. Now, if you define a single
</I>&gt;<i> Consumer instance, and get it to be invoked on multiple threads
</I>&gt;<i> concurrently (on separate channels) you have to be careful -- the code
</I>&gt;<i> in your Consumer must be thread-safe, and probably more than just that,
</I>&gt;<i> too. I'll assume you know what you are doing. If you create one Consumer
</I>&gt;<i> instance for each channel, RabbitMQ will guarantee that each channel's
</I>&gt;<i> Consumer is running on one thread, so the rules are simpler.
</I>&gt;<i>
</I>&gt;<i> There is another option. Provided you are prepared to separate
</I>&gt;<i> consumption from processing (and possibly acknowledgement) you can
</I>&gt;<i> register a single consumer which does very little except pass the
</I>&gt;<i> message to another (worker) thread to do the actual processing. The
</I>&gt;<i> Consumer doesn't have to be sophisticated, but your dispatching
</I>&gt;<i> mechanism needs to be: you mustn't lose messages, and you must ensure
</I>&gt;<i> that you acknowledge them at some point (which may not be straight
</I>&gt;<i> away). Still, if you are adept at Java concurrent programming these are
</I>&gt;<i> all achievable. By managing your own worker threads you can achieve your
</I>&gt;<i> own dispatching and resource management rules, and by setting the
</I>&gt;<i> pre-fetch count (Qos) and managing acknowledgements you can gate the
</I>&gt;<i> amount of work done in parallel, and even decide which workers get which
</I>&gt;<i> messages.
</I>&gt;<i>
</I>&gt;<i> Which of these is 'best' depends a lot on your requirements. If you need
</I>&gt;<i> just a little more control over the processing threads but don't want to
</I>&gt;<i> 'roll-your-own' dispatcher mechanism there is an option for you to
</I>&gt;<i> supply your own ExecutorService for the RabbitMQ Connection to use, and
</I>&gt;<i> Java supplies some standard ExecutorService implementations which allow
</I>&gt;<i> you to do some of the management without considerable effort.
</I>&gt;<i>
</I>&gt;<i> My general advice is that this might be a lot of work, and you should
</I>&gt;<i> consider investing in a sophisticated system only if you have determined
</I>&gt;<i> that you really need the advantages it might bring. Be aware that these
</I>&gt;<i> may not include faster throughput, and might upset any ordering
</I>&gt;<i> guarantees you may be relying upon at present.
</I>&gt;<i>
</I>&gt;<i> I hope this helps.
</I>&gt;<i>
</I>&gt;<i> Steve Powell  (a happy kitten)
</I>&gt;<i> ----------some more definitions from the SPD----------
</I>&gt;<i> chinchilla (n.) Cooling device for the lower jaw.
</I>&gt;<i> socialcast (n.) Someone to whom everyone is speaking but nobody likes.
</I>&gt;<i> literacy (n.) A textually transmitted disease usually contracted in 
</I>&gt;<i> childhood.
</I>&gt;<i>
</I>&gt;<i> On 22 Mar 2012, at 18:20, Josh Stone wrote:
</I>&gt;<i>
</I>&gt;<i> &gt; I wanted to ask the experts since it's not clear to me - what is the 
</I>&gt;<i> best way to parallelize message consumption from a single queue, using the 
</I>&gt;<i> Java client? 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Thanks,
</I>&gt;<i> &gt; Josh
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20120326/02f3fb2d/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20120326/02f3fb2d/attachment.htm</A>&gt;
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019132.html">[rabbitmq-discuss] [java-client] Parallelizing message	consumption from a single queue
</A></li>
	<LI>Next message: <A HREF="019187.html">[rabbitmq-discuss] [java-client] Parallelizing message	consumption from a single queue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19150">[ date ]</a>
              <a href="thread.html#19150">[ thread ]</a>
              <a href="subject.html#19150">[ subject ]</a>
              <a href="author.html#19150">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
