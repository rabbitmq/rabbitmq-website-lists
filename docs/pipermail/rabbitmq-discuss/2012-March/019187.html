<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] [java-client] Parallelizing message	consumption from a single queue
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20%5Bjava-client%5D%20Parallelizing%20message%0A%09consumption%20from%20a%20single%20queue&In-Reply-To=%3C25A82C11-C311-47CA-976D-EA64BA953A75%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019150.html">
   <LINK REL="Next"  HREF="019075.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] [java-client] Parallelizing message	consumption from a single queue</H1>
    <B>Steve Powell</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20%5Bjava-client%5D%20Parallelizing%20message%0A%09consumption%20from%20a%20single%20queue&In-Reply-To=%3C25A82C11-C311-47CA-976D-EA64BA953A75%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] [java-client] Parallelizing message	consumption from a single queue">steve at rabbitmq.com
       </A><BR>
    <I>Tue Mar 27 17:28:00 BST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="019150.html">[rabbitmq-discuss] [java-client] Parallelizing message consumption from a single queue
</A></li>
        <LI>Next message: <A HREF="019075.html">[rabbitmq-discuss] Access for &quot;external&quot; users
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19187">[ date ]</a>
              <a href="thread.html#19187">[ thread ]</a>
              <a href="subject.html#19187">[ subject ]</a>
              <a href="author.html#19187">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Josh,

&gt;<i> This is the approach I've taken so far. I have a single Connection,
</I>&gt;<i> Channel and Consumer and a single thread that loop on
</I>&gt;<i> consumer.nextDelivery(). As soon as consumer.nextDelivery() returns, the
</I>&gt;<i> message is acknowledged and handed off to a separate thread pool for
</I>&gt;<i> processing, allowing the thread to move on to the next delivery.
</I>
Since you mention nextDelivery() this means you are using our
QueueingConsumer implementation. If all your single thread is doing is
to hand the message to another thread(pool) for processing, then you
don't need QueueingConsumer. Instead, define a DefaultConsumer extension
and acknowledge and hand-over the message in the handleDelivery()
method.

Here is what it might look like:

  Channel channel ...
  Consumer cons = new DefaultConsumer(channel) {
      @Override
      public void handleDelivery(String consumerTag,
                                 Envelope envelope,
                                 AMQP.BasicProperties properties,
                                 byte[] body)
          throws IOException
      {
              // acknowledge the message

              // pass it to your thread process
      }
  }

and of course you need to attach it to your queue...

  basicConsume(queueName, false, cons);

This will eliminate the internal queue set up by QueueingConsumer and
allow you greater control over error conditions (just add more callback
methods to your Consumer). The callback methods are called serially, and
you can issue channel method calls in the handleDelivery() body without
deadlocking.

You may want to use autoAck=true if you are *not* deferring the
acknowledgement until after processing. Only do this if you really do
want to acknowledge everything and have no limit on the messages handed
off to the thread pool.

Be aware that the basicQos() prefetch-count setting on the channel
(together with autoAck=false) will permit the delivery of multiple
messages before you have to acknowledge any of them, so it is possible
to defer the acknowledgement until the end of processing, if the
prefetch-count is larger than one, and still permit the concurrent
processing of up-to prefetch-count messages.

Please let us know how you get on.

Steve Powell  (a happy bunny)
----------some more definitions from the SPD----------
chinchilla (n.) Cooling device for the lower jaw.
socialcast (n.) Someone to whom everyone is speaking but nobody likes.
literacy (n.) A textually transmitted disease usually contracted in childhood.

On 27 Mar 2012, at 00:49, Josh Stone wrote:
&gt;<i> ...many lines
</I></PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019150.html">[rabbitmq-discuss] [java-client] Parallelizing message consumption from a single queue
</A></li>
	<LI>Next message: <A HREF="019075.html">[rabbitmq-discuss] Access for &quot;external&quot; users
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19187">[ date ]</a>
              <a href="thread.html#19187">[ thread ]</a>
              <a href="subject.html#19187">[ subject ]</a>
              <a href="author.html#19187">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
