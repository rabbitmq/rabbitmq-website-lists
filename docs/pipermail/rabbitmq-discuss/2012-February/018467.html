<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Design Help?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Design%20Help%3F&In-Reply-To=%3C4F4D37D4.90307%402600hz.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018466.html">
   <LINK REL="Next"  HREF="018288.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Design Help?</H1>
    <B>James Aimonetti</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Design%20Help%3F&In-Reply-To=%3C4F4D37D4.90307%402600hz.com%3E"
       TITLE="[rabbitmq-discuss] Design Help?">james at 2600hz.com
       </A><BR>
    <I>Tue Feb 28 20:23:48 GMT 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="018466.html">[rabbitmq-discuss] Design Help?
</A></li>
        <LI>Next message: <A HREF="018288.html">[rabbitmq-discuss] Starting rabbitmq-server: FAILED
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18467">[ date ]</a>
              <a href="thread.html#18467">[ thread ]</a>
              <a href="subject.html#18467">[ subject ]</a>
              <a href="author.html#18467">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Jerry,

Thanks for the suggestions. You're right that this is an abuse of the
messaging patterns, but the way our system is structured seems to
require building these higher level concepts on top of the primitives we
get from AMQP/RabbitMQ.

We have a system spread out over many servers, across datacenters, with
redundant applications running, and we need ways to coordinate work
amongst the redundant workers in this manner. When we don't care about
the order of work, its really easy to have the queue round-robin the
work to each worker.

As we're building more advanced features into our platform, this pattern
of only allowing one worker to process a job, across the whole platform,
is popping up in a few places and we'd like to encapsulate that pattern
into a reusable bit of code (a behaviour in Erlang).

AMQP is the glue that binds all these apps together, so we look to build
on top of its feature set.

I'll let the list know more if I figure a tenable solution :)

On 02/28/2012 11:53 AM, Jerry Kuch wrote:
&gt;<i> Hi, James:
</I>&gt;<i> 
</I>&gt;<i> Some of this appears to go beyond messaging per se and into more
</I>&gt;<i> general distributed systems/services coordination.  Have you contemplated
</I>&gt;<i> using something like Apache Zookeeper or Heroku's Doozer?  The primitives
</I>&gt;<i> provided by those may lend themselves well to integrating-with/supporting
</I>&gt;<i> your application, while the messaging heavy lifting continues using Rabbit
</I>&gt;<i> and its features/guarantees in the ways they work best without strange
</I>&gt;<i> fetch-peek-ack-nack trickery that will likely make your application 
</I>&gt;<i> pretty complex and hard to reason about.
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://zookeeper.apache.org/">http://zookeeper.apache.org/</A>
</I>&gt;<i> 
</I>&gt;<i> <A HREF="http://xph.us/2011/04/13/introducing-doozer.html">http://xph.us/2011/04/13/introducing-doozer.html</A>
</I>&gt;<i> 
</I>&gt;<i> Doozer is quite new; Zookeeper by virtue of its position in the
</I>&gt;<i> Hadoop ecology is older, more mature and well documented both online
</I>&gt;<i> and in books...
</I>&gt;<i> 
</I>&gt;<i> Best regards,
</I>&gt;<i> Jerry
</I>&gt;<i> 
</I>&gt;<i> ----- Original Message -----
</I>&gt;<i> From: &quot;James Aimonetti&quot; &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">james at 2600hz.com</A>&gt;
</I>&gt;<i> To: <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> Sent: Monday, February 20, 2012 9:04:12 AM
</I>&gt;<i> Subject: [rabbitmq-discuss] Design Help?
</I>&gt;<i> 
</I>&gt;<i> Hey list,
</I>&gt;<i> 
</I>&gt;<i> Curious for feedback, as this design idea I have would possibly extend
</I>&gt;<i> to several places in our application, and I'd love to make it generic
</I>&gt;<i> enough to do so.
</I>&gt;<i> 
</I>&gt;<i> The basic problem:
</I>&gt;<i> 
</I>&gt;<i> We have a queue of work to be done, represented as a named queue. For
</I>&gt;<i> redundancy, we have 2-&gt;many processes (in Erlang) that will read from
</I>&gt;<i> the queue and do the work. Easy so far.
</I>&gt;<i> 
</I>&gt;<i> However, we also have a list of resources needed to process the work
</I>&gt;<i> queue, which needs to be shared across all worker processes. When one
</I>&gt;<i> worker retrieves a job from the work queue, it must also get the list of
</I>&gt;<i> available resources, match resource to job, and return the list of
</I>&gt;<i> resources (with the used resource flagged as such) back to a globally
</I>&gt;<i> accessible place (hoping to avoid the DB, but it may be a good-enough
</I>&gt;<i> sync point).
</I>&gt;<i> 
</I>&gt;<i> So, for example, there are four jobs, two that require a paper shredder,
</I>&gt;<i> two that require a wood chipper. There is only one paper shredder and
</I>&gt;<i> one wood chipper. There are also 10 workers available to actually shred
</I>&gt;<i> stuff.
</I>&gt;<i> 
</I>&gt;<i> Worker one consumes the list of available equipment (one paper shredder,
</I>&gt;<i> one wood chipper), and then pulls the first job (paper to be shredded).
</I>&gt;<i> Worker one grabs the paper shredder, returns the list of resources
</I>&gt;<i> having flagged the paper shredder as in use, and ACKs the job. When
</I>&gt;<i> worker one finishes shredding paper, it will wait until the resources
</I>&gt;<i> list is available and update it with 1 more paper shredder available.
</I>&gt;<i> 
</I>&gt;<i> Once a job is actually started, I don't care if the worker crashes or
</I>&gt;<i> not; that will be handled later. And I'll have a supervising gen_server
</I>&gt;<i> pull the resource list, add the resource its using to its state, and
</I>&gt;<i> spawn the actual worker (catching exits to return the resource). I'm
</I>&gt;<i> sure other measures will be needed to ensure the resource is added back
</I>&gt;<i> eventually, but I'm trying to get the basic idea down.
</I>&gt;<i> 
</I>&gt;<i> So once worker one is done retrieving a resource, worker two can next
</I>&gt;<i> get the resources list and the next job. If the job is paper shredding,
</I>&gt;<i> worker two will nack the job (as there are no paper shredders at the
</I>&gt;<i> moment) and return the resource list. I will eventually want to support
</I>&gt;<i> being able to requeue the job to the back of the job queue, but for now,
</I>&gt;<i> work stalls until the first item in the queue can be processed successfully.
</I>&gt;<i> 
</I>&gt;<i> So while the resources list is out of queue, no workers will consume
</I>&gt;<i> jobs from the work queue. As soon as it reappears in queue, I want the
</I>&gt;<i> next worker in line to grab it and try to process the next job.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Some initial concerns:
</I>&gt;<i> 
</I>&gt;<i> No resources available for the job at the front of the queue means a lot
</I>&gt;<i> of fetching and nacking of jobs, and fetching/returning the resource list.
</I>&gt;<i> 
</I>&gt;<i> Losing the resources list: if whatever node (our Erlang VMs only
</I>&gt;<i> communicate via AMQP) goes down while handling the resources list, it
</I>&gt;<i> will obviously never be republished. We do usually have a timeout window
</I>&gt;<i> for the worker to get a resource for a job (sometimes the actual finding
</I>&gt;<i> of the resource takes a while), so if I could coordinate all workers
</I>&gt;<i> consuming from the resources_available queue, I could know after timeout
</I>&gt;<i> + a small fudge factor, that someone else should have begun processing.
</I>&gt;<i> So maybe the resources_available queue is more a try_to_process_a_job
</I>&gt;<i> queue, and each worker process maintains an identical list of resources
</I>&gt;<i> available, with a worker that pairs a job to resource publishing the
</I>&gt;<i> resource's in-use status.
</I>&gt;<i> 
</I>&gt;<i> So perhaps the solution is:
</I>&gt;<i> 
</I>&gt;<i> Jobs queue round robins amongst all workers, but only one worker can
</I>&gt;<i> fetch/(n)ack. A worker can only fetch from the jobs queue by consuming a
</I>&gt;<i> &quot;next&quot; message from a shared coordination queue. All workers publish
</I>&gt;<i> updates to resources available to a routing key so all workers'
</I>&gt;<i> resources state is in sync. If a worker can't find a resource for a job,
</I>&gt;<i> it can (configurable) 1) nack the job and send a 'next' to the
</I>&gt;<i> coordination queue; 2) requeue the job at the end of the jobs queue and
</I>&gt;<i> send a 'next'; 3) sit on the job (meaning no other worker can fetch from
</I>&gt;<i> the jobs queue) until an appropriate resource comes available.
</I>&gt;<i> 
</I>&gt;<i> Concerns here:
</I>&gt;<i> 
</I>&gt;<i> Starting/recovering the 'next' token.
</I>&gt;<i> 
</I>&gt;<i> I'm sure others but am realizing this is getting long.
</I>&gt;<i> 
</I>&gt;<i> Sorry for the wall of text and stream of consciousness writing. We have
</I>&gt;<i> a lot of places where this pattern is showing up and would love to get a
</I>&gt;<i> module or library written to ease doing this kind of coordination. Any
</I>&gt;<i> ideas or directions towards appropriate messaging patterns warmly welcome :)
</I>&gt;<i> 
</I>_______________________________________________
rabbitmq-discuss mailing list
<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>

- -- 
James Aimonetti
Distributed Systems Engineer / DJ MC_

2600hz | <A HREF="http://2600hz.com">http://2600hz.com</A>
sip:<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">james at 2600hz.com</A>
tel: 415.886.7905
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.10 (GNU/Linux)
Comment: Using GnuPG with Mozilla - <A HREF="http://enigmail.mozdev.org/">http://enigmail.mozdev.org/</A>

iQEcBAEBAgAGBQJPTTfUAAoJENc77s1OYoGgdq0H/2X7oohyxx0MhsoD06J07l2P
DZm7PdEEZhUCSRGb43cBszNjiFLvYtmbSGgWUEzQMjZvI0idKC6m4XIgZqKfJ7Wk
yVQcvMfeHmE0w1NIyrJLFlXToONHlX2mLStRHnsmhFdMZuDHuAwF41N3rZPX5/wV
JIUIvYg45VccYu0zL4kRq/9nBORJsfXxXcsB8pdKJa0uLxv2OPptDOHFgZVz/wVe
FC99/fBU/WixtDvzhe2D7d+ubn5UT1jf01ZKUTAgkesM3EpcmqdqI51jQR2Q0hbT
VhVODLSlTSrYSYsumStXOaFzZ8kwY7+mT3UDbRqtv+ThIKuWWejCXGFVjDeKcA8=
=NhsO
-----END PGP SIGNATURE-----
</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018466.html">[rabbitmq-discuss] Design Help?
</A></li>
	<LI>Next message: <A HREF="018288.html">[rabbitmq-discuss] Starting rabbitmq-server: FAILED
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18467">[ date ]</a>
              <a href="thread.html#18467">[ thread ]</a>
              <a href="subject.html#18467">[ subject ]</a>
              <a href="author.html#18467">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
