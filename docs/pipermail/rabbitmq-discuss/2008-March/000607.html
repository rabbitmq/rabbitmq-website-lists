<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] rabbitmq erlang client questions: channel	access and flags
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20rabbitmq%20erlang%20client%20questions%3A%20channel%0A%09access%20and%20flags&In-Reply-To=50ec7a2e0803170953g6974d866lc77c84493c199054%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000603.html">
   <LINK REL="Next"  HREF="000608.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] rabbitmq erlang client questions: channel	access and flags</H1>
    <B>Ben Hood</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20rabbitmq%20erlang%20client%20questions%3A%20channel%0A%09access%20and%20flags&In-Reply-To=50ec7a2e0803170953g6974d866lc77c84493c199054%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] rabbitmq erlang client questions: channel	access and flags">0x6e6562 at gmail.com
       </A><BR>
    <I>Mon Mar 17 20:15:14 GMT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000603.html">[rabbitmq-discuss] rabbitmq erlang client questions: channel access	and flags
</A></li>
        <LI>Next message: <A HREF="000608.html">[rabbitmq-discuss] rabbitmq erlang client questions: channel	access and flags
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#607">[ date ]</a>
              <a href="thread.html#607">[ thread ]</a>
              <a href="subject.html#607">[ subject ]</a>
              <a href="author.html#607">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Joe,


On 17 Mar 2008, at 16:53, joe lee wrote:

&gt;<i> Hi All,
</I>&gt;<i>
</I>&gt;<i> I was able to get erlang client and erlang rabbitmq server to work  
</I>&gt;<i> successfully.  I have few questions about channel access by erlang  
</I>&gt;<i> processes and certain flags in erlang client example that Ben  
</I>&gt;<i> blogged about.
</I>&gt;<i>
</I>&gt;<i> According RabbitMQ Java Client Documentation:
</I>&gt;<i> While a Channel can be used by multiple threads, it's important to  
</I>&gt;<i> ensure
</I>&gt;<i>  * that only one thread executes a command at once. Concurrent  
</I>&gt;<i> execution of
</I>&gt;<i>  * commands will likely cause an UnexpectedFrameError to be thrown.
</I>&gt;<i>
</I>&gt;<i> If you are using erlang client and that you spawn an erlang process  
</I>&gt;<i> for each message(concurrently), does it mean you have to create new  
</I>&gt;<i> channel/per erlang concurrent processes?
</I>
If I understand you correctly, you have a situation with one AMQP  
channel process and more than one user processes who want to use the  
same channel process.

This is possible albeit in a limited fashion, not because of the  
client side implementation, but because of the nature of the protocol.

Essentially,

1) Asynchronous AMQP methods can be sent concurrently;
2) Synchronous AMQP methods must be sent serially.

This is because there is no way to correlate the top and bottom halves  
of a synchronous invocation other than blocking concurrent access to  
the bottom half.

Concurrent access to a synchronous method is detected and an  
illegal_pending_rpc error is thrown. It may be an improvement on the  
library to include the Pid in the error statement.

Fortunately, those methods that you are most likely to want to use  
concurrently are actually asynchronous, i.e. publish and deliver.

The synchronous methods surround for the most part queue declaration,  
binding and general setup/teardown tasks.

These are the kind of things that you probably would not want or need  
to do concurrently.

Having said that, the exceptions to this are the consume and get  
methods.

In the case of consume methods, you could use the consumer_tag  
supplied by the user process to correlate across synchronous RPC  
halves, but you would have to lock on the tag wrt the amqp_channel (to  
allow it guarantee uniqueness), and which defeats the purpose of  
parallelization to a certain extent.

The same logic would theoretically apply to the get method, except  
that there is no tag in the method record to correlate on.

Hence the client's approach is quite simple: force the serialization  
of the synchronous methods.

User processes wanting to handle this situations more gracefully can  
trap this exit.

Please note that this is due to the protocol as opposed to the  
implementation.

HTH,

Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000603.html">[rabbitmq-discuss] rabbitmq erlang client questions: channel access	and flags
</A></li>
	<LI>Next message: <A HREF="000608.html">[rabbitmq-discuss] rabbitmq erlang client questions: channel	access and flags
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#607">[ date ]</a>
              <a href="thread.html#607">[ thread ]</a>
              <a href="subject.html#607">[ subject ]</a>
              <a href="author.html#607">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
