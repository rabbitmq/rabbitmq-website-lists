<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss]  FW: Multiple consumers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20%20FW%3A%20Multiple%20consumers&In-Reply-To=lyodhxq7o6.fsf%40tanto.lshift.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000064.html">
   <LINK REL="Next"  HREF="000067.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss]  FW: Multiple consumers</H1>
    <B>Ben Hood</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20%20FW%3A%20Multiple%20consumers&In-Reply-To=lyodhxq7o6.fsf%40tanto.lshift.net"
       TITLE="[rabbitmq-discuss]  FW: Multiple consumers">0x6e6562 at gmail.com
       </A><BR>
    <I>Sat Jul 28 14:54:04 BST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000064.html">[rabbitmq-discuss] FW: Multiple consumers
</A></li>
        <LI>Next message: <A HREF="000067.html">[rabbitmq-discuss] FW: Multiple consumers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65">[ date ]</a>
              <a href="thread.html#65">[ thread ]</a>
              <a href="subject.html#65">[ subject ]</a>
              <a href="author.html#65">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Matthias,

&gt;<i> Apologies for the delay in responding to you - I have been very busy
</I>&gt;<i> this week.
</I>
No worries. As it turns out, I sent a follow up mail to this list from
work account on Monday and have just received a notification that it
has been returned because it could not get delivered. I am going to
try to incorporate that into this conversation to try to keep things
in context.

The content of Monday's email is between the snip marks:

--snip--
I've just discovered an issue with the patch I sent:

The basic.consume_ok ack message gets sent to the subscriber and not to
the client reader.

To get around this, I extended the basic_consume/7 function in the
amqqueue module to take an acknowledgement Pid as a further argument (
hence making the function basic_consume/8 ).

In the corresponding function in amqueue_process, I set the replies to
sent to this acknowledgement process.

Then in the channel, extended the ch record with an acknowledgement_pid
field which is set according to the context of the mainloop, so the main
loop decides to which Pid an ack is sent to.

Now the basic.consume_ok goes back to the client control process and
only the deliver method goes to the subscriber.
--snip--

&gt;<i> Looks generally ok, with one caveat: Client channels ought to be
</I>&gt;<i> processes. That way you don't funnel everything through a single
</I>&gt;<i> process.
</I>&gt;<i>
</I>&gt;<i> In the direct API the client channel processes ought to be the same as
</I>&gt;<i> the server channel processes, i.e. the user's client code would interact
</I>&gt;<i> directly with the server channel processes.
</I>
Fair point, and I've already begun to refactor the direct client this
week to take this into consideration. What I started to do is to
create a named amqp_client server process for each channel, so that
the protocol flow within a channel is not inhibited by the protocol
flow from another channel that were both using the same amqp_client
process. So everytime a channel is opened by the user, a gen_server
process is started with the name <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">chN at host.</A> An alternative to this
approach would be for the client to save the Pid of the amqp_client
process and expose an API such as

access_request(AmqpClientPid, Realm)

In contrast, if you use the named approach, the API might look this:

access_request(Channel, Host, Realm)

In the Direct API, the host would probably always be the localhost,
but I went initially for a combination of Channel and Host to keep a
consistent API in the networked case. But I think this has been
completely thought through yet, and the each amqp_client process in
the networked case will have to use the same socket connection.

&gt;<i> You appear to be changing the channel's writer pid with every
</I>&gt;<i> basic_consume. That doesn't look right.
</I>
Do you mean in the mainloop_without_framing function?

{method, MethodRecord, Content, WriterPid} -&gt;
        State0 = State#ch{writer_pid = WriterPid},
	    State1 = handle_method(MethodRecord, Content, State0),
	    mainloop_without_framing(State1);

If so, yes, I think that is unecessary since I introduced the concept
of an acknowledgement pid. I will have a look at removing that.

If not, then I don't completely understand.

&gt;<i>
</I>&gt;<i> think the direct consumer case should actually look like this:
</I>&gt;<i>
</I>&gt;<i>   consumer &lt;-- queue
</I>&gt;<i>
</I>&gt;<i> (which is simpler than what I proposed before)
</I>&gt;<i>
</I>&gt;<i> Queue processes maintain a list of consumer processes. In the direct API
</I>&gt;<i> that's the only mapping you need. In the network API the client channel
</I>&gt;<i> processes maintain a mapping from consumer tags to consumer processes.
</I>
So are you saying that you should pass in the consumer's pid to the
rabbit_amqqueue_process and have that maintain a list of consumers?

I don't think I understand this fully. Can you elaborate?

&gt;<i>
</I>&gt;<i> The question is what should the writer_pid be set to in the direct API?
</I>&gt;<i>
</I>&gt;<i> One possibility is to set it to the caller's pid when doing rpc. That
</I>&gt;<i> way rpc can be implemented like this:
</I>&gt;<i>
</I>&gt;<i> rpc(ChannelPid, MethodRecord, Content) -&gt;
</I>&gt;<i>   ChannelPid ! {method, MethodRecord, Content, self()},
</I>&gt;<i>   receive
</I>&gt;<i>      {send_command, MethodRecord} -&gt; MethodRecord
</I>&gt;<i>      ...
</I>&gt;<i>   end.
</I>&gt;<i>
</I>&gt;<i> The tricky bit is how to deal with asynchronous non-consumer events,
</I>&gt;<i> i.e. cases where a channel/transaction/queue processes sends messages to
</I>&gt;<i> a writer process as part of something other than an rpc or message
</I>&gt;<i> delivery. Perhaps the writer_pid should be set to the channel pid?  That
</I>&gt;<i> would require some pretty careful coding to avoid deadlock.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I reckon it may be easier to tackle the network API first. It is the
</I>&gt;<i> more general case and the refactoring it forces will inform our thinking
</I>&gt;<i> on how to best implement the direct API.
</I>
You might be right on this, but I don't see how the networked API will
change anything on the server side, otherwise wouldn't you have to
change the java client as well.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000064.html">[rabbitmq-discuss] FW: Multiple consumers
</A></li>
	<LI>Next message: <A HREF="000067.html">[rabbitmq-discuss] FW: Multiple consumers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#65">[ date ]</a>
              <a href="thread.html#65">[ thread ]</a>
              <a href="subject.html#65">[ subject ]</a>
              <a href="author.html#65">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
