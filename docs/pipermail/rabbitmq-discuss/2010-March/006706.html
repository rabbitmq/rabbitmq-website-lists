<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] SimpleRpcServer send generated queue name to client
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20SimpleRpcServer%20send%20generated%20queue%20name%20to%0A%20client&In-Reply-To=5429EF528F02C34281C8573452C749431AC0E2E538%40ca-win-mbs02.artesis.be">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006557.html">
   <LINK REL="Next"  HREF="006707.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] SimpleRpcServer send generated queue name to client</H1>
    <B>Matthias Radestock</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20SimpleRpcServer%20send%20generated%20queue%20name%20to%0A%20client&In-Reply-To=5429EF528F02C34281C8573452C749431AC0E2E538%40ca-win-mbs02.artesis.be"
       TITLE="[rabbitmq-discuss] SimpleRpcServer send generated queue name to client">matthias at lshift.net
       </A><BR>
    <I>Tue Mar 23 13:57:03 GMT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="006557.html">[rabbitmq-discuss] SimpleRpcServer send generated queue name to client
</A></li>
        <LI>Next message: <A HREF="006707.html">[rabbitmq-discuss] SimpleRpcServer send generated queue name to client
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6706">[ date ]</a>
              <a href="thread.html#6706">[ thread ]</a>
              <a href="subject.html#6706">[ subject ]</a>
              <a href="author.html#6706">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Glenn,

Ergeerts Glenn wrote:
&gt;<i> Like you said the custom filer predicates are very flexible. It could
</I>&gt;<i> be possible to map them to routing keys and use client side 
</I>&gt;<i> filtering as you said, but for security reasons I want control 
</I>&gt;<i> exactly which client receives which messages. So this rules out
</I>&gt;<i> client side filtering I guess?
</I>
Do these security considerations only apply to event types or the event 
filtering predicates too?

If the former, you could go for a hybrid solution where the server 
publishes events to a direct exchange, with the event type as the 
routing key. Each client's queue would then be bound to that exchange 
with binding keys for each of the event types the client is interested 
in. And client-side filtering would take care of the more complex 
filtering predicates.

The creation/deletion of the client queues could be left up to the 
clients, but the access to the exchange could be restricted to the 
server, with all bindings of client queues to the exchange being 
established by that server.

&gt;<i> I did not know about the option of implementing a custom exchange
</I>&gt;<i> type.. Is it hard to do?
</I>
It's fairly straightforward - if you know a bit about Erlang and the 
rabbit internals ;) See 
<A HREF="http://www.lshift.net/blog/2010/01/22/plugin-exchange-types-for-rabbitmq">http://www.lshift.net/blog/2010/01/22/plugin-exchange-types-for-rabbitmq</A> 
for an example.

&gt;<i> it feels strange pulling this application specific logic
</I>&gt;<i> into the communication infrastructure (so tying our application to
</I>&gt;<i> RabbitMQ) to me.. ?
</I>
The standard, but less efficient, approach to implementing arbitrary 
complex routing logic is to introduce a routing client. That is an 
ordinary AMQP client which

a) consumes messages from, say, a single queue bound to a fanout 
exchange to which producer send all publishes,

b) applies the necessary routing logic to compute a set of queues to 
send the message to,

c) publishes copies of the message to the default exchange - one copy 
per queue it needs routing too.

That's the basic setup, which can be suitably embellished by, say, 
consuming from multiple exchanges/queues, and publishing to exchanges 
other than the default exchange. Plus of course you need logic to deal 
with subscription management.

&gt;<i> What would be the disadvantages of doing it with the multiple queues
</I>&gt;<i> as first suggested? Is it performance related? Would it make a big
</I>&gt;<i> difference using a topic exchange compared to for example 20 queues +
</I>&gt;<i> subscriptions? Are there other disadvantages?
</I>
You end up with one queue per client in all solutions proposed so far. 
But there is still a performance advantage of getting rabbit to do as 
much of the routing as possible. That's what it's designed to do, and it 
(mostly) does it very efficiently. For example, if the same message 
needs to go to 10 different queues, doing the routing in application 
code results in ten separate copies of the message, all getting routed 
separately, whereas if rabbit does the routing there will be just one 
copy of the message and the distribution of that message to individual 
queues is done very efficiently.


Regards,

Matthias.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006557.html">[rabbitmq-discuss] SimpleRpcServer send generated queue name to client
</A></li>
	<LI>Next message: <A HREF="006707.html">[rabbitmq-discuss] SimpleRpcServer send generated queue name to client
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6706">[ date ]</a>
              <a href="thread.html#6706">[ thread ]</a>
              <a href="subject.html#6706">[ subject ]</a>
              <a href="author.html#6706">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
