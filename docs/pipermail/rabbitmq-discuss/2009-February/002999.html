<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Examining Queue Failover Behavior
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Examining%20Queue%20Failover%20Behavior&In-Reply-To=3b949f090902111157s2ba96fa8oa1c351ffd42331e1%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002991.html">
   <LINK REL="Next"  HREF="002938.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Examining Queue Failover Behavior</H1>
    <B>Ben Hood</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Examining%20Queue%20Failover%20Behavior&In-Reply-To=3b949f090902111157s2ba96fa8oa1c351ffd42331e1%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Examining Queue Failover Behavior">0x6e6562 at gmail.com
       </A><BR>
    <I>Thu Feb 12 11:32:25 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002991.html">[rabbitmq-discuss] Examining Queue Failover Behavior
</A></li>
        <LI>Next message: <A HREF="002938.html">[rabbitmq-discuss] (semi OT) erlang/otp and PHP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2999">[ date ]</a>
              <a href="thread.html#2999">[ thread ]</a>
              <a href="subject.html#2999">[ subject ]</a>
              <a href="author.html#2999">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jason,

On Wed, Feb 11, 2009 at 7:57 PM, Jason J. W. Williams
&lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">jasonjwwilliams at gmail.com</A>&gt; wrote:
&gt;<i> Well, my only argument would be that a persistent queue doesn't
</I>&gt;<i> guarantee a whole lot if the message never makes it there.
</I>
True. But this is fundamentally a tricky problem to solve without
tightly coupling producers and consumers. In general I think that it
is better for the messaging infrastructure to provide the application
with the primitives it needs to get the desired level of service,
because the application knows more about the application that the
broker does (what this could mean is exemplified below). Basically
what I mean is that exploiting application specific knowledge can help
prevent turning a messaging broker into a database.

&gt;<i> The problem
</I>&gt;<i> it seems to me depends on the application. If the producer has
</I>&gt;<i> pre-knowledge that the message its entrusting to the MQ is important,
</I>&gt;<i> it needs to be able top specify a level of persistence in case the MQ
</I>&gt;<i> crashes before the exchange can route it.
</I>
True and ties in with the above - a blunt yet effective solution would
be to set up some kind of archiving consumer that keeps a copy of each
published message in some kind of store - some people are using
CouchDB for this kind of thing. This pushes the reliability guarantee
up to a layer that can decide what is important and what is not, thus
keeping the core lean and mean.

&gt;<i> Beyond that, I think its up
</I>&gt;<i> to the consumer to make sure here's a queue available for the message.
</I>&gt;<i> But in a failure environment, since exchanges fail over, but queues do
</I>&gt;<i> not, you now have an issue where producers may publish messages before
</I>&gt;<i> consumers can re-attach and recreate the queues. Where as initially,
</I>&gt;<i> neither the exchanges nor the queues would exist until the consumers
</I>&gt;<i> created them, thereby preventing the producers from publishing into
</I>&gt;<i> ether. As I write this out, it now strikes me that that is the crux of
</I>&gt;<i> our issue: Exchange metadata fails over automatically but not queues.
</I>
This is a fair point and ties in with my previous comments about

a) it being tricky to determine a distributed consensus;
b) the questionable semantics of queue deletes for subscriptions
according to the spec;
b) using AMQP events to allow an application to react to changes in the system;

&gt;<i> Regarding RAS, RAS = Reliability, Availability, Serviceability:
</I>&gt;<i> <A HREF="http://en.wikipedia.org/wiki/Reliability,_Availability_and_Serviceability">http://en.wikipedia.org/wiki/Reliability,_Availability_and_Serviceability</A>
</I>
Good to know what TLAs Rabbit is being benchmarked against - in light
of the recent discussion on what a transaction actually is, you could
even suggest this definition to the working group :-)

Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002991.html">[rabbitmq-discuss] Examining Queue Failover Behavior
</A></li>
	<LI>Next message: <A HREF="002938.html">[rabbitmq-discuss] (semi OT) erlang/otp and PHP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2999">[ date ]</a>
              <a href="thread.html#2999">[ thread ]</a>
              <a href="subject.html#2999">[ subject ]</a>
              <a href="author.html#2999">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
