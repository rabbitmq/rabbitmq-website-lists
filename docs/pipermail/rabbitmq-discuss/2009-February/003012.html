<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Cluster Pathology
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Cluster%20Pathology&In-Reply-To=269388e30902130226od942d18s8029842946bd3135%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003010.html">
   <LINK REL="Next"  HREF="003013.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Cluster Pathology</H1>
    <B>Drew Smathers</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Cluster%20Pathology&In-Reply-To=269388e30902130226od942d18s8029842946bd3135%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Cluster Pathology">drew.smathers at gmail.com
       </A><BR>
    <I>Fri Feb 13 15:34:01 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003010.html">[rabbitmq-discuss] Cluster Pathology
</A></li>
        <LI>Next message: <A HREF="003013.html">[rabbitmq-discuss] Cluster Pathology
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3012">[ date ]</a>
              <a href="thread.html#3012">[ thread ]</a>
              <a href="subject.html#3012">[ subject ]</a>
              <a href="author.html#3012">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Feb 13, 2009 at 5:26 AM, Ben Hood &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">0x6e6562 at gmail.com</A>&gt; wrote:
&gt;<i> Drew,
</I>&gt;<i>
</I>&gt;<i> On Thu, Feb 12, 2009 at 7:31 PM, Drew Smathers &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">drew.smathers at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> Steps to reproduce:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. run publisher and consumer against one node to ensure queue is created there:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  $ python publisher.py hostB 5
</I>&gt;&gt;<i>  $ python consumer.py hostB # CTL-C after receiving 5 messages
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 2. run publisher/consumer against other node - hostA
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  $ python publisher.py hostA 20
</I>&gt;&gt;<i>  $ python consumer.py hostA
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 3. Before publisher from step 2 has finished, bring down rabbitmq on hostB
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  hostB $ rabbitmqctl stop
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 4. After publisher from step 2 has finished, restart consumer:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  $ python consumer.py hostA
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Notice messages delivered after hostB was brought down were not delivered.
</I>&gt;<i>
</I>&gt;<i> Yes, this is the behaviour I would expect as well. As indicated
</I>&gt;<i> previously (on this thread and the other related one) this is because
</I>&gt;<i> the queue to which both consumers are subscribed was initially
</I>&gt;<i> declared on node B. Because there is
</I>&gt;<i>
</I>&gt;<i> a) no automatic failover, just recovery;
</I>&gt;<i> b) no propagation of the queue removal event to each consumer (the
</I>&gt;<i> spec compliancy issue);
</I>&gt;<i>
</I>&gt;<i> the queue is taken down and the guy consuming via node A will be none
</I>&gt;<i> the wiser. Any subsequent messages published to that queue will be
</I>&gt;<i> treated as unroutable and hence will be discarded. To recover from
</I>&gt;<i> this situation, you would need to restart node B and restart the
</I>&gt;<i> consumer on node A.
</I>&gt;<i>
</I>
Thanks for the information.  The consumer is not as much my concern as
the publisher (also attached to A) who would continue publishing
messages which should be delivered but get discarded. (Btw, it's still
_very_ unclear to me who to get notification that a message cannot be
routed.)  I'm solving this issue by making publisher attach to only
one node where the queue is defined so socket errors would stop the
publisher; this is appropriate for our system where there are very few
publishers but many consumers.  We're also keeping a rotating log for
critical messages as another point of recovery in the event a
persister log cannot be recovered.  I haven't finalized what to do
from the consumers' perspective except perhaps having some activity
monitor with a timeout to trigger reestablishing a channel, queue
declarations, etc.  Any ideas how to best handle this without to many
complications such as AMQP-level events, etc?

&gt;<i> Obviously it would be nice to have better handling for this kind of
</I>&gt;<i> thing, which will probably happen at some stage.
</I>&gt;<i>
</I>
Yes, please :)  If there are significant performance impacts, I think
it would still be to nice to have as an optional runtime configuration
for applications where &quot;(99.99999%) guaranteed delivery&quot; is a
requirement more than overall throughput.

-Drew


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003010.html">[rabbitmq-discuss] Cluster Pathology
</A></li>
	<LI>Next message: <A HREF="003013.html">[rabbitmq-discuss] Cluster Pathology
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3012">[ date ]</a>
              <a href="thread.html#3012">[ thread ]</a>
              <a href="subject.html#3012">[ subject ]</a>
              <a href="author.html#3012">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
