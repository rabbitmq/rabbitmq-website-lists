<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Millions of Queues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Millions%20of%20Queues&In-Reply-To=499B39F8.2040400%40lindenlab.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003041.html">
   <LINK REL="Next"  HREF="003045.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Millions of Queues</H1>
    <B>Matthias Radestock</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Millions%20of%20Queues&In-Reply-To=499B39F8.2040400%40lindenlab.com"
       TITLE="[rabbitmq-discuss] Millions of Queues">matthias at lshift.net
       </A><BR>
    <I>Tue Feb 17 23:09:10 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003041.html">[rabbitmq-discuss] Millions of Queues
</A></li>
        <LI>Next message: <A HREF="003045.html">[rabbitmq-discuss] Millions of Queues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3042">[ date ]</a>
              <a href="thread.html#3042">[ thread ]</a>
              <a href="subject.html#3042">[ subject ]</a>
              <a href="author.html#3042">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ryan,

Ryan Williams (Which) wrote:
&gt;<i> Hey all, we have a different use case for rabbit than usual.  We'd like 
</I>&gt;<i> to create a rabbit cluster that handles at least 250,000 queues, with at 
</I>&gt;<i> leat 1 million total bindings;
</I>
That should be possible on a single machine with a decent amount of 
memory - just.

&gt;<i> ideally we would have 20+ million and 80+ million respectively.
</I>&gt;<i> Basically we want infinite scalability along the # of queues axis.
</I>
One problem you are going to run into here is that while queue processes 
reside on single nodes (and hence adding more nodes gives you more room 
to host the queue processes), all the routing info - i.e. queue, 
exchange and binding records - is held in memory on each node. 80 
million binding records are unlikely to fit into physical memory.

&gt;<i> We repeated the experiment with a cluster of two machines and achieved 
</I>&gt;<i> basically the same result -- except the &quot;primary&quot; machine (the one 
</I>&gt;<i> ScalabilityTest was interacting with) had most of its memory consumed, 
</I>&gt;<i> and the &quot;secondary&quot; machine had 40% of its memory consumed by beam 
</I>&gt;<i> processes.  Would we have achieved better results by manually targeting 
</I>&gt;<i> ScalabilityTest at the secondary machine as well?
</I>
What you are observing here follows directly from the explanation above 
- the queue and binding records will consume memory on both machines 
whereas the queue processes will only consume memory on the machine on 
which they were created. So by targeting ScalabilityTest at both 
machines you'd be able to balance the memory usage.

&gt;<i> Are we doing something wrong in our setup here?  What's the maximum 
</I>&gt;<i> number of queues that has been achieved by anyone on this list, and how 
</I>&gt;<i> did you get there?
</I>
I am pretty sure Ben managed to get to 100s of thousands of queues and 
bindings in his tests on a single node.

&gt;<i> I see that in this email: 
</I>&gt;<i> <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/2008-October/002150.html">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/2008-October/002150.html</A> 
</I>&gt;<i> , Ben Hood mentions that routing complexity is O(n), where n is the 
</I>&gt;<i> number of bindings, which doesn't bode well for our particular 
</I>&gt;<i> application.  Assuming that I'm interpreting that correctly, is there 
</I>&gt;<i> anything we can do to tackle that problem to enable huge numbers of queues?
</I>
Ben was referring to topic exchanges. For direct exchanges the routing 
cost is linear (or possibly O(n * log n)) in the number of *matching* 
bindings. Does your application definitely require the use of topic 
exchanges or would direct exchanges be sufficient?

Also, regarding the 20/80 million queues/bindings, would it be possible 
to partition these s.t. rather than having a single RabbitMQ cluster 
with that number of queues/bindings you could have n individual RabbitMQ 
servers, each with 1/nth of the queues/bindings? That might involve your 
producers having to publish messages to more than one broker, and 
consumers consuming from more than one broker, but depending on the 
exact nature of your app that may not be too arduous.


Matthias.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003041.html">[rabbitmq-discuss] Millions of Queues
</A></li>
	<LI>Next message: <A HREF="003045.html">[rabbitmq-discuss] Millions of Queues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3042">[ date ]</a>
              <a href="thread.html#3042">[ thread ]</a>
              <a href="subject.html#3042">[ subject ]</a>
              <a href="author.html#3042">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
