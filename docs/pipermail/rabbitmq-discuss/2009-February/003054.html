<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Millions of Queues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Millions%20of%20Queues&In-Reply-To=499BA4B1.4040403%40imatix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003047.html">
   <LINK REL="Next"  HREF="003056.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Millions of Queues</H1>
    <B>Alexis Richardson</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Millions%20of%20Queues&In-Reply-To=499BA4B1.4040403%40imatix.com"
       TITLE="[rabbitmq-discuss] Millions of Queues">alexis.richardson at cohesiveft.com
       </A><BR>
    <I>Wed Feb 18 10:06:23 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003047.html">[rabbitmq-discuss] Millions of Queues
</A></li>
        <LI>Next message: <A HREF="003056.html">[rabbitmq-discuss] Millions of Queues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3054">[ date ]</a>
              <a href="thread.html#3054">[ thread ]</a>
              <a href="subject.html#3054">[ subject ]</a>
              <a href="author.html#3054">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Martin, Ryan,

On Wed, Feb 18, 2009 at 6:03 AM, Martin Sustrik &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">sustrik at imatix.com</A>&gt; wrote:
&gt;<i> Ryan,
</I>&gt;<i>
</I>&gt;&gt;&gt;<i>   To be more clear
</I>&gt;&gt;&gt;<i> about our use case, we want to create a chat room system, where each
</I>&gt;&gt;&gt;<i> user is a member of K rooms.  The way we're thinking of modeling this is
</I>&gt;&gt;&gt;<i> that each room is represented as a (direct) routing key, and each user
</I>&gt;&gt;&gt;<i> has an individual queue which is then bound to K routing keys.  There's
</I>&gt;&gt;&gt;<i> not really any pattern between users and rooms, so if we partitioned the
</I>&gt;&gt;&gt;<i> queues (and thus users) among clusters, any message sent to an
</I>&gt;&gt;&gt;<i> individual room would have to get sent to every cluster on the (small)
</I>&gt;&gt;&gt;<i> chance that a listening user was in that cluster.  It'd work for a
</I>&gt;&gt;&gt;<i> while, but it can't possibly scale indefinitely.  Is there perhaps a
</I>&gt;&gt;&gt;<i> better way to structure this application?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Answering my own question, another way to structure this would be to
</I>&gt;&gt;<i> partition on routing key, such that when sending to or binding to a
</I>&gt;&gt;<i> particular routing key, the client connects to the same cluster.
</I>
As Matthias said, this is a good pattern.  You may want to use hashing
to provide a uniform distribution across nodes.

If you look at say Twitter, a solution would work in a similar sort of
way.  Each user has a queue representing the consolidated feed of
people whose tweets they follow.  Each 'follow' relationship is a
binding from that queue to the (direct) exchange.  The keys can just
be user names.  So, each queue will be bound to the exchange N times,
if the queue owner is following N people.



&gt;&gt;<i> The
</I>&gt;&gt;<i> downside of this is that, at the extreme, each chat room participant
</I>&gt;&gt;<i> will have to maintain as many connections as rooms they are in (since at
</I>&gt;&gt;<i> the extreme each chat room would be hosted in its own cluster).  But
</I>&gt;&gt;<i> assuming K (the number of chat rooms a user can be in) is finite, then
</I>&gt;&gt;<i> it's not as bad as replicating every message across the entire cluster.
</I>
On option (probably not the best but worth mulling over) is to use the
twitter pattern that I described.  This would mean each chat room
participant has exactly one connection to the cluster.  The price you
pay is that the chat room participant's queue contains messages from
each chat room that they are in.  You would need to disaggregate the
feed at the point of consumption.


&gt;<i> This is a classic example of application that requires pub/sub
</I>&gt;<i> federation. I don't believe it's implemented in RabbitMQ yet, but it
</I>&gt;<i> should be doable.
</I>
Martin, you could achieve this using the relay queue in Ben's shovel,
rather than a true federation, right?  This is because the model you
describe is actually  a cascade, with messages propagating in one
direction through a ramified 'branching tree' structure, with view
consistency at every point.  If the branches recombined, then we would
want a true federation.  But they don't afaict.

Although, I am not convinced a federated solution is needed at all.
The cluster should suffice, no?

alexis


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003047.html">[rabbitmq-discuss] Millions of Queues
</A></li>
	<LI>Next message: <A HREF="003056.html">[rabbitmq-discuss] Millions of Queues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3054">[ date ]</a>
              <a href="thread.html#3054">[ thread ]</a>
              <a href="subject.html#3054">[ subject ]</a>
              <a href="author.html#3054">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
