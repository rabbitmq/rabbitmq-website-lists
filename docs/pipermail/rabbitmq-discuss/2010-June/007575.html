<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] RabbitMQ - Not able to get sets of messages	in the same order
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20RabbitMQ%20-%20Not%20able%20to%20get%20sets%20of%20messages%0A%09in%20the%20same%20order&In-Reply-To=%3CAANLkTiljx4EM28edhAhLUqrumcVZppyr0jE2FITKeNEF%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007572.html">
   <LINK REL="Next"  HREF="007577.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] RabbitMQ - Not able to get sets of messages	in the same order</H1>
    <B>Srijanani Srinivasan</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20RabbitMQ%20-%20Not%20able%20to%20get%20sets%20of%20messages%0A%09in%20the%20same%20order&In-Reply-To=%3CAANLkTiljx4EM28edhAhLUqrumcVZppyr0jE2FITKeNEF%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] RabbitMQ - Not able to get sets of messages	in the same order">srijanani.s at gmail.com
       </A><BR>
    <I>Tue Jun 15 17:45:03 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="007572.html">[rabbitmq-discuss] RabbitMQ - Not able to get sets of messages in the same order
</A></li>
        <LI>Next message: <A HREF="007577.html">[rabbitmq-discuss] RabbitMQ - Not able to get sets of messages in the same order
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7575">[ date ]</a>
              <a href="thread.html#7575">[ thread ]</a>
              <a href="subject.html#7575">[ subject ]</a>
              <a href="author.html#7575">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for your response Simon.

I was not using Basic.QOS method to set the prefetch count so far. After
your suggestion, I modified the code to follow the same order like you said
and I tested it. I see that the order is preserved, when a new
channel/consumer is created for accessing the next set of messages. But, if
we don't acknowledge a certain set of messages, like you said, the order is
not preserved as they will be getting re-delivered.

In my application, we have high volume of messages that are going to be
coming in through the queue. And we will have to do some calculation and
store data in database. We have realized earlier that saving the data one by
one is time consuming, so we will take one set of say 5000 messages and then
do the calculations and store it the database in one database call. So
basically, we do not want to process one by one to save database calls.
Another reason, is that there could be a lot of duplicate messages, so we
will pick 5000 and do the work only for the unique ones.

Is there any performance gain if we ACK a set of messages instead of ACKing
one by one, as we are reducing the number of responses sent from the client
side when we do bulk ACks?

On Tue, Jun 15, 2010 at 7:45 AM, Simon MacMullen &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">simon at rabbitmq.com</A>&gt; wrote:

&gt;<i> Hi Srijanani.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On 10/06/10 15:53, Srijanani Srinivasan wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Thanks for your response. What you said makes sense. When the messages
</I>&gt;&gt;<i> that have not been acknowledged are put back to the queue, then
</I>&gt;&gt;<i> the other messages added in the meantime should be the ones to be
</I>&gt;&gt;<i> de-queued first right in the FIFO manner? But like you said, i guess
</I>&gt;&gt;<i> thats not how it works.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> There isn't a guarantee about ordering for redelivered messages in the spec
</I>&gt;<i> (since in more complex cases it's impossible to guarantee anyway), and
</I>&gt;<i> Rabbit tries to do the most efficient thing rather than be FIFO in cases
</I>&gt;<i> where it can.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  The same problem occurs, when I get a set of messages and don't
</I>&gt;&gt;<i> acknowledge them and close the channel (in the event of any exceptions).
</I>&gt;&gt;<i> When we get the messages, they do not come in the correct order.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Exactly.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  I guess, if i want to get sets of messages instead of one at a time, I
</I>&gt;&gt;<i> must try to use the same channel. Is that right?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> You could do that if it's convenient for you. Alternatively, you could
</I>&gt;<i> prevent messages from being redelivered by making sure the server only sends
</I>&gt;<i> you as many as you will actually process (if you know how many that is).
</I>&gt;<i>
</I>&gt;<i> Oleg suggests you set the prefetch count to 1 - this will ensure that the
</I>&gt;<i> server only sends you one message until you ack it (which will block if
</I>&gt;<i> you're trying to process 100 at once).
</I>&gt;<i>
</I>&gt;<i> So if you're currently reading in 100 messages and then acking all of them
</I>&gt;<i> you could set the prefetch count to 100. The server will then allow you 100
</I>&gt;<i> unacked messages. You'd need to make sure you cancel before acking,
</I>&gt;<i> otherwise the server can send you more messages between acking and closing
</I>&gt;<i> the channel.
</I>&gt;<i>
</I>&gt;<i> So to summarise:
</I>&gt;<i>
</I>&gt;<i> channel.open
</I>&gt;<i> basic.qos(prefetch_count = 100)
</I>&gt;<i> basic.consume
</I>&gt;<i> (consume 100 messages)
</I>&gt;<i> basic.cancel
</I>&gt;<i> (ack 100 messages)
</I>&gt;<i>
</I>&gt;<i> I'd be interested to know why you need to process messages in batches
</I>&gt;<i> though.
</I>&gt;<i>
</I>&gt;<i> Cheers, Simon
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> On Thu, Jun 10, 2010 at 9:38 AM, Oleg Zhurakousky
</I>&gt;&gt;<i> &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ozhurakousky at vmware.com</A> &lt;mailto:<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ozhurakousky at vmware.com</A>&gt;&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Not sure about C# API, and how you are building the next set of
</I>&gt;&gt;<i>    messages, but here is what I belive is happening.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Channel prefetch messages. That is different then invoking a
</I>&gt;&gt;<i>    consumer. THis means that you might have 1000 prefetched messages in
</I>&gt;&gt;<i>    your channel, while you are still processing 21st message. Whatever
</I>&gt;&gt;<i>    you un-acknowledge is put back into the queue once the channel is
</I>&gt;&gt;<i>    closed. AMQO does not define an ordering of messages for re-queueing.
</I>&gt;&gt;<i>    One way to leverage this scenario is to set prefetchCount to 1. This
</I>&gt;&gt;<i>    way there will never me more then one prefetched messages in your
</I>&gt;&gt;<i>    channel.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Oleg
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    On Jun 10, 2010, at 10:24 AM, Srijanani Srinivasan wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    I am using Rabbit MQ in C#. This is my scenario
</I>&gt;&gt;<i>    1.               A separate process publishes messages to the queue
</I>&gt;&gt;<i>    2.               Client has to read set of N messages from queue
</I>&gt;&gt;<i>    3.               Process the N messages
</I>&gt;&gt;<i>    4.               Acknowledge the N messages
</I>&gt;&gt;<i>    5.               Repeat steps 2 to 4 continuously to process all
</I>&gt;&gt;<i>    sets of messages
</I>&gt;&gt;<i>    Under the same channel, I receive the messages and then process them
</I>&gt;&gt;<i>    and then acknowledge them. The server process keeps publishing
</I>&gt;&gt;<i>    messages. The problem I am facing is, when I try to get next set of
</I>&gt;&gt;<i>    messages, they do not come in the same order as it was published by
</I>&gt;&gt;<i>    the publishing process. The messages come in a random order. Only
</I>&gt;&gt;<i>    the first set of messages comes in the correct order.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Does any one what is going wrong here? Is creating a new channel to
</I>&gt;&gt;<i>    access the next set of messages not right? Or is there a problem
</I>&gt;&gt;<i>    caused because of acknowledging multiple messages? Please help me
</I>&gt;&gt;<i>    understand why this does not work correctly.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Below is the sample code:
</I>&gt;&gt;<i>    while (true)
</I>&gt;&gt;<i>                {
</I>&gt;&gt;<i>                    using (IModel getChannel = MQConnection.CreateModel())
</I>&gt;&gt;<i>                    {
</I>&gt;&gt;<i>                        // Create a consumer
</I>&gt;&gt;<i>                        QueueingBasicConsumer consumer =
</I>&gt;&gt;<i>    CreateQueueConsumer(getChannel, exchangeName, queueName);
</I>&gt;&gt;<i>                        int numberOfMessages = 100;
</I>&gt;&gt;<i>                        // Next Recieve
</I>&gt;&gt;<i>                        List&lt;object&gt; msgSet =
</I>&gt;&gt;<i>    GetNextSetOfMessages(consumer, getChannel, exchangeName, queueName,
</I>&gt;&gt;<i>    numberOfMessages,             out finalDeliverytag);
</I>&gt;&gt;<i>                        // Do some processing
</I>&gt;&gt;<i>                        //Acknowledge finished messages by passing in
</I>&gt;&gt;<i>    the delivery tag.
</I>&gt;&gt;<i>                        // calls the method BasicAck with multiple
</I>&gt;&gt;<i>    param=true
</I>&gt;&gt;<i>                        if (finalDeliverytag &gt; 0)
</I>&gt;&gt;<i>                            AckFinishedMessages(exchangeName, queueName,
</I>&gt;&gt;<i>    finalDeliverytag, getChannel);
</I>&gt;&gt;<i>                        if (finalDeliverytag == 0)
</I>&gt;&gt;<i>                            break;
</I>&gt;&gt;<i>                    }
</I>&gt;&gt;<i>                }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    Thanks for your help in advance!
</I>&gt;&gt;<i>    Srijanani
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    &lt;ATT00001..txt&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> rabbitmq-discuss mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100615/c54fb4ab/attachment-0001.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100615/c54fb4ab/attachment-0001.htm</A>&gt;
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007572.html">[rabbitmq-discuss] RabbitMQ - Not able to get sets of messages in the same order
</A></li>
	<LI>Next message: <A HREF="007577.html">[rabbitmq-discuss] RabbitMQ - Not able to get sets of messages in the same order
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7575">[ date ]</a>
              <a href="thread.html#7575">[ thread ]</a>
              <a href="subject.html#7575">[ subject ]</a>
              <a href="author.html#7575">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
