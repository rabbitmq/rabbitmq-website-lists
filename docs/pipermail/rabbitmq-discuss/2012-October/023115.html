<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Use a mysql databse table as the provider for rabbitmq queue
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Use%20a%20mysql%20databse%20table%20as%20the%20provider%0A%20for%20rabbitmq%20queue&In-Reply-To=%3CCAG%3DbwtM4uPEw8JQ-9jTJPy0z%3D8xgVLDVxNo_Sdt1%2BxcOYBnMAA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023112.html">
   <LINK REL="Next"  HREF="023117.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Use a mysql databse table as the provider for rabbitmq queue</H1>
    <B>Ryan R.</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Use%20a%20mysql%20databse%20table%20as%20the%20provider%0A%20for%20rabbitmq%20queue&In-Reply-To=%3CCAG%3DbwtM4uPEw8JQ-9jTJPy0z%3D8xgVLDVxNo_Sdt1%2BxcOYBnMAA%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] Use a mysql databse table as the provider for rabbitmq queue">ryan.rajkomar at gmail.com
       </A><BR>
    <I>Wed Oct 17 11:40:35 BST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="023112.html">[rabbitmq-discuss] Use a mysql databse table as the provider for rabbitmq queue
</A></li>
        <LI>Next message: <A HREF="023117.html">[rabbitmq-discuss] Use a mysql databse table as the provider for rabbitmq queue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23115">[ date ]</a>
              <a href="thread.html#23115">[ thread ]</a>
              <a href="subject.html#23115">[ subject ]</a>
              <a href="author.html#23115">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I think I understand what you mean with the shared library.
However, in my case, RabbitMQ would only be installed if need be (meaning
more than one of the apps are present, and two of those need to be
synchronised for part of their data).

That said, using a shared library would require me to &quot;include/import&quot; said
library when I need to, therefore making me change my app code depending of
the situation I'm in.

And said library would only be required when there's a RabbitMQ available
anyway.

Now a bit further in your message you talk about a listener library.
I'd like to know a bit more about this.
How would an external library be able to listen to anything happening
within my app ?
Would it be listening on the DB queries ?

Cheers,
Ryan.

2012/10/17 Tim Watson &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">tim at rabbitmq.com</A>&gt;

&gt;<i>  Hi
</I>&gt;<i>
</I>&gt;<i> Please keep the list on CC - the info is useful for everyone. :)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On 10/17/2012 11:05 AM, Ryan R. wrote:
</I>&gt;<i>
</I>&gt;<i> Hi,
</I>&gt;<i> Thanks for that long and quite detailed answer.
</I>&gt;<i>
</I>&gt;<i> Based on what you're saying plugging the rabbitmq provider directly on the
</I>&gt;<i> table would not be ideal and would most likely bring issues that I'd rather
</I>&gt;<i> avoid.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That's certainly my view.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That said, could you provide some insight on a potentielly viable solution
</I>&gt;<i> for my project.
</I>&gt;<i> Reminder :
</I>&gt;<i> I want to keep my applications separate in terms of DB and code (avoid
</I>&gt;<i> triggers if possible)
</I>&gt;<i> The reason for this is that depending on the situations, I would deploy
</I>&gt;<i> only one, two, or more applications out of the whole project ( which
</I>&gt;<i> roughly includes about 5 separate applications, each of which needs to be
</I>&gt;<i> fully usable withou the others as well as with, without changing code not
</I>&gt;<i> db config)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> From what I'm hearing, the primary concern here is that we want to be able
</I>&gt;<i> to deploy any application in isolation and have it still work, regardless
</I>&gt;<i> of whether or not the others are up an running. This is exactly the kind of
</I>&gt;<i> scenario where messaging is supposed to help! If it was me, I would look at
</I>&gt;<i> data first and foremost, and ask myself what information needs to be
</I>&gt;<i> publicised. In each application I would publish that information, not via
</I>&gt;<i> the database (which I would keep for internal use), but by publishing data
</I>&gt;<i> to an exchange on the RabbitMQ broker. Publication is asynchronous and will
</I>&gt;<i> not fail if there are no consumers - the data will simply get routed to a
</I>&gt;<i> queue and sit there until someone eventually 'asks for it'. Then I would
</I>&gt;<i> look at what external information my application(s) might want to consume.
</I>&gt;<i> I would set up each application to consume only data it needs, again from
</I>&gt;<i> the messaging broker not the database. Consuming can be asynchronous or
</I>&gt;<i> synchronous - you can choose which - and worker threads or other similar
</I>&gt;<i> tools can be used make this information available to the 'main application
</I>&gt;<i> code' when required. A nice client library may do some or all of this
</I>&gt;<i> 'worker/listener with callbacks' stuff for you.
</I>&gt;<i>
</I>&gt;<i> Now lets consider that design for a moment. Each application publishes
</I>&gt;<i> data (asynchronously) regardless of whether or not someone is around to
</I>&gt;<i> consume it. If there are no consumers, the data sits around in the queue.
</I>&gt;<i> If you don't want this, then you can have the data expire immediately or
</I>&gt;<i> after some timeout - rabbit will allow you do configure all of these
</I>&gt;<i> patterns quite easily. The consuming part introduces slightly more new
</I>&gt;<i> paths on your code, as you've got to decide how to get received messages
</I>&gt;<i> from the consuming callbacks, back into the application code, but this
</I>&gt;<i> isn't too hard. You can configure rabbit so that each message is consumed
</I>&gt;<i> by only one application, or a copy is sent to all consumers, or you can
</I>&gt;<i> route messages to specific consumers based on routing keys. The
</I>&gt;<i> possibilities are numerous, and many good examples are available in the
</I>&gt;<i> tutorials on our website!!!
</I>&gt;<i>
</I>&gt;<i> Now the only common thing that you've got to deal with in each application
</I>&gt;<i> is plugging in the messaging sub system - i.e., each application needs to
</I>&gt;<i> hook up to RabbitMQ using a client API and write a bit of glue code for
</I>&gt;<i> publishing and consuming. Apart from that common factor, which if your
</I>&gt;<i> applications are all written in the same language, can be delegated to a
</I>&gt;<i> shared library, you've kept those applications completely decoupled.
</I>&gt;<i>
</I>&gt;<i> I hope that helps you to get started thinking about ways in which rabbit
</I>&gt;<i> could help with your project. I do recommend going through the tutorials to
</I>&gt;<i> get an idea of some of what's possible, and do feel free to come back here
</I>&gt;<i> and ask about anything that's unclear or just to discuss ideas with the
</I>&gt;<i> rest of the community.
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> Tim
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i> Ryan.
</I>&gt;<i>
</I>&gt;<i> 2012/10/17 Tim Watson &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">tim at rabbitmq.com</A>&gt;
</I>&gt;<i>
</I>&gt;&gt;<i>  Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On 10/17/2012 09:58 AM, Shadowalker wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I've just stumbled upon rabbitmq and I think it could very well help in a
</I>&gt;&gt;<i> project that I'm currently working on. But there's one thing that I'd like
</I>&gt;&gt;<i> to get some input about though :
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My project consist of one, two or more applications that, though
</I>&gt;&gt;<i> separated, need to keep some of their datas synchronized.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For example say I have two use cases that could happen at the same time :
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> First project has a app A and a app B : when app A insert some specific
</I>&gt;&gt;<i> data in its db i need to get a meesage to appB to do the corresponding
</I>&gt;&gt;<i> action on its own db
</I>&gt;&gt;<i> Second project has only app A and when I insert stuff in A's db it
</I>&gt;&gt;<i> shouldn't send anything anywhere.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In both cases, I'll like to have app A and app B identical : I don't want
</I>&gt;&gt;<i> to have to change app A's code jsut because app B is here.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So my question is : Is there anyway to plug the raabitmq consumer
</I>&gt;&gt;<i> directly onto a specific table in app A's database so that every time
</I>&gt;&gt;<i> something happens appB can come and consume the data.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Well, I'm not sure I would choose this approach personally, and I'll
</I>&gt;&gt;<i> explain why. But as I'm rather attention deficit I'll cut to the chase
</I>&gt;&gt;<i> first and say &quot;yes - it is *possible* to do this - but you'll have to put
</I>&gt;&gt;<i> in a lot of work to make it happen&quot; and as I said, I certainly wouldn't
</I>&gt;&gt;<i> recommend doing it. Now I'll explain why it's a bad idea IMHO and then I'll
</I>&gt;&gt;<i> explain how you can do it if you insist on following this path.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> First of all, you are creating a very tight coupling between the
</I>&gt;&gt;<i> application and the database schema, which will be difficult to work with
</I>&gt;&gt;<i> if the design changes (which most do) over time. Secondly, you are going to
</I>&gt;&gt;<i> be running code *inside the database server* which is fraught with danger.
</I>&gt;&gt;<i> Thirdly, it's going to be very difficult to test and/or debug when things
</I>&gt;&gt;<i> go wrong. Our industry tends to favour integrating systems using messaging
</I>&gt;&gt;<i> technology so much because doing so decouples applications from one
</I>&gt;&gt;<i> another, at least to a certain extent.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The deceptively simple alternative to messaging, and it is often
</I>&gt;&gt;<i> ineffective and costly to develop and maintain, is to share data using
</I>&gt;&gt;<i> files and/or a shared database. Both applications share tables and/or
</I>&gt;&gt;<i> schemas and either poll for changes using worker processes (or threads) on
</I>&gt;&gt;<i> the one hand, or utilise notification features of the database system
</I>&gt;&gt;<i> itself on the other (e,g., Microsoft SQL Server Notification Services). But
</I>&gt;&gt;<i> this approach is full of problems, ranging from contention for reads/writes
</I>&gt;&gt;<i> on shared tables, to timing issues where both applications make very subtle
</I>&gt;&gt;<i> implicit assumptions about the order in which the various participants in
</I>&gt;&gt;<i> the system are interacting with the database, leading to functional errors.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> One reason that messaging based integration has been so successful is
</I>&gt;&gt;<i> that it gets us *away* from these problems, and allows applications to
</I>&gt;&gt;<i> simplify their model of interaction with the outside world. AMQP in
</I>&gt;&gt;<i> particular allows an application developer to think in terms of
</I>&gt;&gt;<i> asynchronously publishing events (for consumption elsewhere) or consuming
</I>&gt;&gt;<i> data in a variety of ways, based purely on the usage pattern required.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Let's assume that you did implement this capability and whenever your
</I>&gt;&gt;<i> publishing application writes to the database, a message gets sent to an
</I>&gt;&gt;<i> exchange on a rabbit broker somewhere, which the other application is
</I>&gt;&gt;<i> consuming via some queue. What happens if the machine or data centre the
</I>&gt;&gt;<i> broker is running on crashes? What happens if the broker becomes overloaded
</I>&gt;&gt;<i> and starts to assert tcp back-pressure on the publisher - which, remember,
</I>&gt;&gt;<i> is running inside a database!? What happens if the database server has to
</I>&gt;&gt;<i> be restarted? And each of these 'what happens' questions must be answered
</I>&gt;&gt;<i> from the perspective of
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 1. the code running inside the database server
</I>&gt;&gt;<i> 2. the application writing to the database
</I>&gt;&gt;<i> 3. the application listening to the queue(s)
</I>&gt;&gt;<i> 4. the RabbitMQ broker itself
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That is an *awful* lot of moving parts, one of which is critical to your
</I>&gt;&gt;<i> infrastructure (i.e., the database server) and largely not under you
</I>&gt;&gt;<i> control (in so much as the semantics for running user defined code inside
</I>&gt;&gt;<i> the database server and the error handling behaviour of such, are likely to
</I>&gt;&gt;<i> be highly constrained). Even in an environment where you're running your
</I>&gt;&gt;<i> user defined function in an external operating system process (e.g., Oracle
</I>&gt;&gt;<i> UDFs written in java) the failure modes are terrifying. Even in an
</I>&gt;&gt;<i> environment which gives you a very clear picture of the constrained runtime
</I>&gt;&gt;<i> in which you're operating (e.g., custom .NET code running inside MS SQL
</I>&gt;&gt;<i> Server as a UDF or stored procedure) there are questions about how stable
</I>&gt;&gt;<i> and safe this approach is. And even in those environments, where stability
</I>&gt;&gt;<i> and safety *can* be understood and controlled to some extent, there is
</I>&gt;&gt;<i> still the question of semantics. If the publication fails, what does the
</I>&gt;&gt;<i> application writing to the database see? Does the insert/update fail? Doing
</I>&gt;&gt;<i> so would require making a synchronous call in the trigger/callback, which
</I>&gt;&gt;<i> would block the database server and create contention for the table!
</I>&gt;&gt;<i> Failing to make the call synchronous would lead to silent failures however!
</I>&gt;&gt;<i> There are no happy endings here, I can assure you.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Now that I hope I've put you off this idea, here's how you can do it if
</I>&gt;&gt;<i> you disagree. Write a user defined function in C (consulting
</I>&gt;&gt;<i> <A HREF="http://dev.mysql.com/doc/refman/5.1/en/adding-udf.html">http://dev.mysql.com/doc/refman/5.1/en/adding-udf.html</A> or whatever
</I>&gt;&gt;<i> resources you have available to assist in this) and in your user defined
</I>&gt;&gt;<i> function, use the RabbitMQ native/C client (librabbitmq) to talk to rabbit.
</I>&gt;&gt;<i> The details of doing all of this are left as an exercise to the daring. Do
</I>&gt;&gt;<i> bare in mind that MySQL UDFs *must* be thread safe, that librabbitmq has no
</I>&gt;&gt;<i> explicit support for threading whatsoever and that blocking in a udf is
</I>&gt;&gt;<i> probably the first step on the road to bedlam.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Cheers,
</I>&gt;&gt;<i> Tim
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Cheers,
</I>&gt;&gt;<i> Shadowalker.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> rabbitmq-discuss mailing <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">listrabbitmq-discuss at lists.rabbitmq.comhttps</A>://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20121017/81b4be2b/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20121017/81b4be2b/attachment.htm</A>&gt;
</PRE>



























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023112.html">[rabbitmq-discuss] Use a mysql databse table as the provider for rabbitmq queue
</A></li>
	<LI>Next message: <A HREF="023117.html">[rabbitmq-discuss] Use a mysql databse table as the provider for rabbitmq queue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23115">[ date ]</a>
              <a href="thread.html#23115">[ thread ]</a>
              <a href="subject.html#23115">[ subject ]</a>
              <a href="author.html#23115">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
