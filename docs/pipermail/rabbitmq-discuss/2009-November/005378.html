<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] RabbitMQ crashes hard when it runs out of	memory
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20RabbitMQ%20crashes%20hard%20when%20it%20runs%20out%20of%0A%09memory&In-Reply-To=20091106104343.GE30680%40wellquite.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005367.html">
   <LINK REL="Next"  HREF="005424.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] RabbitMQ crashes hard when it runs out of	memory</H1>
    <B>Stephen Day</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20RabbitMQ%20crashes%20hard%20when%20it%20runs%20out%20of%0A%09memory&In-Reply-To=20091106104343.GE30680%40wellquite.org"
       TITLE="[rabbitmq-discuss] RabbitMQ crashes hard when it runs out of	memory">sjaday at gmail.com
       </A><BR>
    <I>Fri Nov  6 20:57:33 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="005367.html">[rabbitmq-discuss] RabbitMQ crashes hard when it runs out of memory
</A></li>
        <LI>Next message: <A HREF="005424.html">[rabbitmq-discuss] RabbitMQ crashes hard when it runs out of memory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5378">[ date ]</a>
              <a href="thread.html#5378">[ thread ]</a>
              <a href="subject.html#5378">[ subject ]</a>
              <a href="author.html#5378">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Nov 6, 2009 at 2:43 AM, Matthew Sackman &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">matthew at lshift.net</A>&gt; wrote:

&gt;<i> On Fri, Nov 06, 2009 at 10:06:20AM +0000, Matthew Sackman wrote:
</I>&gt;<i> &gt; That's fine. I have to say that it's unlikely this patch will make it
</I>&gt;<i> &gt; through - the memory management code has gone through a lot of change
</I>&gt;<i> &gt; recently as we're getting a much better handle on resource management.
</I>&gt;<i>
</I>Agreed. This is a definitely a workaround fix for the problem. In the
interest of full disclosure, I have gotten rabbitmq to crash with this patch
for the same reason, by getting the memory to spike before excess can be
collected, so this isn't a full fix by any means. I will try to dig further
into the root cause in 1.7.0 release when I have time.


&gt;<i> &gt; Whilst you've obviously been working from the head of our default branch
</I>&gt;<i> &gt; (many thanks!), there are a couple of issues with garbage collecting
</I>&gt;<i> &gt; every process like that, for example, it's possible that garbage
</I>&gt;<i> &gt; collecting vast numbers of processes will take longer than the
</I>&gt;<i> &gt; memory_check_interval, making messages queue up for the memory manager
</I>&gt;<i> &gt; process. This would become a problem if the garbage collection is unable
</I>&gt;<i> &gt; to reclaim any memory at all - eg millions of queues, all of which are
</I>&gt;<i> &gt; empty.
</I>&gt;<i>
</I>However, with rabbit's current memory problems, I wouldn't run it with more
than 10 queues, let alone millions ;). I will give the java client test a
try.


&gt;<i>
</I>&gt;<i> Some immediate ideas to improve this a little.
</I>&gt;<i> 1) Only do the GC when you initially hit the memory alarm. I.e. in the
</I>&gt;<i> first case when going from non-alarmed to alarmed, put the gc in there,
</I>&gt;<i> then maybe recurse again (though you'll likely want another param on the
</I>&gt;<i> function to stop infinite recursion).
</I>&gt;<i>
</I>This was my initial thought as well. However, by the time the alarm goes
off, it is often too late for this to stop rabbit from crashing. For
example, the default memory alarm is set to 0.95. Many of the crashes where
to due to a failed allocation of 200-300 MB by the VM. At 4GB (rounding
*up*), 200 MB is the limit of the allocation that can be made before garbage
collecting (1 - .2/4 = 0.95). So, if more is allocated, the server is dead
in the water.


&gt;<i> 2) Only put GC in processes that are known to eat lots of RAM. Eg if
</I>&gt;<i> it's the persister, then putting in a manual GC right after it does a
</I>&gt;<i> snapshot is probably a good idea.
</I>&gt;<i>
</I>The persister is indeed where the binary memory is hanging around, but I am
not sure if the snapshot point is the problem. The crashes happen when
adding batches into the queue. Its like the persister can't keep up.

For now, I will try this at the same point shown in the patch, but only do
the persister:

garbage_collect(whereis(rabbit_persister)).

I would say the correct pattern would be something like python's MemoryError
or handling of a malloc failure in C. Is there an exception that is thrown,
where a garbage collect can be run?

_steve
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20091106/2e712c63/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20091106/2e712c63/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005367.html">[rabbitmq-discuss] RabbitMQ crashes hard when it runs out of memory
</A></li>
	<LI>Next message: <A HREF="005424.html">[rabbitmq-discuss] RabbitMQ crashes hard when it runs out of memory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5378">[ date ]</a>
              <a href="thread.html#5378">[ thread ]</a>
              <a href="subject.html#5378">[ subject ]</a>
              <a href="author.html#5378">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
