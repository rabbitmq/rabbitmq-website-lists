<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Message redelivering doubt with one and with more than one consumers.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Message%20redelivering%20doubt%20with%20one%20and%20with%0A%20more%20than%20one%20consumers.&In-Reply-To=%3C20110214233853.GB2366%40dakota.doc.ic.ac.uk%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011250.html">
   <LINK REL="Next"  HREF="011283.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Message redelivering doubt with one and with more than one consumers.</H1>
    <B>Alexandru Scvor&#355;ov</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Message%20redelivering%20doubt%20with%20one%20and%20with%0A%20more%20than%20one%20consumers.&In-Reply-To=%3C20110214233853.GB2366%40dakota.doc.ic.ac.uk%3E"
       TITLE="[rabbitmq-discuss] Message redelivering doubt with one and with more than one consumers.">alexandru at rabbitmq.com
       </A><BR>
    <I>Mon Feb 14 23:38:53 GMT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="011250.html">[rabbitmq-discuss] Message redelivering doubt with one and with more than one consumers.
</A></li>
        <LI>Next message: <A HREF="011283.html">[rabbitmq-discuss] Message redelivering doubt with one and with more than one consumers.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11253">[ date ]</a>
              <a href="thread.html#11253">[ thread ]</a>
              <a href="subject.html#11253">[ subject ]</a>
              <a href="author.html#11253">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Alfonso,

&gt;<i> The use of basic.reject{requeue=true} implies that there is no need to
</I>&gt;<i> un-ack messages thus counting those messages and calling basic.recover
</I>&gt;<i> to put them again in the queue is not necessary.
</I>&gt;<i> So when receiving messages the only possible actions are basic.ack for
</I>&gt;<i> messages OK, basic.reject{requeue=true}  for messages that couldn't be
</I>&gt;<i> processed and basic.reject{requeue=false} for discarding the messages
</I>&gt;<i> we don't want to process.
</I>&gt;<i> In this scenario I think that un-ack'd messages are only possible when
</I>&gt;<i> the consumer crashes or it is stopped so basic.recover calls are
</I>&gt;<i> totally unnecessary because, as you said, the messages will be requeue
</I>&gt;<i> when a consumer is connected again.
</I>&gt;<i> Am I right or am I missing something?
</I>
That sounds about right.

Basic.recover means ``requeue all unacknowledged messages now''.
Basic.reject means ``requeue/discard the following messages now''.

So, basic.reject{requeue=true} can be seen as a more specific version of
basic.recover{requeue=true}.

&gt;<i> An also I suppose it is better to actively response to Rabbit about
</I>&gt;<i> the messages (discarding  or requeing using basic.reject) instead of
</I>&gt;<i> &quot;not respoding&quot; for un-ack them.
</I>
It depends.  For instance, from the broker's point of view, there's no
difference in overhead between un-ack'd messages and undelivered
messages.  Rejecting{requeue=false} and ack'ing messages will free up
some RAM and some disk space.

It's probably good practice to tell the broker what it should do with
the messages as soon as possible, but it doesn't matter that much.  If
the broker starts running out of RAM, it will write more messages to
disk.  If it's really running low on RAM, it will throttle publishers.

Cheers,
Alex

On Mon, Feb 14, 2011 at 11:24:14PM +0100, Alfonso Pantoja wrote:
&gt;<i> Hi Alex,
</I>&gt;<i> 
</I>&gt;<i> Thank for that clear explanation. You really helped me.
</I>&gt;<i> 
</I>&gt;<i> In the first approach of my code I didn't ack messages that couldn't
</I>&gt;<i> be processed by my business logic (for instance when they couldn't be
</I>&gt;<i> stored in the database due to a connection error) so I counted then
</I>&gt;<i> un-ack'd messages and when they reach a threshold number I called
</I>&gt;<i> basic.recover because as I read on the documentation basic.reject was
</I>&gt;<i> not implemented in 1.7.2.
</I>&gt;<i> Now using 2.2.0 version (server and API) I replaced basic.recover with
</I>&gt;<i> basic.reject which doesn't requeue the whole messages in the queue as
</I>&gt;<i> basic.recover did (and the CPU wasn't very 'happy' with it)
</I>&gt;<i> 
</I>&gt;<i> The use of basic.reject{requeue=true} implies that there is no need to
</I>&gt;<i> un-ack messages thus counting those messages and calling basic.recover
</I>&gt;<i> to put them again in the queue is not necessary.
</I>&gt;<i> So when receiving messages the only possible actions are basic.ack for
</I>&gt;<i> messages OK, basic.reject{requeue=true}  for messages that couldn't be
</I>&gt;<i> processed and basic.reject{requeue=false} for discarding the messages
</I>&gt;<i> we don't want to process.
</I>&gt;<i> In this scenario I think that un-ack'd messages are only possible when
</I>&gt;<i> the consumer crashes or it is stopped so basic.recover calls are
</I>&gt;<i> totally unnecessary because, as you said, the messages will be requeue
</I>&gt;<i> when a consumer is connected again.
</I>&gt;<i> An also I suppose it is better to actively response to Rabbit about
</I>&gt;<i> the messages (discarding  or requeing using basic.reject) instead of
</I>&gt;<i> &quot;not respoding&quot; for un-ack them.
</I>&gt;<i> 
</I>&gt;<i> Am I right or am I missing something?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Best regards,
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Alfonso
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 2011/2/14 Alexandru Scvor&#355;ov &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">alexandru at rabbitmq.com</A>&gt;:
</I>&gt;<i> &gt; Hi,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; In a scenario with one consumer as I saw in my tests, the consumer
</I>&gt;<i> &gt;&gt; received messages with the Redelivered=true AMQP header atribute.
</I>&gt;<i> &gt;&gt; The consumer was based in the classes provided by the .NET API and as
</I>&gt;<i> &gt;&gt; I remember the consumer-tag is random generated by the server.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sounds good.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; When there is a only one consumer (with a random consumer-tag name)
</I>&gt;<i> &gt;&gt; and a message is not acked when the consumer is reconnected (so has
</I>&gt;<i> &gt;&gt; another random tag name) that message is redelivered?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yes, un-ack'd messages will be redelivered to the consumer when it
</I>&gt;<i> &gt; reconnects. &#160;Be aware, though, they will be redelivered *after* the
</I>&gt;<i> &gt; messages still on the queue (i.e. the undelivered ones) are delivered.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So, if the following messages are published to the queue:
</I>&gt;<i> &gt; &#160;1 2 3 4 5 6
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; And the following are delivered but not ack'd by the consumer:
</I>&gt;<i> &gt; &#160;1 2 3
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; If the consumer crashes and reconnects, the messages delivered in order
</I>&gt;<i> &gt; will be:
</I>&gt;<i> &gt; &#160;4 5 6 1 2 3
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; Based on my experience I think this is true but don't understand that
</I>&gt;<i> &gt;&gt; &quot;If that same consumer then reconnects and creates a new subscription
</I>&gt;<i> &gt;&gt; to the same queue&quot;...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; That's just another way of saying it reconnects and starts consuming
</I>&gt;<i> &gt; again.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; By the was my consumer always tries to create the queue and the
</I>&gt;<i> &gt;&gt; bindings every time it connects to RabbitMQ.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; That's perfect. &#160;You should always do that.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; And also I'm wondering how this behavior acts when there are more than
</I>&gt;<i> &gt;&gt; one consumer (same queue and same bindings)...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Messages are delivered one at a time to consumers in round-robin order.
</I>&gt;<i> &gt; If a message is delivered and the consumer dies, the message is
</I>&gt;<i> &gt; republished to the queue and a consumer will eventually get it (note
</I>&gt;<i> &gt; that it may be the same client if it reconnects).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt; Under what circumstances an unack message wouldn't be redelivered again?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; In none of the circumstances we were talking about. &#160;A client can
</I>&gt;<i> &gt; basic.reject{requeue=false} a message, in which case it will not be
</I>&gt;<i> &gt; requeued.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Hope this helps.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Cheers,
</I>&gt;<i> &gt; Alex
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; On Thu, Feb 10, 2011 at 10:26:53AM +0100, Alfonso Pantoja wrote:
</I>&gt;<i> &gt;&gt; Hi,
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; on the RabbitMQ FAQ page I see the response to
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; &quot;Can you explain the cases where a message might be delivered to a
</I>&gt;<i> &gt;&gt; consumer more than once?&quot;
</I>&gt;<i> &gt;&gt; the following:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; &quot;If a message is delivered to a consumer, and that consumer then dies
</I>&gt;<i> &gt;&gt; (or closes the channel which has the subscription to the queue, or
</I>&gt;<i> &gt;&gt; closes the connection itself) without acking the message, then
</I>&gt;<i> &gt;&gt; RabbitMQ will reinject the message into the queue. If that same
</I>&gt;<i> &gt;&gt; consumer then reconnects and creates a new subscription to the same
</I>&gt;<i> &gt;&gt; queue, it's possible it'll receive the same message again. This is 'at
</I>&gt;<i> &gt;&gt; least once' delivery and is very deliberate design to ensure that
</I>&gt;<i> &gt;&gt; messages are not lost in transit.&quot;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; So my doubt is:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; In a scenario with one consumer as I saw in my tests, the consumer
</I>&gt;<i> &gt;&gt; received messages with the Redelivered=true AMQP header atribute.
</I>&gt;<i> &gt;&gt; The consumer was based in the classes provided by the .NET API and as
</I>&gt;<i> &gt;&gt; I remember the consumer-tag is random generated by the server.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; When there is a only one consumer (with a random consumer-tag name)
</I>&gt;<i> &gt;&gt; and a message is not acked when the consumer is reconnected (so has
</I>&gt;<i> &gt;&gt; another random tag name) that message is redelivered?
</I>&gt;<i> &gt;&gt; Based on my experience I think this is true but don't understand that
</I>&gt;<i> &gt;&gt; &quot;If that same consumer then reconnects and creates a new subscription
</I>&gt;<i> &gt;&gt; to the same queue&quot;...
</I>&gt;<i> &gt;&gt; By the was my consumer always tries to create the queue and the
</I>&gt;<i> &gt;&gt; bindings every time it connects to RabbitMQ.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; And also I'm wondering how this behavior acts when there are more than
</I>&gt;<i> &gt;&gt; one consumer (same queue and same bindings)...
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Under what circumstances an unack message wouldn't be redelivered again?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Thank you in advance.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Regards,
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Alfonso
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; The consumer can also call basic.recover which tells rabbit to resend
</I>&gt;<i> &gt;&gt; all the messages sent to the consumer for which rabbit has not
</I>&gt;<i> &gt;&gt; received an ack for. This basically amounts to the consumer saying &quot;I
</I>&gt;<i> &gt;&gt; know you sent me some messages, but I've forgotten what they are.
</I>&gt;<i> &gt;&gt; Could you resend them all again?&quot;.
</I>&gt;<i> &gt;&gt; _______________________________________________
</I>&gt;<i> &gt;&gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt;&gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> &gt;&gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i> &gt;
</I></PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011250.html">[rabbitmq-discuss] Message redelivering doubt with one and with more than one consumers.
</A></li>
	<LI>Next message: <A HREF="011283.html">[rabbitmq-discuss] Message redelivering doubt with one and with more than one consumers.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11253">[ date ]</a>
              <a href="thread.html#11253">[ thread ]</a>
              <a href="subject.html#11253">[ subject ]</a>
              <a href="author.html#11253">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
