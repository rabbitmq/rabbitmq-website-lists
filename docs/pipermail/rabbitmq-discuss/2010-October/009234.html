<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] hanging on message sending with py-amqplib
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20hanging%20on%20message%20sending%20with%20py-amqplib&In-Reply-To=%3C20101001171936.GP20604%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009235.html">
   <LINK REL="Next"  HREF="009238.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] hanging on message sending with py-amqplib</H1>
    <B>Matthew Sackman</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20hanging%20on%20message%20sending%20with%20py-amqplib&In-Reply-To=%3C20101001171936.GP20604%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] hanging on message sending with py-amqplib">matthew at rabbitmq.com
       </A><BR>
    <I>Fri Oct  1 18:19:36 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="009235.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
        <LI>Next message: <A HREF="009238.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9234">[ date ]</a>
              <a href="thread.html#9234">[ thread ]</a>
              <a href="subject.html#9234">[ subject ]</a>
              <a href="author.html#9234">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

On Thu, Sep 30, 2010 at 04:52:46PM -0500, tsuraan wrote:
&gt;<i> The way I'm repopulating the queues is by binding each queue to the
</I>&gt;<i> amq.direct exchange with the queue name as the routing key, and then
</I>&gt;<i> sending messages to that exchange with the desired queue's name as the
</I>&gt;<i> key.  The messages are being created as persistent messages, and the
</I>&gt;<i> sends are done in a transactional channel with a commit every hundred
</I>&gt;<i> messages.
</I>
Ok, so you should be seeing a fair amount of disk activity.

&gt;<i>  While this is happening, the consumers are consuming from
</I>&gt;<i> the queues.  If I stop the consumers, then the hangs also stop.
</I>
Are the consumers part of the same clients that are doing the sending or
are they different clients?

&gt;<i>  I
</I>&gt;<i> also don't ever seem to get hangs when doing normal message sending
</I>&gt;<i> through the exchanges that I normally use; at least I haven't seen any
</I>&gt;<i> evidence or heard any bug reports that would indicate that's
</I>&gt;<i> happening.  There is nothing in my sasl log, and the only unusual
</I>&gt;<i> thing in my other log is that I'm sometimes hitting the high water
</I>&gt;<i> mark, but I haven't seen that happen while I've been attempting to
</I>&gt;<i> send messages.
</I>
At what rate are the consumers consuming messages? Rabbit is optimised
to get rid of messages quickly, thus if a queue is quite long, it can
drive consumers as fast as possible, but will ignore publishes until the
queue has become empty... however, that should really only express
itself internally within Rabbit - the client shouldn't actually see any
impact on publishing, unless it was also doing something synchronous
from time to time like tx.commit. Are you finding it blocks when it hits
tx.commit?

I don't think there's anything wrong with what you're doing. But this
might be a client library issue.

Seeing as you're using a client to shovel messages from one broker to
another, I would suggest experimenting with using the shovel - I'd
configure it in the new broker (where it's easiest to install) and just
have it drag all messages over from the old broker. If that works, then
it does point to something going wrong in the python client library.

Socket flushing will block if the broker has hit its high memory
watermarks. This is because we now use TCP backpressure to block any
clients which are sending us messages. If you have the sender and the
consumer on the same connection, this will certainly affect you, and it
is possible that memory use will be worse (more fragmented) if you have
a consumer and publisher at the same time rather than just a publisher,
so you might just be hitting the limits more often. It could be that the
socket flush doesn't correctly return even when the socket becomes
unblocked.

Best wishes,

Matthew
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009235.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
	<LI>Next message: <A HREF="009238.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9234">[ date ]</a>
              <a href="thread.html#9234">[ thread ]</a>
              <a href="subject.html#9234">[ subject ]</a>
              <a href="author.html#9234">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
