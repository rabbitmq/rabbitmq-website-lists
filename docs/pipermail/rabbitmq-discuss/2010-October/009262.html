<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] hanging on message sending with py-amqplib
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20hanging%20on%20message%20sending%20with%20py-amqplib&In-Reply-To=%3CAANLkTi%3DKeryhDT-fv00YNG90ZU_KKUA8DvpRSmxbcNeD%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009261.html">
   <LINK REL="Next"  HREF="009263.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] hanging on message sending with py-amqplib</H1>
    <B>tsuraan</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20hanging%20on%20message%20sending%20with%20py-amqplib&In-Reply-To=%3CAANLkTi%3DKeryhDT-fv00YNG90ZU_KKUA8DvpRSmxbcNeD%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] hanging on message sending with py-amqplib">tsuraan at gmail.com
       </A><BR>
    <I>Sat Oct  2 18:53:09 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="009261.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
        <LI>Next message: <A HREF="009263.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9262">[ date ]</a>
              <a href="thread.html#9262">[ thread ]</a>
              <a href="subject.html#9262">[ subject ]</a>
              <a href="author.html#9262">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> Why is your water mark set so low? I thought you said you had 2GB of memory
</I>&gt;<i> in the machine, which with the default setting of the mark at 0.4 would be
</I>&gt;<i> about 819Mb.
</I>
The machine runs quite a few processes.  My understanding of the high
water mark is that the erlang process running rabbit will use at most
2*(watermark * total_ram), so a watermark of 0.1 will result in rabbit
consuming at most 20% of the machine's RAM, correct?  The default
value of 0.4 would let rabbit consume 80% of RAM, which isn't so good
for the other stuff running on the machine.  I know the ideal is that
rabbit gets its own machine, but that isn't an option for us; we sell
individual computers.

&gt;<i> Toke would probably help since you have one queue with nearly 600k messages.
</I>&gt;<i> But 200Mb is really very little to give to a rabbit that is supposed to
</I>&gt;<i> handle the message volume you have. So I'd start be increasing that.
</I>
We're not too worried about having really high rabbit performance;
rabbit's ability to handle hundreds of thousands of messages per
second is awesome, but the rest of our system can't handle more than a
few thousand messages per minute, so rabbit isn't a bottleneck.  I had
hoped that setting a low watermark would just make rabbit keep more
messages on disk and less in RAM, and it would just have to feed from
its disk queues more often than it would with a higher watermark.

&gt;<i> A prefetch of 1000 is quite high. I'd suggest lowering that.
</I>
That process gets messages from rabbit, does indexing on the
associated data (not stored in rabbit) and does a checkpoint per
minute on a postgres database, a transactional search index, and on
rabbit.  If it acknowledges messages from rabbit before they are
committed, then they can be lost, which is bad.  Checkpoints on the
search index are somewhat expensive; doing them once a minute isn't
bad, but more frequent checkpoints mean busier disks, which means an
uphappy machine.  The number of messages we can process per checkpoint
interval is effectively limited by the prefetch limit, and going under
a thousand means our indexer is idle until the next checkpoint.

&gt;<i> Blocking happens at the *connection* level. A client connection that hasn't
</I>&gt;<i> done any publishing will not be blocked.
</I>
Ok, so if I have a few channels on a connection, and one of the
channels is only getting messages, acking message, and committing
while another channel is publishing, then the connection will be
blocked on a low memory alert.  If I move the publishing channel and
the consuming channel to different connections, then the consuming
channel will never be blocked?  I can do that easily enough, and it
might just fix things.
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009261.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
	<LI>Next message: <A HREF="009263.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9262">[ date ]</a>
              <a href="thread.html#9262">[ thread ]</a>
              <a href="subject.html#9262">[ subject ]</a>
              <a href="author.html#9262">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
