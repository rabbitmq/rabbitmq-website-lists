<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] last sticky wicket on map/reduce
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20last%20sticky%20wicket%20on%20map/reduce&In-Reply-To=%3C5E91BB01-C950-46EC-B7AA-F086F6354603%40npcinternational.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009213.html">
   <LINK REL="Next"  HREF="009218.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] last sticky wicket on map/reduce</H1>
    <B>Jon Brisbin</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20last%20sticky%20wicket%20on%20map/reduce&In-Reply-To=%3C5E91BB01-C950-46EC-B7AA-F086F6354603%40npcinternational.com%3E"
       TITLE="[rabbitmq-discuss] last sticky wicket on map/reduce">jon.brisbin at npcinternational.com
       </A><BR>
    <I>Fri Oct  1 14:34:41 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="009213.html">[rabbitmq-discuss] last sticky wicket on map/reduce
</A></li>
        <LI>Next message: <A HREF="009218.html">[rabbitmq-discuss] last sticky wicket on map/reduce
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9214">[ date ]</a>
              <a href="thread.html#9214">[ thread ]</a>
              <a href="subject.html#9214">[ subject ]</a>
              <a href="author.html#9214">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'm also wondering if anyone uses counts to determine when a job is finished or not. By that I mean, increment a counter for every outgoing message and decrement the counter when a response is received. In the case of a map/reduce job, I'd need to do something like:

SQL -&gt; Map phase = +1 (per row)
Map phase -&gt; Reduce phase = -1 (that we got the original msg) +1 * (num of emit's)
Reduce phase -&gt; Response|ReReduce = -1 (for emit's) +1 (for response/rereduce)
[ReReduce -&gt; Response] = -1 +1 (for sending response)
Response = -1

Essentially, each step would decrement a counter for the incoming message and increment the counter for the outgoing message. A reduce phase might decrement the counter 1000 times and increment it once. But since the map phase incremented it 1000 times prior, the count after map/reduce would be &quot;1&quot;. The response listener would then decrement the counter when it processed the response, see that it's now zero, and know to continue.

If my goal is to beat processing times on the AS/400 when doing large financial calculations (daily acct'g reports take several hours to generate), I can't really depend on timeouts to make sure I've gathered all my results. I want the job to return as soon as results are ready. I'd like to go to management and show them a 2 hr -&gt; 15 min improvement by using parallel processing.

I'm just wondering if using ZooKeeper or similar to do distributed, synchronized counters will have enough atomicity to not miss a count incr/decr. If I miss even one, I'm screwed because it'll never get back to zero (or get there prematurely).

I need a sentence with a question mark or this will definitely go unanswered: are message counters like this a good way to monitor asynchronous, distributed processing state?

Thanks! :)

Jon Brisbin
Portal Webmaster
NPC International, Inc.



On Oct 1, 2010, at 8:11 AM, Jon Brisbin wrote:

&gt;<i> I had not really looked at the spring integration stuff for a solution. It looks interesting, though.
</I>&gt;<i> 
</I>&gt;<i> Thanks for the link...
</I>&gt;<i> 
</I>&gt;<i> Jon Brisbin
</I>&gt;<i> Portal Webmaster
</I>&gt;<i> NPC International, Inc.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On Sep 30, 2010, at 4:19 PM, Shane Witbeck wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> Have you thought about using an Aggregator? Spring Integration offers this: 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> <A HREF="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggregator">http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggregator</A>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I think Apache Camel offers this too. Both might be overkill in your case but maybe a look at how they're doing it will help.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> HTH,
</I>&gt;&gt;<i> Shane
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> On Thu, Sep 30, 2010 at 4:41 PM, Jon Brisbin &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">jon.brisbin at npcinternational.com</A>&gt; wrote:
</I>&gt;&gt;<i> I've got a pest of a sticky wicket in my map/reduce implementation that's using Groovy for the logic and RabbitMQ for the plumbing. It's frustrating because I'm so close.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> The problem I'm having is knowing when I'm finished. Using data like this:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 1
</I>&gt;&gt;<i> 2
</I>&gt;&gt;<i> 3
</I>&gt;&gt;<i> 4
</I>&gt;&gt;<i> 5
</I>&gt;&gt;<i> 6
</I>&gt;&gt;<i> 7
</I>&gt;&gt;<i> 8
</I>&gt;&gt;<i> 9
</I>&gt;&gt;<i> 10
</I>&gt;&gt;<i> END
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> The &quot;END&quot; goes through a separate consumer thread because it goes out on a fanout exchange (it has to go to all workers), so it comes in out-of-order from the other data:
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 1    2    3
</I>&gt;&gt;<i>           END
</I>&gt;&gt;<i> 4    5    6
</I>&gt;&gt;<i> END  END  
</I>&gt;&gt;<i> 7    8    9
</I>&gt;&gt;<i> ...etc...
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I can sort of work around this by keeping track of id changes in my consumers using the classic &quot;if this.id != last.id&quot; approach. But the last record is a tricky one because there's no key change event to trigger sending the response back. Unless I simply wait until a timeout has occurred, I'm not sure how I can tell when I've collected all the responses I'm going to get.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> The problem is that I only know how many message I've sent and not how many to expect in return. emit() can be called multiple times from a map phase and the reduce phase can take (records per key) * (emitted) and either rereduce the result or reply back to the requestor. The requestor shouldn't know whether the result has been rereduced or not. It should simply process the return values.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> What am I missing to handle situations like this? Should I introduce another component to this that keeps track of how many messages are sent and received? Maybe put a ZooKeeper install in somewhere and coordinate all this? I've already got Riak integrated, though I'd think ZooKeeper would be better at managing concurrent updates.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Any help or suggestions here would be greatly appreciated! :)
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Jon Brisbin
</I>&gt;&gt;<i> Portal Webmaster
</I>&gt;&gt;<i> NPC International, Inc.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> rabbitmq-discuss mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> -- 
</I>&gt;&gt;<i> -Shane
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20101001/831a0347/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20101001/831a0347/attachment.htm</A>&gt;
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009213.html">[rabbitmq-discuss] last sticky wicket on map/reduce
</A></li>
	<LI>Next message: <A HREF="009218.html">[rabbitmq-discuss] last sticky wicket on map/reduce
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9214">[ date ]</a>
              <a href="thread.html#9214">[ thread ]</a>
              <a href="subject.html#9214">[ subject ]</a>
              <a href="author.html#9214">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
