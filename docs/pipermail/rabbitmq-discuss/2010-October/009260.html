<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] hanging on message sending with py-amqplib
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20hanging%20on%20message%20sending%20with%20py-amqplib&In-Reply-To=%3CAANLkTimTh1x2em7Zep7%3DC4nNA9BXP56UrV_nxFdyzEEw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009258.html">
   <LINK REL="Next"  HREF="009261.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] hanging on message sending with py-amqplib</H1>
    <B>tsuraan</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20hanging%20on%20message%20sending%20with%20py-amqplib&In-Reply-To=%3CAANLkTimTh1x2em7Zep7%3DC4nNA9BXP56UrV_nxFdyzEEw%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] hanging on message sending with py-amqplib">tsuraan at gmail.com
       </A><BR>
    <I>Sat Oct  2 17:15:35 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="009258.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
        <LI>Next message: <A HREF="009261.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9260">[ date ]</a>
              <a href="thread.html#9260">[ thread ]</a>
              <a href="subject.html#9260">[ subject ]</a>
              <a href="author.html#9260">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> The output of list_connections show many connections in the 'blocked' state,
</I>&gt;<i> which means the broker is refusing to accept any more data.
</I>&gt;<i>
</I>&gt;<i> That should only happen if the memory alarm is currently active. What does
</I>&gt;<i> the log file say about that? Perhaps you could post it.
</I>
Yeah, it is in an alarm state.  The thing goes up and down like mad
for a minute or so, and then settles down with everything hung.  The
logfile is attached.

&gt;<i> The output of list_queues shows a number of queues with messages waiting for
</I>&gt;<i> acknowledgement. One queue in particular has a high count. What's the
</I>&gt;<i> average message size of messages in that queue?
</I>
it's around a hundred bytes to a few hundred bytes.  Is it strange
that the largest of the queues is using ~12MB, and the second largest
is using ~3MB, and we're hitting our 200MB high water mark?  Am I
reading that wrong, or does there seem to be a lot of memory being
used that's not in the queued messages?  Could it be one of the
tracking things, and solvable with the toke plugin?  The highest
unack'd count is 54,468, which seems high, but not insanely so.  The
other strange thing is that the process slurping from that queue
should have a prefetch of 1,000 messages.  I'll have to see what went
wrong there, but I'm guessing it's running the wrong code.

&gt;<i> The messages waiting for acks also show up in list_channels.
</I>&gt;<i>
</I>&gt;<i> Tracing the from the queue through the consumers, channels and connections
</I>&gt;<i> to find the connection which is consuming from the high-ack queue, we
</I>&gt;<i> discover that connection to be blocked.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> So I think what is happening here is that you have a client that is both a
</I>&gt;<i> consumer and producer. At some point the memory alarm is raised. Because the
</I>&gt;<i> client has been identified as a producer the server blocks the inbound
</I>&gt;<i> socket data stream, thus pausing the client in its tracks. But messages
</I>&gt;<i> still get delivered to the client. And they all pile up in memory, in the
</I>&gt;<i> server's channel process. That is preventing the server from ever
</I>&gt;<i> recovering, clearing the memory alarm and unblocking the connections.
</I>
If the client isn't also a producer (at least on that channel), but is
in transactional mode, will the high water mark prevent tx.commit
messages from being handled?

&gt;<i> I reckon one way to prevent this situation is to set a qos.prefetch_count,
</I>&gt;<i> thus bounding the number of messages which are waiting for acknowledgement.
</I>&gt;<i> Or, if you can consume in no-ack mode that would be even better.
</I>
the prefetch_count should be getting set, but doesn't appear to be.
I'll look into that.  The original machine that was having this
problem was doing it after ~300 messages were inserted into the
queues, and it had a high water mark of 800MB.  I really wish I still
had access to that machine for testing, but unfortunately that exact
situation doesn't seem to be repeatable.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">mqueue at master.0.log.gz</A>
Type: application/x-gzip
Size: 4497 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20101002/7efe6d33/attachment.bin">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20101002/7efe6d33/attachment.bin</A>&gt;
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009258.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
	<LI>Next message: <A HREF="009261.html">[rabbitmq-discuss] hanging on message sending with py-amqplib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9260">[ date ]</a>
              <a href="thread.html#9260">[ thread ]</a>
              <a href="subject.html#9260">[ subject ]</a>
              <a href="author.html#9260">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
