<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Is the &quot;master&quot; node mandatory ?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Is%20the%20%22master%22%20node%20mandatory%20%3F&In-Reply-To=%3C20101101131045.GA2628%40dakota.eng.vmware.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009760.html">
   <LINK REL="Next"  HREF="009714.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Is the &quot;master&quot; node mandatory ?</H1>
    <B>Alexandru Scvor&#355;ov</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Is%20the%20%22master%22%20node%20mandatory%20%3F&In-Reply-To=%3C20101101131045.GA2628%40dakota.eng.vmware.com%3E"
       TITLE="[rabbitmq-discuss] Is the &quot;master&quot; node mandatory ?">alexandru at rabbitmq.com
       </A><BR>
    <I>Mon Nov  1 13:10:45 GMT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="009760.html">[rabbitmq-discuss] The Assumption Of Cooperative Peers (was Re: Protection against slow consumers)
</A></li>
        <LI>Next message: <A HREF="009714.html">[rabbitmq-discuss] Understanding RabbitMQ clustering
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9713">[ date ]</a>
              <a href="thread.html#9713">[ thread ]</a>
              <a href="subject.html#9713">[ subject ]</a>
              <a href="author.html#9713">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> To summarize, the list of exchanges and queues are recreated at 
</I>&gt;<i> reconnection time by producers and consumers, thus, the &quot;state&quot; of 
</I>&gt;<i> the cluster can be lost. That's why I think we can use RAM node 
</I>&gt;<i> only. But maybe the &quot;state&quot; of the cluster is not limited to the 
</I>&gt;<i> list of exchanges and queues ?
</I>
The &quot;state&quot; of the cluster is just the names of the nodes currently in
the cluster and the queues/exchanges declared on said nodes.

All nodes, whether ram or disc record the names of the other nodes in
the cluster, so even ram nodes will rejoin the cluster when restarted.

Ram nodes don't store most of their mnesia tables on disk, so they won't
remember queues/exchanges/messages on restart.

Your scenario seems fine: if you don't mind having to redeclare
queues/exchanges on every use and losing messages on node failure, using
a cluster of all ram nodes is ok.


Also, sorry for the late reply.


Cheers,
Alex

On Wed, Oct 20, 2010 at 09:19:30AM +0200, Vincent Barat wrote:
&gt;<i>   Thank you for this long reply, I was not aware about that.
</I>&gt;<i> 
</I>&gt;<i> In our use case, all queues are not persistent. Thus, when a node 
</I>&gt;<i> fails, all messages of all queues it handles are lost (since 
</I>&gt;<i> messages are not replicated between nodes).
</I>&gt;<i> This situation is ok for us (anyway there is nothing we can do to 
</I>&gt;<i> prevent this, except to upgrade to RabbitMQ 2.0 with persistent 
</I>&gt;<i> queues, something we plan to do, but throughput being our main 
</I>&gt;<i> concern, we need to benchmark it first).
</I>&gt;<i> 
</I>&gt;<i> For the moment, what we must ensure is not to lose the global list 
</I>&gt;<i> of exchanges declared by producers on node failure.
</I>&gt;<i> AFAIK, this list is maintained in mnesia. If all nodes fails, 
</I>&gt;<i> because they are all RAM nodes, we lose this exchange list. But in 
</I>&gt;<i> that case, producers would recreate all exchange at reconnection 
</I>&gt;<i> time, whatever the node that is restarted first.
</I>&gt;<i> 
</I>&gt;<i> To summarize, the list of exchanges and queues are recreated at 
</I>&gt;<i> reconnection time by producers and consumers, thus, the &quot;state&quot; of 
</I>&gt;<i> the cluster can be lost. That's why I think we can use RAM node 
</I>&gt;<i> only. But maybe the &quot;state&quot; of the cluster is not limited to the 
</I>&gt;<i> list of exchanges and queues ?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Le 19/10/10 18:35, Matthew Sackman a &#233;crit :
</I>&gt;<i> &gt; On Tue, Oct 19, 2010 at 06:28:47PM +0200, Vincent Barat wrote:
</I>&gt;<i> &gt;&gt; My two nodes are RAM nodes actually.
</I>&gt;<i> &gt; Ahh. From <A HREF="http://rabbitmq.com/clustering.html:">http://rabbitmq.com/clustering.html:</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &quot;Because state is replicated across all nodes in the cluster, it is
</I>&gt;<i> &gt; sufficient to have just one disk node within a cluster, to store the
</I>&gt;<i> &gt; state of the cluster safely. Beware, however, that RabbitMQ will not
</I>&gt;<i> &gt; stop you from creating a cluster with only RAM nodes. Should you do
</I>&gt;<i> &gt; this, and suffer a power failure to the entire cluster, the entire state
</I>&gt;<i> &gt; of the cluster, including all messages, will be lost.&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I think we used to prevent you from building RAM-node-only clusters. We
</I>&gt;<i> &gt; must have changed behaviour there a while ago. It makes sense that the
</I>&gt;<i> &gt; last node to die needs to be brought up first: if a node goes down and
</I>&gt;<i> &gt; it knew that it was part of a cluster, then when coming back up, it'll
</I>&gt;<i> &gt; remember it was part of a cluster and try to reconnect to it - it will
</I>&gt;<i> &gt; be very aware that any data it holds (in this case, none!) will likely
</I>&gt;<i> &gt; be out of date and it needs to resync from the other nodes in the
</I>&gt;<i> &gt; cluster - it'll have no knowledge that the other nodes also went down.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; That said, it's been a while since I played around with clusters so my
</I>&gt;<i> &gt; information might be out of date.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Matthew
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; rabbitmq-discuss mailing list
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> &gt; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i> &gt;
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I></PRE>
































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009760.html">[rabbitmq-discuss] The Assumption Of Cooperative Peers (was Re: Protection against slow consumers)
</A></li>
	<LI>Next message: <A HREF="009714.html">[rabbitmq-discuss] Understanding RabbitMQ clustering
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9713">[ date ]</a>
              <a href="thread.html#9713">[ thread ]</a>
              <a href="subject.html#9713">[ subject ]</a>
              <a href="author.html#9713">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
