<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] fastest way to process messages?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20fastest%20way%20to%20process%20messages%3F&In-Reply-To=%3C4C3AF500.1080903%40rabbitmq.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007924.html">
   <LINK REL="Next"  HREF="007925.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] fastest way to process messages?</H1>
    <B>Simon MacMullen</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20fastest%20way%20to%20process%20messages%3F&In-Reply-To=%3C4C3AF500.1080903%40rabbitmq.com%3E"
       TITLE="[rabbitmq-discuss] fastest way to process messages?">simon at rabbitmq.com
       </A><BR>
    <I>Mon Jul 12 11:57:04 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="007924.html">[rabbitmq-discuss] fastest way to process messages?
</A></li>
        <LI>Next message: <A HREF="007925.html">[rabbitmq-discuss] timed / delayed messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7929">[ date ]</a>
              <a href="thread.html#7929">[ thread ]</a>
              <a href="subject.html#7929">[ subject ]</a>
              <a href="author.html#7929">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 09/07/10 21:43, Jon Brisbin wrote:
&gt;<i> I pushed a rough draft/alpha version of the asynchronous distributed
</I>&gt;<i> cache I blogged about last week to GitHub. It works pretty well for a
</I>&gt;<i> rough draft. I am noticing some pretty large variances in my metrics
</I>&gt;<i> from one run to another, though. I'm throwing 25 messages at a time at
</I>&gt;<i> an object with 25 workers waiting for those objects (so there's no
</I>&gt;<i> waiting for objects to be processed). I'm seeing run times as fast as
</I>&gt;<i> 10ms and as slow as 150-200ms. It really varies from one run to the next.
</I>
Hi Jon. I would first of all suggest you use a profiler to check whether 
the bottlenecks are in the server or your client, and if so where. But I 
guess you already knew that :)

&gt;<i> I'm sure there are bottlenecks in my code. I'm starting to investigate
</I>&gt;<i> that right now. But I was wondering if there was some consensus on
</I>&gt;<i> maximizing throughput (using the Java client). Since this is a cache,
</I>&gt;<i> I'm wanting to keep load times to an absolute minimum (duh). In several
</I>&gt;<i> runs, I've gotten down to 10-15 ms but I can't get it to do that
</I>&gt;<i> consistently.
</I>&gt;<i>
</I>&gt;<i> Will I be able to process more messages if each of my workers has its
</I>&gt;<i> own queue, but binds to the exchange using a common key--or should I do
</I>&gt;<i> what I'm currently doing, which is to use the QueueingConsumer and
</I>&gt;<i> simply use multiple workers to pull messages off the single
</I>&gt;<i> BlockingQueue? Which has the potential for higher throughput while not
</I>&gt;<i> increasing the likelihood I'll end up with duplicate messages?
</I>
If each worker has its own queue, each worker will get a copy of all 
messages (or a subset depending on how you do routing). It sounds like 
this is not what you want.

&gt;<i> Is there a better way to process messages if performance is the primary
</I>&gt;<i> consideration than using the QueueingConsumer? I've haven't looked at
</I>&gt;<i> the code to see what it's doing, but I would think fewer method calls
</I>&gt;<i> between delivery of the message and calling the callback provided by the
</I>&gt;<i> application code would give me greater throughput and shorter run times.
</I>
QueueingConsumer implements the Consumer interface and stores messages 
inside a LinkedBlockingQueue. I'm not sure of how performant that is, 
but it shouldn't be too bad.

If you determine that's where the problems lie, you can implement 
Consumer yourself. You should make sure that you implement 
handleDelivery() in such a way as to be very fast - that method is 
invoked by the Connection main loop so the Connection will block while 
it runs (this is the motivation for the existence of QueueingConsumer).

&gt;<i> I should probably also investigate alternative languages. I started this
</I>&gt;<i> as a Java object cache, so naturally I used Java. But I'm wondering if I
</I>&gt;<i> could get better performance by skipping the serialize/deserialize step
</I>&gt;<i> in the cache provider (I'm storing actual objects in memory rather than
</I>&gt;<i> the byte array, which I considered doing at first).
</I>
I don't see why Java shouldn't be fast enough, but I don't know how 
optimised serialisation is.

Cheers, Simon

-- 
Simon MacMullen
Staff Engineer, RabbitMQ
SpringSource, a division of VMware

</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007924.html">[rabbitmq-discuss] fastest way to process messages?
</A></li>
	<LI>Next message: <A HREF="007925.html">[rabbitmq-discuss] timed / delayed messages
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7929">[ date ]</a>
              <a href="thread.html#7929">[ thread ]</a>
              <a href="subject.html#7929">[ subject ]</a>
              <a href="author.html#7929">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
