<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] difficulties with prefetch count
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20difficulties%20with%20prefetch%20count&In-Reply-To=%3CA40D2567-1868-4A7E-9D7D-8451344A8DFA%40setf.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012636.html">
   <LINK REL="Next"  HREF="012700.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] difficulties with prefetch count</H1>
    <B>james anderson</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20difficulties%20with%20prefetch%20count&In-Reply-To=%3CA40D2567-1868-4A7E-9D7D-8451344A8DFA%40setf.de%3E"
       TITLE="[rabbitmq-discuss] difficulties with prefetch count">james.anderson at setf.de
       </A><BR>
    <I>Fri May  6 06:22:43 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="012636.html">[rabbitmq-discuss] difficulties with prefetch count
</A></li>
        <LI>Next message: <A HREF="012700.html">[rabbitmq-discuss] difficulties with prefetch count [ps]
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12699">[ date ]</a>
              <a href="thread.html#12699">[ thread ]</a>
              <a href="subject.html#12699">[ subject ]</a>
              <a href="author.html#12699">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>good morning,

as the sole response to date, below, contradicts the discussion on  
fair dispatch in [3], i rephrase the question.
with this message, i enclose simple client and server implementations  
which can be used to demonstrate the problem.
it is intended to be run with de.setf.amqp[4], but the amqp operation  
sequence is language-independent.

when run with a rmq broker @2.1.1 (that is, the version which we have  
in production), one observes that each time a subscriber delays  
acknowledgment of one message, one additional message is delayed by  
being queued for delivery to that subscriber despite a pending  
unacknowledged message. this although the subscriber has a prefetch  
limit of 1 and the held message appears nowhere in queue lists  
produced by rabbitmqctl.

this can be observed in two combinations.

1. with two clients and two servers.
   a. start a server which runs without delay.
   b. start two clients

one observes, that the server receives and replies to alternating  
messages from each client

   c. start a second server, with a delay

one observes, that first one client and then the second hangs until  
the message to the first client has been acknowledged.


2. with three clients and two servers
   a. start a server which runs without delay.
   b. start three clients.

one observes, that the server receives and replies to alternating  
messages from each client in turn.

   c. start a second server, with delay

one observes,  that first one client and then a second hangs until  
the message to the first client has been acknowledged, but the third  
client's messages are delivered to the non-waiting server without delay.


that is, one gets the distinct impression that rmq does not  
consistently honor the prefetch count constraint.


-------------- next part --------------
A non-text attachment was scrubbed...
Name: fair-allocation-1-1.lisp
Type: application/applefile
Size: 584 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20110506/31fdb650/attachment.bin">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20110506/31fdb650/attachment.bin</A>&gt;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: fair-allocation-1-1.lisp
Type: application/octet-stream
Size: 6981 bytes
Desc: not available
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20110506/31fdb650/attachment.obj">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20110506/31fdb650/attachment.obj</A>&gt;
-------------- next part --------------

-------
[4] <A HREF="https://github.com/lisp/de.setf.amqp">https://github.com/lisp/de.setf.amqp</A>






On 2011-05-02, at 14:28 , Allan Kamau wrote:

&gt;<i> On Mon, May 2, 2011 at 3:01 PM, james anderson  
</I>&gt;<i> &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">james.anderson at setf.de</A>&gt; wrote:
</I>&gt;&gt;<i> good afternoon, gentlemen;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> we find that a qos request with prefetch count of 1 does not reliably
</I>&gt;&gt;<i> achieve &quot;fair dispatch&quot; and seek advice, what we should  
</I>&gt;&gt;<i> reconfigure in order
</I>&gt;&gt;<i> to achieve it.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> the specification page[1] indicates that rmq supports local  
</I>&gt;&gt;<i> prefetch limits,
</I>&gt;&gt;<i> but not global ones. the BasicQosDesign[2] wiki entry describes some
</I>&gt;&gt;<i> restrictions, in particular qos/consume ordering. the work queue  
</I>&gt;&gt;<i> tutorial
</I>&gt;&gt;<i> describes how to use prefetch constraints to achieve &quot;fair dispatch&quot;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> despite adhering to these understandings, we observe the following  
</I>&gt;&gt;<i> with rmq
</I>&gt;&gt;<i> 2.1.1:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> a server process establishes four worker threads, each of which
</I>&gt;&gt;<i>  - creates a connection to the rmq broker
</I>&gt;&gt;<i>  - creates a shared work queue (most likely redundantly)
</I>&gt;&gt;<i>  - a private sub-task queue for responses to delegated tasks
</I>&gt;&gt;<i>  - creates two channels on its connection;
</I>&gt;&gt;<i>   - one channel is for task messages; there it requests qos 
</I>&gt;&gt;<i> (prefetch=1),
</I>&gt;&gt;<i> consume(work queue).
</I>&gt;&gt;<i>   - one channel is used to delegate tasks; on this one just
</I>&gt;&gt;<i> consume(delegated response queue).
</I>&gt;&gt;<i>  - accepts delivery of task messages, processes them, publishes  
</I>&gt;&gt;<i> results to a
</I>&gt;&gt;<i> task-identified response queue.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> a front-end process establishes equivalent threads, each of which  
</I>&gt;&gt;<i> supports
</I>&gt;&gt;<i> http requests and mediates them to the server.
</I>&gt;&gt;<i> for each front-end request, a thread
</I>&gt;&gt;<i>  - creates a connection to the rmq server
</I>&gt;&gt;<i>  - creates a task-specific queue (as per routing) for an eventual  
</I>&gt;&gt;<i> response
</I>&gt;&gt;<i>  - subscribes to the response queue
</I>&gt;&gt;<i>  - publishes a task message with routing to the work queue
</I>&gt;&gt;<i>  - accepts delivery of task responses
</I>&gt;&gt;<i>  - tears down the task response subscription and queue.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> in this particular situation, no delegation occurs. that is, no  
</I>&gt;&gt;<i> messages
</I>&gt;&gt;<i> pass through the delegated work queue.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> we observe that, if a posted task takes an &quot;long&quot; time, not only its
</I>&gt;&gt;<i> front-end thread will wait until that processing completes, but one
</I>&gt;&gt;<i> additional front-end task hangs was well.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> while the long task transpires, other http requests are processed  
</I>&gt;&gt;<i> without
</I>&gt;&gt;<i> delay. that is, their setup, request, subscription, delivery, and  
</I>&gt;&gt;<i> tear-down,
</I>&gt;&gt;<i> all complete as normal. their task messages are delivered to one  
</I>&gt;&gt;<i> of the
</I>&gt;&gt;<i> three unoccupied server threads which does the work and produces the
</I>&gt;&gt;<i> response.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> independent of whether the front-end leaves the hung task to wait  
</I>&gt;&gt;<i> for a
</I>&gt;&gt;<i> response or aborts it, by canceling the subscription, deleting the  
</I>&gt;&gt;<i> queue,
</I>&gt;&gt;<i> and closing the connection, once the long-running server thread  
</I>&gt;&gt;<i> completes
</I>&gt;&gt;<i> its task, the next message delivered to it is that message from the
</I>&gt;&gt;<i> waiting-or-aborted front-end thread.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> if we use rabbitmqctl to display the connection/subscription/queue  
</I>&gt;&gt;<i> state
</I>&gt;&gt;<i> during the long task processing, we observe that
</I>&gt;&gt;<i> - the work queue has one unacknowledged message, but zero ready  
</I>&gt;&gt;<i> messages
</I>&gt;&gt;<i> - the server task channels have a prefetch window of 1
</I>&gt;&gt;<i> - no connection has a send pending
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> that is, it appears as if one single message is held up until the  
</I>&gt;&gt;<i> long task
</I>&gt;&gt;<i> complete, but is no where to be seen.
</I>&gt;&gt;<i> what do we not understand about prefetch windows?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ---------------
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> [1] <A HREF="http://www.rabbitmq.com/specification.html">http://www.rabbitmq.com/specification.html</A>
</I>&gt;&gt;<i> [2] <A HREF="https://dev.rabbitmq.com/wiki/BasicQosDesign">https://dev.rabbitmq.com/wiki/BasicQosDesign</A>
</I>&gt;&gt;<i> [3] <A HREF="http://www.rabbitmq.com/tutorials/tutorial-two-python.html">http://www.rabbitmq.com/tutorials/tutorial-two-python.html</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> rabbitmq-discuss mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I am quite new to RabbitMQ, reading your first line it seem you would
</I>&gt;<i> like the &quot;fair dispatch&quot; or round robin message fetching. This is the
</I>&gt;<i> default behaviour. The prefetch count of 1 does disable this &quot;fair
</I>&gt;<i> dispatch&quot; and lets the jobs be fetched by clients at quickly as they
</I>&gt;<i> can manage to consume them.
</I>&gt;<i>
</I>&gt;<i> Allan.
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012636.html">[rabbitmq-discuss] difficulties with prefetch count
</A></li>
	<LI>Next message: <A HREF="012700.html">[rabbitmq-discuss] difficulties with prefetch count [ps]
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12699">[ date ]</a>
              <a href="thread.html#12699">[ thread ]</a>
              <a href="subject.html#12699">[ subject ]</a>
              <a href="author.html#12699">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
