<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Stress testing RabbitMQ
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Stress%20testing%20RabbitMQ&In-Reply-To=%3C222F5BBC-5347-422E-BAC5-C9E50C5E0FD6%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012872.html">
   <LINK REL="Next"  HREF="012875.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Stress testing RabbitMQ</H1>
    <B>Alvaro Videla</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Stress%20testing%20RabbitMQ&In-Reply-To=%3C222F5BBC-5347-422E-BAC5-C9E50C5E0FD6%40gmail.com%3E"
       TITLE="[rabbitmq-discuss] Stress testing RabbitMQ">videlalvaro at gmail.com
       </A><BR>
    <I>Sun May 15 18:16:55 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="012872.html">[rabbitmq-discuss] Stress testing RabbitMQ
</A></li>
        <LI>Next message: <A HREF="012875.html">[rabbitmq-discuss] Stress testing RabbitMQ
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12873">[ date ]</a>
              <a href="thread.html#12873">[ thread ]</a>
              <a href="subject.html#12873">[ subject ]</a>
              <a href="author.html#12873">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Matthias,

I didn't suffer from the add/remove binding problem because in my tests I was just creating the bindings, &#8211;which yes, was really slow (30 secs for 5000 bindings)&#8211;, and then routing messages.

So as I said, I was just *stressing* the routing part. That is, I didn't have any new bindings once I started publishing messages.

Regarding the caching&#8230; yes I know it can be pretty hard to manage. I already had many nightmares doing caching in web apps. In RabbitMQ's case if you are routing many thousands of messages per second and then there's a bindings coming and going I think things can start to get out of sync pretty easily.

Anyway&#8230; it was a lot of fun going around the rabbit internals. I really like all the Erlang specs you have there. That makes it really easy to follow along with the code, understand which parameters to expect and so on.

Regards,

-Alvaro

On May 15, 2011, at 6:58 PM, Matthias Radestock wrote:

&gt;<i> Alvaro,
</I>&gt;<i> 
</I>&gt;<i> Alvaro Videla wrote:
</I>&gt;&gt;<i> Yes, the binding add/removal is slow. In that case I thought that is
</I>&gt;&gt;<i> more common to be routing messages than adding removing bindings.
</I>&gt;<i> 
</I>&gt;<i> Given that you were trying to optimise massive fanout, the binding count will be high, so the O(n^2) time complexity on add/remove really hurts and imposes a limit on the fanout degree which is way lower than it would be otherwise. I am surprised you haven't come up against this in your tests.
</I>&gt;<i> 
</I>&gt;&gt;<i> Also my goal was to easily get an implementation to see if the route
</I>&gt;&gt;<i> part could be improved by skipping the mnesia:dirty_select. One
</I>&gt;&gt;<i> reason I thought Mnesia could be a problem was because I started
</I>&gt;&gt;<i> getting logs like: Mnesia(<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbit at mrhyde</A>): ** WARNING ** Mnesia is
</I>&gt;&gt;<i> overloaded&#8230;
</I>&gt;<i> 
</I>&gt;<i> These warnings are issued when mnesia's write-behind logic gets too far, er, behind. They are generally harmless. More importantly though they cannot originate from dirty_select/read operations. So if you are seeing these warnings in your tests they are most likely due to binding addition/removal, not routing.
</I>&gt;<i> 
</I>&gt;&gt;<i> My reasoning was that scanning the table every time a message is
</I>&gt;&gt;<i> routed could be slower than just returning a somehow cached list of
</I>&gt;&gt;<i> bindings, which is what I tried to do.
</I>&gt;<i> 
</I>&gt;<i> Caching routing results in, say, the channel's process dictionary, can indeed yield significant performance gains for some use cases. We have experimented with that but trying to apply caching generally turns out to be hard. The problem, unsurprisingly, is keeping such caches up to date. Particularly when trying to maintain AMQP's quite strict visibility guarantees. Another problem is keeping the caches from taking up too much memory.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Regards,
</I>&gt;<i> 
</I>&gt;<i> Matthias.
</I>
Sent form my Nokia 1100



</PRE>












<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012872.html">[rabbitmq-discuss] Stress testing RabbitMQ
</A></li>
	<LI>Next message: <A HREF="012875.html">[rabbitmq-discuss] Stress testing RabbitMQ
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12873">[ date ]</a>
              <a href="thread.html#12873">[ thread ]</a>
              <a href="subject.html#12873">[ subject ]</a>
              <a href="author.html#12873">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
