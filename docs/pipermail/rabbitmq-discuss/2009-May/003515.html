<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Multicasting
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Multicasting&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003521.html">
   <LINK REL="Next"  HREF="003517.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Multicasting</H1>
    <B>bradford cross</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Multicasting&In-Reply-To="
       TITLE="[rabbitmq-discuss] Multicasting">bradford.n.cross at gmail.com
       </A><BR>
    <I>Tue May  5 03:28:37 BST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003521.html">[rabbitmq-discuss] .net client exception
</A></li>
        <LI>Next message: <A HREF="003517.html">[rabbitmq-discuss] Multicasting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3515">[ date ]</a>
              <a href="thread.html#3515">[ thread ]</a>
              <a href="subject.html#3515">[ subject ]</a>
              <a href="author.html#3515">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I would like to do redundant one-to-many multicasting from the java AMQP
client.  Well, actually, I am not sure if the word redundant is the proper
terminology or if I really need to do multicasting at all.

My requirement is to have two parallel (forked, or whatever) queues, one of
which the regular production process listens to, and one of which a backup
process listens to.

Rabbitmq seems to call this sort of thing one-to-many broadcasting and
multicast.  There is not a lot of documentation about it, just a blurb
here&lt;<A HREF="http://www.rabbitmq.com/faq.html#scenarios">http://www.rabbitmq.com/faq.html#scenarios</A>&gt;and then the code here
-&gt;
rabbitmq-java-client-1.5.4/test/src/com/rabbitmq/examples/MulticastMain.java

Looking at a snippet from the multicast code below, it is clear that each
producer and consumer runs on its own thread, on its own connection, on its
own channel, and each consumer creates its own queue.  But they all use one
exchange name, one ID, and one address (host and port.)  Is it solely these
last elements and what is happening in channel.queueBind that make this
multicast?  What exactly makes it multicasting?

Lastly, am I even headed in the right direction for what I want to do?  It
appears that I would ahve to manually write the code the puts a message into
two duplicate queues to achieve the queue for the backup.

What else is different about this multicasting and the two independent
queues in  the clojure example code below:



Clojure, two independent queues:

(defn two-independent-queues []
  (with-open [connection (let [params (doto (ConnectionParameters.)
                                        (.setVirtualHost &quot;/&quot;)
                                        (.setUsername &quot;guest&quot;)
                                        (.setPassword &quot;guest&quot;))
                               factory (ConnectionFactory. params)]
                           (.newConnection factory &quot;localhost&quot;))
              channel (.createChannel connection)
              channel2 (.createChannel connection)]
    (let [queue-name (random-id)
          queue-name2 (random-id)
          consumer (bootstrap-consumer channel exchangeName &quot;direct&quot;
queue-name id)
      consumer2 (bootstrap-consumer channel2 exchangeName &quot;direct&quot;
queue-name2 id)]
      (publish channel queue-name &quot;hello&quot;)
      (publish channel2 queue-name2 &quot;goodbye&quot;)
      (str (consume channel queue-name consumer) &quot;  &quot; (consume channel2
queue-name2 consumer2)))))




java, multicast:

 //setup
            String id = UUID.randomUUID().toString();
            Stats stats = new Stats(1000L * samplingInterval);
            Address[] addresses = new Address[] {
                new Address(hostName, portNumber)
            };
            ConnectionParameters params = new ConnectionParameters();
            Thread[] consumerThreads = new Thread[consumerCount];
            Connection[] consumerConnections = new
Connection[consumerCount];
            for (int i = 0; i &lt; consumerCount; i++) {
                System.out.println(&quot;starting consumer #&quot; + i);
                Connection conn = new
ConnectionFactory(params).newConnection(addresses, maxRedirects);
                consumerConnections[i] = conn;
                Channel channel = conn.createChannel();
                if (consumerTxSize &gt; 0) channel.txSelect();
                channel.exchangeDeclare(exchangeName, exchangeType);
                Queue.DeclareOk res = channel.queueDeclare();
                String queueName = res.getQueue();
                QueueingConsumer consumer = new QueueingConsumer(channel);
                channel.basicConsume(queueName, autoAck, consumer);
                channel.queueBind(queueName, exchangeName, id);
                Thread t =
                    new Thread(new Consumer(consumer, id,
                                            consumerTxSize, autoAck,
                                            stats, timeLimit));
                consumerThreads[i] = t;
                t.start();
            }
            Thread[] producerThreads = new Thread[producerCount];
            Connection[] producerConnections = new
Connection[producerCount];
            for (int i = 0; i &lt; producerCount; i++) {
                System.out.println(&quot;starting producer #&quot; + i);
                Connection conn = new
ConnectionFactory(params).newConnection(addresses, maxRedirects);
                producerConnections[i] = conn;
                Channel channel = conn.createChannel();
                if (producerTxSize &gt; 0) channel.txSelect();
                channel.exchangeDeclare(exchangeName, exchangeType);
                Thread t =
                    new Thread(new Producer(channel, exchangeName, id,
                                            flags, producerTxSize,
                                            1000L * samplingInterval,
                                            rateLimit, minMsgSize,
timeLimit));
                producerThreads[i] = t;
                t.start();
            }
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20090504/0b5b027c/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20090504/0b5b027c/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003521.html">[rabbitmq-discuss] .net client exception
</A></li>
	<LI>Next message: <A HREF="003517.html">[rabbitmq-discuss] Multicasting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3515">[ date ]</a>
              <a href="thread.html#3515">[ thread ]</a>
              <a href="subject.html#3515">[ subject ]</a>
              <a href="author.html#3515">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
