<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Towards better handling of RabbitMQ connection/channel failures
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Towards%20better%20handling%20of%20RabbitMQ%0A%20connection/channel%20failures&In-Reply-To=%3CCA%2Bes_-zY89EQZXaxB2YqzobzqGX8CUTVDzEiNi%3Di9fKbmnStcQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030251.html">
   <LINK REL="Next"  HREF="030273.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Towards better handling of RabbitMQ connection/channel failures</H1>
    <B>Jonathan Halterman</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Towards%20better%20handling%20of%20RabbitMQ%0A%20connection/channel%20failures&In-Reply-To=%3CCA%2Bes_-zY89EQZXaxB2YqzobzqGX8CUTVDzEiNi%3Di9fKbmnStcQ%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] Towards better handling of RabbitMQ connection/channel failures">jhalterman at gmail.com
       </A><BR>
    <I>Thu Sep 19 01:37:13 BST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="030251.html">[rabbitmq-discuss] Towards better handling of RabbitMQ	connection/channel failures
</A></li>
        <LI>Next message: <A HREF="030273.html">[rabbitmq-discuss] Towards better handling of RabbitMQ	connection/channel failures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30271">[ date ]</a>
              <a href="thread.html#30271">[ thread ]</a>
              <a href="subject.html#30271">[ subject ]</a>
              <a href="author.html#30271">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for the response Tim.

On Wed, Sep 18, 2013 at 2:59 AM, Tim Watson &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">tim at rabbitmq.com</A>&gt; wrote:

&gt;<i> Hi Jonathan,
</I>&gt;<i> On 17 Sep 2013, at 19:34, Jonathan Halterman wrote:
</I>&gt;<i>
</I>&gt;<i> Why are the shutdown listeners for only some of my channels/connections
</I>&gt;<i> called when a rabbit server shuts down?
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> All connection/channel shutdown listeners are triggered when the client
</I>&gt;<i> detects the shutdown. When the shutdown originates at the server, this
</I>&gt;<i> activity is mediated on the client side in one of two ways, either (a) the
</I>&gt;<i> client received a `connection.close' AMQP method from the broker, or (b)
</I>&gt;<i> the OS networking layer signals to the JVM that the socket has closed, at
</I>&gt;<i> which point the listening/reading thread handles the relevant exception,
</I>&gt;<i> tears down any associated local resources and fires the shutdown listeners.
</I>&gt;<i> In the latter case, there can be a significant time delay before the
</I>&gt;<i> operating system &quot;notices&quot; that the peer socket has closed/disappeared.
</I>&gt;<i> Having said all that....
</I>&gt;<i>
</I>&gt;<i> On Mon, Sep 16, 2013 at 5:13 PM, Jonathan Halterman &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">jhalterman at gmail.com</A>&gt;wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> I've been experimenting with various sorts of RabbitMQ failures that
</I>&gt;&gt;<i> result in connections and channels being shutdown with the goal of being
</I>&gt;&gt;<i> able to re-establish connections, channels, and consumers whenever a
</I>&gt;&gt;<i> failure occurs. In particular, I've been forcing network partitions on a
</I>&gt;&gt;<i> pause_minority configured cluster with a client connected to what will
</I>&gt;&gt;<i> become the minority node, to see how things behave, and the results are a
</I>&gt;&gt;<i> bit inconsistent.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> How exactly are you forcing network partitions? Are you causing packet
</I>&gt;<i> loss (using pf or iptables) or doing something else?
</I>&gt;<i>
</I>
iptables


&gt;<i>
</I>&gt;<i> For a simple test, I created 2 connections and 6 channels then partitioned
</I>&gt;&gt;<i> the cluster.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> How did you partition the cluster?
</I>&gt;<i>
</I>
Tweaking iptables to drop traffic to/from other nodes in the cluster.


&gt;<i>
</I>&gt;<i>  Within a minute or so the minority node (to which my client is connected
</I>&gt;&gt;<i> connected) shuts itself down.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> If a RabbitMQ node decides to undertake an orderly shutdown, then all AMQP
</I>&gt;<i> connections should be explicitly closed (as per method &quot;a&quot; listed above)
</I>&gt;<i> before the network connection is severed. Where this might not work as
</I>&gt;<i> expected, is if the network connection between client and server is
</I>&gt;<i> unavailable and/or subject to packet loss. If the `connection.close' signal
</I>&gt;<i> the broker sends doesn't make it to the client, then the shutdown listeners
</I>&gt;<i> won't fire until the client's (OS) network stack detects the problem, which
</I>&gt;<i> can take up to 30 mins depending on environment configuration.
</I>&gt;<i>
</I>&gt;<i> What happens next varies a bit which each test run:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Outcome 1: Immediately the shutdown listeners for my 2 connections and
</I>&gt;&gt;<i> all 6 channels are called.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> That is what I'd expect to happen if:
</I>&gt;<i>
</I>&gt;<i> 1. both connections are between the client and the broker that is shutting
</I>&gt;<i> down
</I>&gt;<i> 2. the network link between the broker that is shutting down and the
</I>&gt;<i> client is in good condition (no packet loss, etc) such that the
</I>&gt;<i> connection.close from the broker arrives at the client as expected
</I>&gt;<i>
</I>&gt;<i> Outcome 2: Immediately 2 of my 6 channels' shutdown listeners are called.
</I>&gt;&gt;<i> None of the connection shutdown listeners are called. After waiting a few
</I>&gt;&gt;<i> minutes I heal the partition and the shutdown listeners for the 2
</I>&gt;&gt;<i> connections and the remaining 4 channels are immediately called.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> That doesn't sound right. If both connections are between the client and
</I>&gt;<i> the server that is shutting down, and there is a bug in the shutdown
</I>&gt;<i> listener handling code, then this problem would be showing up all the time
</I>&gt;<i> (and we'd have fixed it). It is also unnecessary to consider
</I>&gt;<i> clustering/partitions is the behaviour you describe is happening for two
</I>&gt;<i> connection between one client and one broker.
</I>&gt;<i>
</I>&gt;<i> Can you share a minimal example of the code you're using please.
</I>&gt;<i>
</I>&gt;<i> Outcome 3: Immediate 2 of my 6 channels' shutdown listeners are called.
</I>&gt;&gt;<i> None of the connection shutdown listeners are called. After about 30
</I>&gt;&gt;<i> seconds, with the cluster still partitioned, the shutdown listeners for the
</I>&gt;&gt;<i> 2 connections and the remaining 4 channels are immediately called.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> There are no timing guarantees about when shutdown listeners will fire. As
</I>&gt;<i> I mentioned, these events are only triggered when either the client &quot;sees&quot;
</I>&gt;<i> a `connection.close' from the broker or detects a network failure whilst
</I>&gt;<i> listening/sending. Since both of these factors are entirely dependent on
</I>&gt;<i> the network between client and server, and on the networking layers of the
</I>&gt;<i> various participating operating systems, the `connection.close' and/or
</I>&gt;<i> socket closed exception will be detected when the client's OS delivers the
</I>&gt;<i> relevant signal to the JVM and up into the client library's application
</I>&gt;<i> code, at which point it is handled immediately.
</I>&gt;<i>
</I>&gt;<i> In both these two cases, if some channels are being used to `send' data,
</I>&gt;<i> and the disconnection between client and server involves loss of network
</I>&gt;<i> connectivity, then the &quot;sending&quot; channels are most likely to &quot;see&quot;
</I>&gt;<i> IOExceptions before the &quot;listening&quot; channels. Modern OS networking stacks
</I>&gt;<i> are often configured with lower retry thresholds for sending than they are
</I>&gt;<i> for receiving, thus detection of network failures will likely vary
</I>&gt;<i> considerably depending on what you're doing in a particular channel over a
</I>&gt;<i> particular connection.
</I>&gt;<i>
</I>
I think you've basically hit on what I'm experiencing. The client in
question is serving as a consumer only.


&gt;<i>
</I>&gt;<i> I'm interested to learn more about when and why certain shutdown listeners
</I>&gt;&gt;<i> might or might not be invoked so I can do a better job of re-establishing
</I>&gt;&gt;<i> resources after a failure. Any input is appreciated.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> If you can share an example of your client code, boiled down to the
</I>&gt;<i> minimal details, that would help. Please also confirm exactly what your
</I>&gt;<i> setup looks like, viz
</I>&gt;<i>
</I>
I wrote a test attempting to reproduce what my actual client is
experiencing, but I was only able to come close to reproducing my client's
results when pushing a lot of volume down to the consumers, and even then
it was not consistent enough to draw any conclusions. At this point I'm
satisfied to simply tweak my client to account for potential delays in
ShutdownListener calls and move on. I just wanted to be sure that there
were no mechanisms introduced by amqp-client which could be causing any
additional ShutdownListener delays, and it sounds like there are not.

Cheers,
Jonathan


&gt;<i>
</I>&gt;<i> 1. are both connections made between the client and exactly one server
</I>&gt;<i>
</I>2. how are you &quot;partitioning&quot; the server from the rest of the cluster
&gt;<i>
</I>3. are you sending or receiving on the various channels that we're talking
&gt;<i> about
</I>&gt;<i>
</I>
&gt;<i> Tim
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130918/4ec20b14/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130918/4ec20b14/attachment.htm</A>&gt;
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030251.html">[rabbitmq-discuss] Towards better handling of RabbitMQ	connection/channel failures
</A></li>
	<LI>Next message: <A HREF="030273.html">[rabbitmq-discuss] Towards better handling of RabbitMQ	connection/channel failures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30271">[ date ]</a>
              <a href="thread.html#30271">[ thread ]</a>
              <a href="subject.html#30271">[ subject ]</a>
              <a href="author.html#30271">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
