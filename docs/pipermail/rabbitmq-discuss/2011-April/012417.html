<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Creating a job only once (using Java Client	API)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Creating%20a%20job%20only%20once%20%28using%20Java%20Client%0A%09API%29&In-Reply-To=%3CBANLkTikbnqYKK1m%3DvLKuEfZjXVj7UWX11Q%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012416.html">
   <LINK REL="Next"  HREF="012435.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Creating a job only once (using Java Client	API)</H1>
    <B>Allan Kamau</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Creating%20a%20job%20only%20once%20%28using%20Java%20Client%0A%09API%29&In-Reply-To=%3CBANLkTikbnqYKK1m%3DvLKuEfZjXVj7UWX11Q%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] Creating a job only once (using Java Client	API)">kamauallan at gmail.com
       </A><BR>
    <I>Sat Apr 16 15:18:36 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="012416.html">[rabbitmq-discuss] Creating a job only once (using Java Client	API)
</A></li>
        <LI>Next message: <A HREF="012435.html">[rabbitmq-discuss] Creating a job only once (using Java Client	API)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12417">[ date ]</a>
              <a href="thread.html#12417">[ thread ]</a>
              <a href="subject.html#12417">[ subject ]</a>
              <a href="author.html#12417">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> On Apr 16, 2011, at 7:03 AM, Allan Kamau wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> I have potentially many clients what may attempt create a given type
</I>&gt;&gt;<i> of job at the same time and more than once. And I would like the given
</I>&gt;&gt;<i> job (maybe identified by a job_name) for the given queue to be created
</I>&gt;&gt;<i> only once. And for the given job to be or have been executed
</I>&gt;&gt;<i> successfully only once in the future, present or in the past.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is the long format of the situation.
</I>&gt;&gt;<i> I have several clients for whom a particular initialization step needs
</I>&gt;&gt;<i> to happen only once. Each such client represents an instance of an
</I>&gt;&gt;<i> application I am executing in parallel, for a particular node I would
</I>&gt;&gt;<i> like some data initialization procedure to be run only once triggered
</I>&gt;&gt;<i> by a single instance of these processes even though there will be many
</I>&gt;&gt;<i> such instances (processes) started at the same time. After the task
</I>&gt;&gt;<i> has been created a note that such a task as already been created
</I>&gt;&gt;<i> (already run or not) should be evident for all instances of this
</I>&gt;&gt;<i> application present and even for the instances to be created in the
</I>&gt;&gt;<i> future accessing a given queue_name.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Below is what I have tried without much success.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &#160; &#160; public void runHelper()throws IOException,java.lang.InterruptedException
</I>&gt;&gt;<i> &#160; &#160; &#160; {
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; long start_time=System.currentTimeMillis();
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; long duration=0;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; ConnectionFactory factory=new ConnectionFactory();
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; factory.setHost(&quot;localhost&quot;);
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; Connection connection=factory.newConnection();
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; Channel channel=connection.createChannel();
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; channel.queueDeclare(queue_name,false,false,false,null);
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; String message=null;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; QueueingConsumer consumer=new QueueingConsumer(channel);
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; boolean autoAck=false;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; channel.basicConsume(queue_name,autoAck,consumer);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; int messages_cnt=0;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; for(int i=1;i&lt;=number_of_messages;i++)
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; {
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; QueueingConsumer.Delivery
</I>&gt;&gt;<i> delivery=consumer.nextDelivery(1000);//consumer.nextDelivery();
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if(delivery==null)
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; {
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; //this means no message has been send received for the given
</I>&gt;&gt;<i> channel and queue.
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; //so let's send one.
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; message=&quot;dothis, from \&quot;&quot;+_id__producer+&quot;\&quot;, id:&quot;+i;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; channel.basicPublish(&quot;&quot;,queue_name,null,message.getBytes());
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; number_of_jobs_posted++;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; {
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; //consume the message
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; messages_cnt+=1;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; String message2=new String(delivery.getBody());
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if(message2.startsWith(&quot;dothis&quot;))
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; {
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; System.out.println(new java.util.Date()+&quot;,
</I>&gt;&gt;<i> _id__producer:\&quot;&quot;+_id__producer+&quot;\&quot;, got the job to be executed only
</I>&gt;&gt;<i> once:\&quot;&quot;+message2+&quot;\&quot;&quot;);
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; message2=&quot;donethat&quot;;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; channel.basicPublish(&quot;&quot;,queue_name,null,message2.getBytes());
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; number_of_jobs_received++;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; {
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; //do not acknowledge the receiption of the message.
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; System.out.println(new java.util.Date()+&quot; -
</I>&gt;&gt;<i> _id__producer:\&quot;&quot;+_id__producer+&quot;\&quot;, messages_cnt:&quot;+messages_cnt+&quot;,
</I>&gt;&gt;<i> [x]Received:'&quot;+message2+&quot;'. &quot;+new java.util.Date());
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; duration=System.currentTimeMillis()-start_time;
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; System.out.println(&quot;[x] Thread:\&quot;&quot;+_id__producer+&quot;\&quot; completed
</I>&gt;&gt;<i> sending:&quot;+number_of_messages+&quot;, messages in:&quot;+duration+&quot;ms.&quot;);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; channel.close();
</I>&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; connection.close();
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &#160; &#160; &#160; }
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> rabbitmq-discuss mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>

On Sat, Apr 16, 2011 at 4:51 PM, Jon Brisbin &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">jon at jbrisbin.com</A>&gt; wrote:
&gt;<i> Can't your initialization code respond to a message and immediately de-register itself as a consumer?
</I>&gt;<i>
</I>&gt;<i> Given a routing key binding of &quot;my.work.topic.*&quot; for workers, a single initializer could be bound using &quot;#&quot; and de-register itself as soon as its init code completes:
</I>&gt;<i>
</I>&gt;<i> synchronized(this) {
</I>&gt;<i>  init();
</I>&gt;<i>  cancel();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> jb
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Thanks!
</I>&gt;<i>
</I>&gt;<i> Jon Brisbin
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://jbrisbin.com">http://jbrisbin.com</A>
</I>&gt;<i> Twitter: @j_brisbin
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>



The initialization code does exist as a centralized module.
This is the situation. I am developing a distributed application which
comprises of several instances of itself at runtime. A single instance
of this application would be mostly single threaded and have no
interprocess communication and can be viewed as a worker. On the fly I
would like to start additional such single instances on a given
PC/server and even start such instances on other physical computers at
will. At the moment I am looking for a way for any such independent
instance to know (learn) if it is indeed the first such instance on
the given PC to reach a given processing step. Then perform the
priming procedures for this step, in the mean time the other instances
should be notified (as a response to a job request) of the ongoing
priming procedure when they reach the start of the given processing
step and wait for the process to complete and only then engage in the
processing of this step.
I am trying to see if I can use AMQP (using RabbitMQ) for end of task
gate keeping in addition to hosting jobs for the distributed worker
application instances.

Allan.
</PRE>






































































































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012416.html">[rabbitmq-discuss] Creating a job only once (using Java Client	API)
</A></li>
	<LI>Next message: <A HREF="012435.html">[rabbitmq-discuss] Creating a job only once (using Java Client	API)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12417">[ date ]</a>
              <a href="thread.html#12417">[ thread ]</a>
              <a href="subject.html#12417">[ subject ]</a>
              <a href="author.html#12417">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
