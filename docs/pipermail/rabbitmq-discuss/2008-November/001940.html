<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Flow Control
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Flow%20Control&In-Reply-To=269388e30811100724r64614b89lb28c76f6ad102760%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001937.html">
   <LINK REL="Next"  HREF="001944.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Flow Control</H1>
    <B>Edwin Fine</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Flow%20Control&In-Reply-To=269388e30811100724r64614b89lb28c76f6ad102760%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Flow Control">rabbitmq-discuss_efine at usa.net
       </A><BR>
    <I>Mon Nov 10 16:18:19 GMT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001937.html">[rabbitmq-discuss] Flow Control
</A></li>
        <LI>Next message: <A HREF="001944.html">[rabbitmq-discuss] Flow Control
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1940">[ date ]</a>
              <a href="thread.html#1940">[ thread ]</a>
              <a href="subject.html#1940">[ subject ]</a>
              <a href="author.html#1940">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, Nov 10, 2008 at 10:24 AM, Ben Hood &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">0x6e6562 at gmail.com</A>&gt; wrote:

&gt;<i> Edwin,
</I>&gt;<i>
</I>&gt;<i> On Sun, Nov 9, 2008 at 11:00 PM, Edwin Fine
</I>&gt;<i> &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss_efine at usa.net</A>&gt; wrote:
</I>&gt;<i> &gt; Truly, I always felt uncomfortable with using a cast on publish because
</I>&gt;<i> you
</I>&gt;<i> &gt; can't tell directly if there was a problem. I'd prefer a call.
</I>&gt;<i>
</I>&gt;<i> Interesting that you should touch on the issue of transfer of
</I>&gt;<i> responsibility in this context. I guess the question you need to ask
</I>&gt;<i> is if there is a case where you can do a gen_server:cast and either
</I>&gt;<i> loose the message full stop or loose the ordering. My initial thought
</I>&gt;<i> is that all practical cases, this is not a problem, but I am following
</I>&gt;<i> this up with a question on the Erlang list (which you've probably seen
</I>&gt;<i> already).
</I>&gt;<i>
</I>&gt;<i> At this point in time I would be reticent to turn this is into a
</I>&gt;<i> gen_server:call/3 because cast/2
</I>&gt;<i>
</I>&gt;<i> a) matches the asynchronous semantics of the publish command;
</I>&gt;<i> b) is a lot quicker than a call;
</I>&gt;<i> c) it is pending clarification as to whether there are actually
</I>&gt;<i> reordering issues.
</I>&gt;<i>
</I>&gt;<i> Also, even if you use a call, how will you know that the message
</I>&gt;<i> hasn't been binned by the gen_server instance that you invoked
</I>&gt;<i> quasi-synchronously?
</I>&gt;<i>
</I>
Because the call will return an ok?


&gt;<i>
</I>&gt;<i> In general if you want to make sure that you are not losing messages,
</I>&gt;<i> you should consider using transactions. Or what would be even better
</I>&gt;<i> would be to have an application level acknowledgement.
</I>&gt;<i>
</I>
Application level acknowldgement, meaning that my consumer explicitly sends
an application-level acknowledgement message to the producer? Let me
hopefully not annoy you by again comparing with WebSphere MQ. When you PUT a
message to the queue manager, you get a return code which, if it is a
success, means that the queue manager has got your message and it's all
good. No app level acks needed. No transactions needed. With using a cast to
send a message to the broker, if the client has a problem with the message
(this happened to me recently), the producer has no idea of this. I only
found out by seeing errors in my log file. Or at least, I don't know of a
way to find out other than by starting a transaction, which I am loath to do
because of performance concerns.

What happened is that I refactored some code and in doing so created a bug
that tried to send a record instead of a list in the basic.publish. Yes, my
fault, but I would have liked to have known about it at the code level. The
message was lost because there apparently was no way to detect this, let
alone recover from it (except maybe the txn, which I have not tried).

== 8-Nov-2008::20:08:59 == ERROR -  emulator
Error in process &lt;0.191.0&gt; on node '<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">xhg_rel at ender</A>' with exit value:
{badarg,[{erlang,list_to_binary,[{frame_rec,&lt;&lt;217
bytes&gt;&gt;,1226192940,0,active,ok,0,undefined,0,&lt;&lt;33
bytes&gt;&gt;}]},{rabbit_binary_generator,create_frame,3},{rabbit_binary_generator,build_content_frames,5},{rabbit_binary_generator,build_simple_content_frames...



&gt;<i> Maybe this is a hare-brained idea, but can't the broker just send a
</I>&gt;<i> channel.flow to the producer; the Erlang client just forwards it on to the
</I>&gt;<i> producer in precisely the same way as it sends a basic.receive to a
</I>&gt;<i> consumer? The publishing application would just need to write a
</I>handle_info
&gt;<i> for channel.flow just like a consumer does for basic.receive, or have I
</I>&gt;<i> missed the point?
</I>
When you say basic.receive, I assume you mean basic.deliver.
&gt;<i>
</I>Yes, sorry.


&gt;<i>
</I>&gt;<i> Have you looked at the test that I wrote for this in the test_util
</I>&gt;<i> module - it does pretty much what you describe.
</I>&gt;<i>
</I>
I have looked at the test, but it does not do anything like what I was
trying to describe :)

What I was trying to describe was having a gen_server or gen_fsm that has a
clause something like this;

handle_info(#'channel.flow'{active = false}, State) -&gt;
    {noreply, State#state{channel_flow = false}};

handle_info(#'channel.flow'{active = true}, State) -&gt;
    {noreply, State#state{channel_flow = true}};

When receiving the &quot;down&quot; signal, the producer can then go into an idle
state voluntarily. I don't like the idea of the client silently throwing
away producer messages.



&gt;<i> &gt; I realize that this means that publishing applications can choose to
</I>&gt;<i> ignore
</I>&gt;<i> &gt; channel.flow commands, but that would be shooting themselves in the foot.
</I>&gt;<i> In
</I>&gt;<i> &gt; the 0.8 spec it says &quot;The peer that requests a Channel.Flow method MAY
</I>&gt;<i> &gt; disconnect and/or ban a peer that does not respect the request.&quot;, so the
</I>&gt;<i> &gt; server could just drop the channel if the publisher ignores it.
</I>&gt;<i>
</I>&gt;<i> That's what it will eventually do.
</I>&gt;<i>
</I>&gt;<i> &gt; Now I am not sure what is meant by a &quot;peer&quot;, if that's the client itself
</I>&gt;<i> or
</I>&gt;<i> &gt; the application that is using the client. Either way, I believe that the
</I>&gt;<i> &gt; Erlang client simply forwarding the channel.flow command to the
</I>&gt;<i> application
</I>&gt;<i> &gt; and requiring it to respond with the ok (and stop sending) is within the
</I>&gt;<i> &gt; spirit of the spec, and should (?) be simple to do in the client.
</I>&gt;<i>
</I>&gt;<i> ATM the client sends the ack back after it has asynchronously notified
</I>&gt;<i> the sending application. The registration for this is analogous to the
</I>&gt;<i> return listener registration process (in fact it's copy and paste). If
</I>&gt;<i> the flag is set, any invocation of the cast function will silently
</I>&gt;<i> discard the message.
</I>&gt;<i>
</I>
I really don't like the sound of that. I don't like silent discards in
general.


&gt;<i> I think that doing it this way round would be cooler than turning the
</I>&gt;<i> cast into a call in order to be able to read the state of the channel
</I>&gt;<i> flow flag.
</I>&gt;<i>
</I>
Well, how about what I suggested above? Just let the client pass the
channel.flow on to the app. Why not?

&gt;<i>
</I>&gt;<i> The only issue I see is the added complexity involved in the
</I>&gt;<i> application - it would have to have a receive loop that matches on the
</I>&gt;<i> pause and resume atoms sent to it by the channel process.
</I>&gt;<i>
</I>
Not if done the way I suggested. Then it just becomes another handle_info
clause and state change.


&gt;<i>
</I>&gt;<i> Maybe there is a way to build a convenience function for this in lib_amqp?
</I>&gt;<i>
</I>&gt;<i> Ben
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20081110/c51b5e05/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20081110/c51b5e05/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001937.html">[rabbitmq-discuss] Flow Control
</A></li>
	<LI>Next message: <A HREF="001944.html">[rabbitmq-discuss] Flow Control
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1940">[ date ]</a>
              <a href="thread.html#1940">[ thread ]</a>
              <a href="subject.html#1940">[ subject ]</a>
              <a href="author.html#1940">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
