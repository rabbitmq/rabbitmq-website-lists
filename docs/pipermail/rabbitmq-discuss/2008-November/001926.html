<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Flow Control
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Flow%20Control&In-Reply-To=269388e30811091428t8eabd21l10e61a3bd451037b%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001925.html">
   <LINK REL="Next"  HREF="001937.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Flow Control</H1>
    <B>Edwin Fine</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Flow%20Control&In-Reply-To=269388e30811091428t8eabd21l10e61a3bd451037b%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Flow Control">rabbitmq-discuss_efine at usa.net
       </A><BR>
    <I>Sun Nov  9 23:00:16 GMT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001925.html">[rabbitmq-discuss] Flow Control
</A></li>
        <LI>Next message: <A HREF="001937.html">[rabbitmq-discuss] Flow Control
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1926">[ date ]</a>
              <a href="thread.html#1926">[ thread ]</a>
              <a href="subject.html#1926">[ subject ]</a>
              <a href="author.html#1926">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ben,

Truly, I always felt uncomfortable with using a cast on publish because you
can't tell directly if there was a problem. I'd prefer a call.

Maybe this is a hare-brained idea, but can't the broker just send a
channel.flow to the producer; the Erlang client just forwards it on to the
producer in precisely the same way as it sends a basic.receive to a
consumer? The publishing application would just need to write a handle_info
for channel.flow just like a consumer does for basic.receive, or have I
missed the point?

I realize that this means that publishing applications can choose to ignore
channel.flow commands, but that would be shooting themselves in the foot. In
the 0.8 spec it says &quot;The peer that requests a Channel.Flow method MAY
disconnect and/or ban a peer that does not respect the request.&quot;, so the
server could just drop the channel if the publisher ignores it.

Now I am not sure what is meant by a &quot;peer&quot;, if that's the client itself or
the application that is using the client. Either way, I believe that the
Erlang client simply forwarding the channel.flow command to the application
and requiring it to respond with the ok (and stop sending) is within the
spirit of the spec, and should (?) be simple to do in the client.

Can you see any issues with doing it like this?

Regards,
Ed

On Sun, Nov 9, 2008 at 5:28 PM, Ben Hood &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">0x6e6562 at gmail.com</A>&gt; wrote:

&gt;<i> Edwin,
</I>&gt;<i>
</I>&gt;<i> On Sun, Nov 9, 2008 at 6:58 PM, Edwin Fine
</I>&gt;<i> &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss_efine at usa.net</A>&gt; wrote:
</I>&gt;<i> &gt; This is greatly welcome news! I look forward to the implementation of
</I>&gt;<i> this
</I>&gt;<i> &gt; in the Erlang client, so that I can pause my producers when I get the
</I>&gt;<i> &gt; channel.flow command from the broker and avoid any possibility of
</I>&gt;<i> exhausting
</I>&gt;<i> &gt; Rabbit's memory. Any ETA?
</I>&gt;<i>
</I>&gt;<i> Not really. But I have knocked up a first version that works - 19560
</I>&gt;<i> refers. The only I am not sure about yet is the fact that publish
</I>&gt;<i> function uses gen_server:cast/2 under the covers, making it difficult
</I>&gt;<i> to on this invocation. My first thought was to keep the cast/2
</I>&gt;<i> invocation as it is and just send out {pause,resume} atoms to a
</I>&gt;<i> registered flow control handler, but this means more code on the
</I>&gt;<i> client side. I suppose you could add a convenience function to
</I>&gt;<i> encapsulate the blocking receive when you're in the pause state, but
</I>&gt;<i> there may be a simpler way to do this. Have a look at the code
</I>&gt;<i> yourself and maybe you have an idea.
</I>&gt;<i>
</I>&gt;<i> HTH,
</I>&gt;<i>
</I>&gt;<i> Ben
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20081109/062eb915/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20081109/062eb915/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001925.html">[rabbitmq-discuss] Flow Control
</A></li>
	<LI>Next message: <A HREF="001937.html">[rabbitmq-discuss] Flow Control
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1926">[ date ]</a>
              <a href="thread.html#1926">[ thread ]</a>
              <a href="subject.html#1926">[ subject ]</a>
              <a href="author.html#1926">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
