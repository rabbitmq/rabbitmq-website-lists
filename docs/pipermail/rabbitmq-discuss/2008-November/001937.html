<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Flow Control
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Flow%20Control&In-Reply-To=6c2563b20811091500o1c242b54nbd5e11d46811f73a%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001926.html">
   <LINK REL="Next"  HREF="001940.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Flow Control</H1>
    <B>Ben Hood</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Flow%20Control&In-Reply-To=6c2563b20811091500o1c242b54nbd5e11d46811f73a%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Flow Control">0x6e6562 at gmail.com
       </A><BR>
    <I>Mon Nov 10 15:24:56 GMT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001926.html">[rabbitmq-discuss] Flow Control
</A></li>
        <LI>Next message: <A HREF="001940.html">[rabbitmq-discuss] Flow Control
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1937">[ date ]</a>
              <a href="thread.html#1937">[ thread ]</a>
              <a href="subject.html#1937">[ subject ]</a>
              <a href="author.html#1937">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Edwin,

On Sun, Nov 9, 2008 at 11:00 PM, Edwin Fine
&lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss_efine at usa.net</A>&gt; wrote:
&gt;<i> Truly, I always felt uncomfortable with using a cast on publish because you
</I>&gt;<i> can't tell directly if there was a problem. I'd prefer a call.
</I>
Interesting that you should touch on the issue of transfer of
responsibility in this context. I guess the question you need to ask
is if there is a case where you can do a gen_server:cast and either
loose the message full stop or loose the ordering. My initial thought
is that all practical cases, this is not a problem, but I am following
this up with a question on the Erlang list (which you've probably seen
already).

At this point in time I would be reticent to turn this is into a
gen_server:call/3 because cast/2

a) matches the asynchronous semantics of the publish command;
b) is a lot quicker than a call;
c) it is pending clarification as to whether there are actually
reordering issues.

Also, even if you use a call, how will you know that the message
hasn't been binned by the gen_server instance that you invoked
quasi-synchronously?

In general if you want to make sure that you are not losing messages,
you should consider using transactions. Or what would be even better
would be to have an application level acknowledgement.


&gt;<i> Maybe this is a hare-brained idea, but can't the broker just send a
</I>&gt;<i> channel.flow to the producer; the Erlang client just forwards it on to the
</I>&gt;<i> producer in precisely the same way as it sends a basic.receive to a
</I>&gt;<i> consumer? The publishing application would just need to write a handle_info
</I>&gt;<i> for channel.flow just like a consumer does for basic.receive, or have I
</I>&gt;<i> missed the point?
</I>
When you say basic.receive, I assume you mean basic.deliver.

Have you looked at the test that I wrote for this in the test_util
module - it does pretty much what you describe.

&gt;<i> I realize that this means that publishing applications can choose to ignore
</I>&gt;<i> channel.flow commands, but that would be shooting themselves in the foot. In
</I>&gt;<i> the 0.8 spec it says &quot;The peer that requests a Channel.Flow method MAY
</I>&gt;<i> disconnect and/or ban a peer that does not respect the request.&quot;, so the
</I>&gt;<i> server could just drop the channel if the publisher ignores it.
</I>
That's what it will eventually do.

&gt;<i> Now I am not sure what is meant by a &quot;peer&quot;, if that's the client itself or
</I>&gt;<i> the application that is using the client. Either way, I believe that the
</I>&gt;<i> Erlang client simply forwarding the channel.flow command to the application
</I>&gt;<i> and requiring it to respond with the ok (and stop sending) is within the
</I>&gt;<i> spirit of the spec, and should (?) be simple to do in the client.
</I>
ATM the client sends the ack back after it has asynchronously notified
the sending application. The registration for this is analogous to the
return listener registration process (in fact it's copy and paste). If
the flag is set, any invocation of the cast function will silently
discard the message.

I think that doing it this way round would be cooler than turning the
cast into a call in order to be able to read the state of the channel
flow flag.

The only issue I see is the added complexity involved in the
application - it would have to have a receive loop that matches on the
pause and resume atoms sent to it by the channel process.

Maybe there is a way to build a convenience function for this in lib_amqp?

Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001926.html">[rabbitmq-discuss] Flow Control
</A></li>
	<LI>Next message: <A HREF="001940.html">[rabbitmq-discuss] Flow Control
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1937">[ date ]</a>
              <a href="thread.html#1937">[ thread ]</a>
              <a href="subject.html#1937">[ subject ]</a>
              <a href="author.html#1937">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
