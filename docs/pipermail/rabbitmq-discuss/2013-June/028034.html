<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Getting many messages, ack() failing if total messages not equal a 10 increment
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Getting%20many%20messages%2C%0A%20ack%28%29%20failing%20if%20total%20messages%20not%20equal%20a%2010%20increment&In-Reply-To=%3Cfaba7352-9c2e-4d87-ab8f-8fa8370941bd%40googlegroups.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="028049.html">
   <LINK REL="Next"  HREF="028168.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Getting many messages, ack() failing if total messages not equal a 10 increment</H1>
    <B>Matthew Taft</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Getting%20many%20messages%2C%0A%20ack%28%29%20failing%20if%20total%20messages%20not%20equal%20a%2010%20increment&In-Reply-To=%3Cfaba7352-9c2e-4d87-ab8f-8fa8370941bd%40googlegroups.com%3E"
       TITLE="[rabbitmq-discuss] Getting many messages, ack() failing if total messages not equal a 10 increment">matthewetaft at gmail.com
       </A><BR>
    <I>Sat Jun 22 15:32:11 BST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="028049.html">[rabbitmq-discuss] Request: Enable/Disable Firehose via Management API
</A></li>
        <LI>Next message: <A HREF="028168.html">[rabbitmq-discuss] Getting many messages,	ack() failing if total messages not equal a 10 increment
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28034">[ date ]</a>
              <a href="thread.html#28034">[ thread ]</a>
              <a href="subject.html#28034">[ subject ]</a>
              <a href="author.html#28034">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi everyone,

Hoping someone can help me with this problem.  After going through a few 
tutorials, I've pieced together some code the produce and consume messages. 
 I'm using kombu.  I'lll past the code below.  But the idea is to be able 
to send many messages to the queue, possibly hundreds, then have a periodic 
task that wakes up and consumes all messages.  Right now I haven't set up 
the periodic task.  It's just a simply python file.  When passed &quot;produce,&quot; 
it produces some random messages.  When passed &quot;consume,&quot; it consumes them.

I've found that when the total messages is in increments of 10 (90, 100, 
510, etc.), all messages get processed correctly and the qsize value shows 
there are 0 messages remaining.  However -- and this is better explained by 
example - if the queue contains 78 messages, after processing all of them, 
the queue reports 8 remaining, but the consumer can no longer get them 
(times out).  Any time the total qsize at the start is anything other than 
a 10 increment (129, 523, 234, etc.), the part beyond the latest 10 
increment is left remaining (9, 3, 4, etc.). 

I've added some print statements to confirm that each message is actually 
consumed correctly, and the ack() is being called for each one.  However, I 
noticed that the qsize value is only being updated every 10 messages. 
 Here's the log for some of them to give you a better idea. The first 
number is the counter.  It's shown three times for each message because I'm 
printing before the get, after the get, then after the ack().  Notice the 
qsize value only updates every 10 messages:

--------------------------------------------------------------------------------
Total Messages: 78
--------------------------------------------------------------------------------
Counter | Status
0: amount before queue.get: 78
0: amount after queue.get, before ack(): 78
0: amount after queue.get, after ack(): 78
1: amount before queue.get: 78
1: amount after queue.get, before ack(): 78
1: amount after queue.get, after ack(): 78
2: amount before queue.get: 78
2: amount after queue.get, before ack(): 78
2: amount after queue.get, after ack(): 78
3: amount before queue.get: 78
3: amount after queue.get, before ack(): 78
3: amount after queue.get, after ack(): 78
4: amount before queue.get: 78
4: amount after queue.get, before ack(): 78
4: amount after queue.get, after ack(): 78
5: amount before queue.get: 78
5: amount after queue.get, before ack(): 78
5: amount after queue.get, after ack(): 78
6: amount before queue.get: 78
6: amount after queue.get, before ack(): 78
6: amount after queue.get, after ack(): 78
7: amount before queue.get: 78
7: amount after queue.get, before ack(): 78
7: amount after queue.get, after ack(): 78
8: amount before queue.get: 78
8: amount after queue.get, before ack(): 78
8: amount after queue.get, after ack(): 78
9: amount before queue.get: 78
9: amount after queue.get, before ack(): 68
9: amount after queue.get, after ack(): 68

Is it just some configuration I have to set?  Or is there something wrong 
in the code?  Here's the code in full:

import sys
from contextlib import closing
from django.conf import settings
from django.dispatch import Signal
from django.dispatch import receiver
from kombu import BrokerConnection
from Queue import Empty

# Test Stuff:
queue_name = &quot;my.messages&quot;
test_messages_to_produce = 78
consumer_batch_size = 100
consumer_timeout = 5


class UserMessenger(object):
    &quot;&quot;&quot;
    Class for producing and consuming messages
    &quot;&quot;&quot;
    def __init__(self, connection, queue_name, serializer=&quot;json&quot;, 
compression=None):
        self.queue = connection.SimpleQueue(queue_name)
        self.serializer = serializer
        self.compression = compression

    def produce_message(self, context={}):
        self.queue.put(context,
                       serializer=self.serializer,
                       compression=self.compression)

    def consume_messages(self, callback, messages_to_get=1, timeout=1):
        for i in range(messages_to_get):
            try:
                before_get = self.get_message_count()
                message = self.queue.get(block=True, timeout=timeout)
                callback(message.payload)

                after_get_before_ack = self.get_message_count()
                message.ack() # remove message from queue
                after_get_after_ack = self.get_message_count()

                deserialized = message.payload
                user_id = deserialized[&quot;user_id&quot;]
                print(&quot;%d: amount before queue.get: %d&quot; % (user_id, 
before_get))
                print(&quot;%d: amount after queue.get, before ack(): %d&quot; % 
(user_id, after_get_before_ack))
                print(&quot;%d: amount after queue.get, after ack(): %d&quot; % 
(user_id, after_get_after_ack))
            except Empty as e:
                break;

    def get_message_count(self):
        return self.queue.qsize()

    def purge_messages(self):
        self.queue.clear()

    def close(self):
        self.queue.close()


def produce():
    with BrokerConnection(settings.BROKER_URL) as connection:
        with closing(UserMessenger(connection, queue_name)) as messenger:

            #Just produce some random messages for now:
            for i in range(test_messages_to_produce):
                context = {
                    &quot;user_id&quot;: i,
                    &quot;changed_fields&quot;: {
                        'first_name': {
                            'before':'albert',
                            'after':'Albert'
                     }}}

                messenger.produce_message(context)


def consume():
    messages = []

    def consume_message_callback(message):
        &quot;&quot;&quot;
        This callback passed to the messenger consume_messages method, 
which calls it for each message.
        Just append to messages for now.
        &quot;&quot;&quot;
        if message is not None:
            messages.append(message)


    with BrokerConnection(settings.BROKER_URL) as connection:
        with closing(UserMessenger(connection, queue_name)) as messenger:
            messages_count = messenger.get_message_count()

            # Debug: How many total?
            print &quot;-&quot; * 80; print &quot;Total Messages: %d&quot; % messages_count; 
print &quot;-&quot; * 80

            for i in range(0, messages_count, consumer_batch_size):
                messenger.consume_messages(
                            consume_message_callback,
                            messages_to_get = consumer_batch_size,
                            timeout = consumer_timeout,
                        )

            # Debug: Print the results.
            print &quot;Should be done now.  Let's see what we have:&quot;
            for message in messages:
                print message

def purge():
    &quot;&quot;&quot;
    Delete messages (for debugging)
    &quot;&quot;&quot;
    with BrokerConnection(settings.BROKER_URL) as connection:
        with closing(UserMessenger(connection, queue_name)) as messenger:
            messenger.purge_messages()

def status():
    &quot;&quot;&quot;
    Get messages on queue (for debugging)
    &quot;&quot;&quot;
    with BrokerConnection(settings.BROKER_URL) as connection:
        with closing(UserMessenger(connection, queue_name)) as messenger:
            print(&quot;Remaining messages: %d&quot; % messenger.queue.qsize())


if __name__ == &quot;__main__&quot;:
    if sys.argv[0].startswith(&quot;python&quot;):
        option_index = 2
    else:
        option_index = 1
    option = sys.argv[option_index]

    if option == &quot;produce&quot;:
        produce()
    elif option == &quot;consume&quot;:
        consume()
    elif option == &quot;purge&quot;:
        purge()
    elif option == &quot;status&quot;:
        status()
    else:
        print &quot;Unknown option '%s'; exiting ...&quot; % option
        sys.exit(1)

-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130622/79132aca/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130622/79132aca/attachment.htm</A>&gt;
</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="028049.html">[rabbitmq-discuss] Request: Enable/Disable Firehose via Management API
</A></li>
	<LI>Next message: <A HREF="028168.html">[rabbitmq-discuss] Getting many messages,	ack() failing if total messages not equal a 10 increment
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28034">[ date ]</a>
              <a href="thread.html#28034">[ thread ]</a>
              <a href="subject.html#28034">[ subject ]</a>
              <a href="author.html#28034">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
