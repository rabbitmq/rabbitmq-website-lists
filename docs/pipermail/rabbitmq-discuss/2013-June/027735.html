<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Durability and consumer acknowledgement	extremely slow
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Durability%20and%20consumer%20acknowledgement%0A%09extremely%20slow&In-Reply-To=%3C64919f75-c730-4720-b008-b7fc665849bc%40googlegroups.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027738.html">
   <LINK REL="Next"  HREF="027739.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Durability and consumer acknowledgement	extremely slow</H1>
    <B>Joost Reuzel</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Durability%20and%20consumer%20acknowledgement%0A%09extremely%20slow&In-Reply-To=%3C64919f75-c730-4720-b008-b7fc665849bc%40googlegroups.com%3E"
       TITLE="[rabbitmq-discuss] Durability and consumer acknowledgement	extremely slow">joost.reuzel at gmail.com
       </A><BR>
    <I>Thu Jun  6 13:43:30 BST 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="027738.html">[rabbitmq-discuss] RabbitMQ read performance does not grow when we add more subscribers?
</A></li>
        <LI>Next message: <A HREF="027739.html">[rabbitmq-discuss] Durability and consumer acknowledgement extremely slow
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27735">[ date ]</a>
              <a href="thread.html#27735">[ thread ]</a>
              <a href="subject.html#27735">[ subject ]</a>
              <a href="author.html#27735">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>We encountered perhaps the same issue. This time not on Amazon, but with 
simple VMWare instances. We are using the .NET client. This would imply 
indeed that it is some behavioral aspect of the node. It would be very 
helpful if someone can explain what is happening here.

Regards,
Joost


On Wednesday, April 24, 2013 6:26:42 PM UTC+2, Karl Rieb wrote:
&gt;<i>
</I>&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> I am trying to improve the message throughput for a RabbitMQ queue in an 
</I>&gt;<i> Amazon cloud instance and am noticing a *significant* drop in performance 
</I>&gt;<i> when enabling acknowledgements for consumer of a durable queue (with 
</I>&gt;<i> persisted messages).  The real problem is that the bottleneck appears to be 
</I>&gt;<i> on the rabbit node and not with the consumers, so adding more consumers 
</I>&gt;<i> does not improve the throughput (or help drain the queue any quicker).  As 
</I>&gt;<i> a matter of fact, adding new consumers will just slow down existing 
</I>&gt;<i> consumers so everyone ends up consuming at a slower rate, preventing 
</I>&gt;<i> overall throughput from changing.
</I>&gt;<i>
</I>&gt;<i> Trying to do batch acknowledgements using the Multiple flag helps a bit 
</I>&gt;<i> (8k msgs/s vs 5.5k msgs/s) but not much compared to the initial drop.  It 
</I>&gt;<i> is only when I turn on *auto_ack* for the consumers that I see the 
</I>&gt;<i> performance shoot *way *back up and when I start seeing a linear increase 
</I>&gt;<i> in throughput as I add more consumers.
</I>&gt;<i>
</I>&gt;<i> Is this expected behavior?  Is there a way to configure the rabbit node so 
</I>&gt;<i> it doesn't hit this bottleneck with acknowledgements?
</I>&gt;<i>
</I>&gt;<i> Here is the sample code I'm using to test the throughput:
</I>&gt;<i>
</I>&gt;<i> Publisher:
</I>&gt;<i>
</I>&gt;<i> #!/usr/bin/python
</I>&gt;<i>
</I>&gt;<i> import pika
</I>&gt;<i>
</I>&gt;<i> creds = pika.PlainCredentials('guest','guest')
</I>&gt;<i> conn  = 
</I>&gt;<i> pika.BlockingConnection(pika.ConnectionParameters(host='10.10.1.123', 
</I>&gt;<i> credentials=creds))
</I>&gt;<i> chan  = conn.channel()
</I>&gt;<i>
</I>&gt;<i> while True:
</I>&gt;<i>     chan.basic_publish(exchange='simple_exchange', 
</I>&gt;<i> routing_key='simple_queue', body='', 
</I>&gt;<i> properties=pika.BasicProperties(delivery_mode=2))
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Consumer:
</I>&gt;<i>
</I>&gt;<i>  #!/usr/bin/python
</I>&gt;<i>
</I>&gt;<i> import pika
</I>&gt;<i>
</I>&gt;<i> def callback(chan, method, properties, body):
</I>&gt;<i>     chan.basic_ack(delivery_tag=method.delivery_tag, multiple=False)
</I>&gt;<i>
</I>&gt;<i> creds = pika.PlainCredentials('guest','guest')
</I>&gt;<i> conn  = 
</I>&gt;<i> pika.BlockingConnection(pika.ConnectionParameters(host='10.10.1.123', 
</I>&gt;<i> credentials=creds))
</I>&gt;<i> chan  = conn.channel()
</I>&gt;<i>
</I>&gt;<i> chan.basic_consume(callback, queue='simple_queue', no_ack=False)
</I>&gt;<i> chan.basic_qos(prefetch_count=1000)
</I>&gt;<i> chan.start_consuming()
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I spawn multiple processes for the producers and multiple for the consumer 
</I>&gt;<i> (so there is no python interpreter locking issues since each runs in its 
</I>&gt;<i> own interpreter instance).  I'm using an an Amazon *c1.xlarge *(8 virtual 
</I>&gt;<i> cores and &quot;high&quot; IO) Ubuntu 12.04 LTS instance with RabbitMQ version 
</I>&gt;<i> 3.0.4-1 and an Amazon ephemeral disk (in production we would use an EBS 
</I>&gt;<i> volume instead).  The queue is marked *Durable* and my messages all use *
</I>&gt;<i> delivery_mode* 2 (persist).  
</I>&gt;<i>
</I>&gt;<i> Below are the performance numbers.  For each test I use 2 publishers 
</I>&gt;<i> processes and 6 consumer processes (where 3 different machines host 2 
</I>&gt;<i> consumers each).  The producers and consumers are all on *separate*machines from the rabbit node.  Throughput measurements were done using the 
</I>&gt;<i> RabbitMQ management UI and linux utility top.  Python was compiled to pyc 
</I>&gt;<i> files before running.
</I>&gt;<i>
</I>&gt;<i> *no_ack = True:*  
</I>&gt;<i>     rate = 24,000/s 
</I>&gt;<i>     single consumer CPU   =  65% 
</I>&gt;<i>     single publisher CPU  =  80% (flow control enabled and being enforced)
</I>&gt;<i>     (beam.smp) rabbit CPU = 400% (of 800%, 8 cores) -&gt; 0.0%wa 11.5%sy
</I>&gt;<i>
</I>&gt;<i> *no_ack = False (manual acks per message):*
</I>&gt;<i>     rate =  5,500/s
</I>&gt;<i>     single consumer CPU   =  20%
</I>&gt;<i>     single publisher CPU  =  20% (flow control enabled and being enforced)
</I>&gt;<i>     (beam.smp) rabbit CPU = 300% (of 800%, 8 cores) -&gt; 4.5%wa 10.0%sy
</I>&gt;<i>     
</I>&gt;<i> The most notable difference besides the throughput are the I/O waits when 
</I>&gt;<i> ACKs are enabled (4.5% vs 0.0%).  This leads me to believe that the rabbit 
</I>&gt;<i> node is being bottlenecked by performing I/O operations for ACK 
</I>&gt;<i> bookkeeping.  The I/O doesn't appear to be a problem for persisting the 
</I>&gt;<i> published messages since I'm *guessing* that rabbit is buffering those 
</I>&gt;<i> and syncing them to disk in batches.  Does this mean the acknowledgements 
</I>&gt;<i> are not also being buffered before synced with disk?  Can I configure the 
</I>&gt;<i> rabbit node to change this behavior to help speed up the acknowledgements? 
</I>&gt;<i>   I'm not using transactions in the example code above, so I don't need any 
</I>&gt;<i> strict guarantees that ACKs were written to disk before returning.
</I>&gt;<i>
</I>&gt;<i> Thanks,
</I>&gt;<i> Karl
</I>&gt;<i>
</I>&gt;<i> P.S. I wrote the same sample consumer code in Ruby to see if there was a 
</I>&gt;<i> difference (in case there was a Python issue), but the numbers were about 
</I>&gt;<i> the same.
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130606/72b62762/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130606/72b62762/attachment.htm</A>&gt;
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027738.html">[rabbitmq-discuss] RabbitMQ read performance does not grow when we add more subscribers?
</A></li>
	<LI>Next message: <A HREF="027739.html">[rabbitmq-discuss] Durability and consumer acknowledgement extremely slow
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27735">[ date ]</a>
              <a href="thread.html#27735">[ thread ]</a>
              <a href="subject.html#27735">[ subject ]</a>
              <a href="author.html#27735">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
