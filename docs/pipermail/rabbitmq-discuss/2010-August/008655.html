<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Turning consumers on/off in Erlang client
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Turning%20consumers%20on/off%20in%20Erlang%20client&In-Reply-To=%3C482972BD-382A-4C8E-AC1C-28ED89EC4983%40jbrisbin.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008652.html">
   <LINK REL="Next"  HREF="008656.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Turning consumers on/off in Erlang client</H1>
    <B>Jon Brisbin</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Turning%20consumers%20on/off%20in%20Erlang%20client&In-Reply-To=%3C482972BD-382A-4C8E-AC1C-28ED89EC4983%40jbrisbin.com%3E"
       TITLE="[rabbitmq-discuss] Turning consumers on/off in Erlang client">jon at jbrisbin.com
       </A><BR>
    <I>Mon Aug 30 19:08:52 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="008652.html">[rabbitmq-discuss] Turning consumers on/off in Erlang client
</A></li>
        <LI>Next message: <A HREF="008656.html">[rabbitmq-discuss] Turning consumers on/off in Erlang client
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8655">[ date ]</a>
              <a href="thread.html#8655">[ thread ]</a>
              <a href="subject.html#8655">[ subject ]</a>
              <a href="author.html#8655">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On Aug 30, 2010, at 12:43 PM, Matthew Sackman wrote:

&gt;<i> Hi Jon,
</I>&gt;<i> 
</I>&gt;<i> On Mon, Aug 30, 2010 at 08:28:33AM -0500, Jon Brisbin wrote:
</I>&gt;&gt;<i> In my webhooks plugin, I'm trying to add some basic support for scheduling requests to go out at a particular time. Rather than try to implement some kind of sleep() call that waits until the next configured send window (which is getting a little complicated to manage) I'd like to simply cancel the consumer whenever the time is after a send window and start it back up whenever the window opens. I can figure out whether I'm in a send window easy enough but when I try to turn the consumer on and off (by asynchronously doing basic.cancel and basic.consume) it will give me an error something along the lines of (my logs have rolled past this error long ago, sorry for not having it verbatim) &quot;unexpected delivery and no default consumer&quot;. I think this is coming from the erlang client, not the broker. 
</I>&gt;<i> 
</I>&gt;<i> Hmm, that error was meant to catch the case where you do a basic.cancel,
</I>&gt;<i> but you have outstanding unack'd messages and then you do
</I>&gt;<i> basic.redeliver - the messages get resend but the client has since lost
</I>&gt;<i> knowledge about that ctag, hence the error.
</I>
I probably do have unack'd messages waiting because I'm trying to limit the number of messages coming through. But I wasn't doing a redeliver, though...

&gt;<i> 
</I>&gt;<i> If you're doing a basic.cancel with nowait = true then I can certainly
</I>&gt;<i> believe this would happen then too. But why are you doing that?
</I>&gt;<i> 
</I>&gt;&gt;<i> Is there a way to &quot;nicely&quot; manage the consumer so that it stops reasonably (not by simply interrupting whatever it's currently doing)? A kind of &quot;cancel this consumer after the next message delivery&quot;? Or should I be doing this in a different way?
</I>&gt;<i> 
</I>&gt;<i> Yes - any of:
</I>&gt;<i> 1. don't use the nowait version of basic.cancel
</I>&gt;<i> 2. set qos prefetch_count to 1 and never cancel unless you have an
</I>&gt;<i> unacknowledged message
</I>&gt;<i> 3. use amqp_channel:register_default_consumer to set a consumer which
</I>&gt;<i> will be invoked if the ctag isn't recognised.
</I>&gt;<i> 
</I>&gt;<i> Matthew
</I>

Hmmm. I was using the defaults:

amqp_channel.call(Channel, #'basic.cancel'{ consumer_tag=Tag }),

I probably want to do #3 as well, no matter what. I don't really *care* if a message sneaks through after a window is closed. I don't have to be that accurate. I just need it to stop any new messages from being processed until I start the consumer again when another send window has opened. 


Thanks!

J. Brisbin
<A HREF="http://jbrisbin.com/">http://jbrisbin.com/</A>






-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100830/176844df/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100830/176844df/attachment.htm</A>&gt;
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008652.html">[rabbitmq-discuss] Turning consumers on/off in Erlang client
</A></li>
	<LI>Next message: <A HREF="008656.html">[rabbitmq-discuss] Turning consumers on/off in Erlang client
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8655">[ date ]</a>
              <a href="thread.html#8655">[ thread ]</a>
              <a href="subject.html#8655">[ subject ]</a>
              <a href="author.html#8655">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
