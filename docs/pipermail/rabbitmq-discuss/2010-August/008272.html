<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Exactly Once Delivery
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Exactly%20Once%20Delivery&In-Reply-To=%3CAANLkTi%3DOzrRYT1Jf9AM37KNKf0WWDTWDdm5Aew0oJhjf%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008271.html">
   <LINK REL="Next"  HREF="008273.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Exactly Once Delivery</H1>
    <B>John Apps</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Exactly%20Once%20Delivery&In-Reply-To=%3CAANLkTi%3DOzrRYT1Jf9AM37KNKf0WWDTWDdm5Aew0oJhjf%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] Exactly Once Delivery">johndapps at gmail.com
       </A><BR>
    <I>Thu Aug  5 14:00:11 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="008271.html">[rabbitmq-discuss] Exactly Once Delivery
</A></li>
        <LI>Next message: <A HREF="008273.html">[rabbitmq-discuss] Exactly Once Delivery
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8272">[ date ]</a>
              <a href="thread.html#8272">[ thread ]</a>
              <a href="subject.html#8272">[ subject ]</a>
              <a href="author.html#8272">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Matthew,
  an excellent response and thank you for it! Yes, difficult it is!

It raises a somewhat philosophical discussion around where the onus is
placed in terms of guaranteeing such things as 'guaranteed once', i.e., on
the client side or on the server side? The JMS standard offers guaranteed
once, whereby the onus is on the server (JMS implementation) and not on the
client.

What I am trying to say is that, in my opinion, client programs should be as
'simple' as possible with the servers doing all the hard work. This is what
the JMS standard forces on implementors and, perhaps to a lesser extent
today, do does AMQP.

Note: the word 'server' is horribly overloaded these days. It is used here
to indicate the software with which clients, producers and consumers,
communicate.

Oh well, off to librabbitMQ and some example programs written in COBOL...

Cheers, John
On Thu, Aug 5, 2010 at 13:22, Matthew Sackman &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">matthew at rabbitmq.com</A>&gt; wrote:

&gt;<i> Hi Mike,
</I>&gt;<i>
</I>&gt;<i> On Tue, Aug 03, 2010 at 04:43:56AM -0400, Mike Petrusis wrote:
</I>&gt;<i> &gt; In reviewing the mailing list archives, I see various threads which state
</I>&gt;<i> that ensuring &quot;exactly once&quot; delivery requires deduplication by the
</I>&gt;<i> consumer.  For example the following:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &quot;Exactly-once requires coordination between consumers, or idempotency,
</I>&gt;<i> &gt; even when there is just a single queue. The consumer, broker or network
</I>&gt;<i> &gt; may die during the transmission of the ack for a message, thus causing
</I>&gt;<i> &gt; retransmission of the message (which the consumer has already seen and
</I>&gt;<i> &gt; processed) at a later point.&quot;
</I>&gt;<i> <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/2009-July/004237.html">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/2009-July/004237.html</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; In the case of competing consumers which pull messages from the same
</I>&gt;<i> queue, this will require some sort of shared state between consumers to
</I>&gt;<i> de-duplicate messages (assuming the consumers are not idempotent).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Our application is using RabbitMQ to distribute tasks across multiple
</I>&gt;<i> workers residing on different servers, this adds to the cost of sharing
</I>&gt;<i> state between the workers.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Another message in the email archive mentions that &quot;You can guarantee
</I>&gt;<i> exactly-once delivery if you use transactions, durable queues and exchanges,
</I>&gt;<i> and persistent messages, but only as long as any failing node eventually
</I>&gt;<i> recovers.&quot;
</I>&gt;<i>
</I>&gt;<i> All the above is sort of wrong. You can never *guarantee* exactly once
</I>&gt;<i> (there's always some argument about whether receiving message duplicates
</I>&gt;<i> but relying on idempotency is achieving exactly once. I don't feel it
</I>&gt;<i> does, and this should become clearer as to why further on...)
</I>&gt;<i>
</I>&gt;<i> The problem is publishers. If the server on which RabbitMQ is running
</I>&gt;<i> crashes, after commiting a transaction containing publishes, it's
</I>&gt;<i> possible the commit-ok message may get lost. Thus the publishers still
</I>&gt;<i> think they need to republish, so wait until the broker comes back up and
</I>&gt;<i> then republishes. This can happen an infinite number of times: the
</I>&gt;<i> publishers connect, start a transaction, publish messages, commit the
</I>&gt;<i> transaction and then the commit-ok gets lost and so the publishers
</I>&gt;<i> repeat the process.
</I>&gt;<i>
</I>&gt;<i> As a result, on the clients, you need to detect duplicates. Now this is
</I>&gt;<i> really a barrier to making all operations idempotent. The problem is
</I>&gt;<i> that you never know how many copies of a message there will be. Thus you
</I>&gt;<i> never know when it's safe to remove messages from your dedup cache. Now
</I>&gt;<i> things like redis apparently have the means to delete entries after an
</I>&gt;<i> amount of time, which would at least allow you to avoid the database
</I>&gt;<i> eating up all the RAM in the universe, but there's still the possibility
</I>&gt;<i> that after the entry's been deleted, another duplicate will come along
</I>&gt;<i> which you now won't detect as a duplicate.
</I>&gt;<i>
</I>&gt;<i> This isn't just a problem with RabbitMQ - in any messaging system, if
</I>&gt;<i> any message can be lost, you can not achieve exactly once semantics. The
</I>&gt;<i> best you can hope for is a probability of a large number of 9s that you
</I>&gt;<i> will be able to detect all the duplicates. But that's the best you can
</I>&gt;<i> achieve.
</I>&gt;<i>
</I>&gt;<i> Scaling horizontally is thus more tricky because, as you say, you may
</I>&gt;<i> now have multiple consumers which each receive one copy of a message.
</I>&gt;<i> Thus the dedup database would have to be distributed. With high message
</I>&gt;<i> rates, this might well become prohibitive because of the amount of
</I>&gt;<i> network traffic due to transactions between the consumers.
</I>&gt;<i>
</I>&gt;<i> &gt; What's the recommended way to deal with the potential of duplicate
</I>&gt;<i> messages?
</I>&gt;<i>
</I>&gt;<i> Currently, there is no &quot;recommended&quot; way. If you have a single consumer,
</I>&gt;<i> it's quite easy - something like tokyocabinet should be more than
</I>&gt;<i> sufficiently performant. For multiple consumers, you're currently going
</I>&gt;<i> to have to look at some sort of distributed database.
</I>&gt;<i>
</I>&gt;<i> &gt; Is this a rare enough edge case that most people just ignore it?
</I>&gt;<i>
</I>&gt;<i> No idea. But one way of making your life easier is for the producer to
</I>&gt;<i> send slightly different messages on every republish (they would still
</I>&gt;<i> obviously need to have the same msg id). That way, if you detect a msg
</I>&gt;<i> with &quot;republish count&quot; == 0, then you know it's the first copy, so you
</I>&gt;<i> can insert async into your shared database and then act on the message.
</I>&gt;<i> You only need to do a query on the database whenever you receive a msg
</I>&gt;<i> with &quot;republish count&quot; &gt; 0 - thus you can tune your database for
</I>&gt;<i> inserts and hopefully save some work - the common case will then be the
</I>&gt;<i> first case, and lookups will be exceedingly rare.
</I>&gt;<i>
</I>&gt;<i> The question then is: if you've received a msg, republish count &gt; 0 but
</I>&gt;<i> there are no entries in the database, what do you do? It shouldn't have
</I>&gt;<i> overtaken the first publish (though if consumers disconnected without
</I>&gt;<i> acking, or requeued messages, it could have), but you need to cause some
</I>&gt;<i> sort of synchronise operation between all the consumers to ensure none
</I>&gt;<i> are in the process of adding to the database - it all gets a bit hairy
</I>&gt;<i> at this point.
</I>&gt;<i>
</I>&gt;<i> Thus if your message rate is low, you're much safer doing the insert and
</I>&gt;<i> select on every message. If that's too expensive, you're going to have
</I>&gt;<i> to think very hard indeed about how to avoid races between different
</I>&gt;<i> consumers thinking they're both/all responsible for acting on the same
</I>&gt;<i> message.
</I>&gt;<i>
</I>&gt;<i> This stuff isn't easy.
</I>&gt;<i>
</I>&gt;<i> Matthew
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>


-- 
---
John Apps
(49) 171 869 1813
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100805/7eca06e8/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100805/7eca06e8/attachment.htm</A>&gt;
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008271.html">[rabbitmq-discuss] Exactly Once Delivery
</A></li>
	<LI>Next message: <A HREF="008273.html">[rabbitmq-discuss] Exactly Once Delivery
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8272">[ date ]</a>
              <a href="thread.html#8272">[ thread ]</a>
              <a href="subject.html#8272">[ subject ]</a>
              <a href="author.html#8272">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
