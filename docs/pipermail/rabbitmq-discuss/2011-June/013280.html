<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] sequence of consumation (was: Message	Aggregating Queue)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20sequence%20of%20consumation%20%28was%3A%20Message%0A%09Aggregating%20Queue%29&In-Reply-To=%3C9C37154E143FE14CBA656B2D2232745F088AE856B8F8%40popeye.gebaschtel.bnet%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013277.html">
   <LINK REL="Next"  HREF="013281.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] sequence of consumation (was: Message	Aggregating Queue)</H1>
    <B>Josh Geisser</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20sequence%20of%20consumation%20%28was%3A%20Message%0A%09Aggregating%20Queue%29&In-Reply-To=%3C9C37154E143FE14CBA656B2D2232745F088AE856B8F8%40popeye.gebaschtel.bnet%3E"
       TITLE="[rabbitmq-discuss] sequence of consumation (was: Message	Aggregating Queue)">josh at gebaschtel.ch
       </A><BR>
    <I>Wed Jun 15 22:36:43 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="013277.html">[rabbitmq-discuss] 2.5.0 stomp ssl Windows 2008R2
</A></li>
        <LI>Next message: <A HREF="013281.html">[rabbitmq-discuss] use rabbit.config file to start multiple nodes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13280">[ date ]</a>
              <a href="thread.html#13280">[ thread ]</a>
              <a href="subject.html#13280">[ subject ]</a>
              <a href="author.html#13280">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Sorry coming back to this old &quot;information-aggregation&quot; topic, still hanging on the stack-idea of message consuming. 

As far as my horizon goes, queuing ('keeping') of messages happens in two cases:

1) no consumer at queue arrival: message (persistent) is stored on a queue which is picked up later in a e.g. eod-job, or when the consumer becomes available. Most important thing is that it will eventually delivered.

2) Consumer present at queue arrival: en-queuing will only happen in this case when the consumer is busy, -&gt; a client which you want to buffer for him -&gt; en-queue 


I understand that the mechanism of en-queuing and de-queuing is done anyway, but in an ideal world(2) you have &lt;=1 msg in your queue.

This is not always possible, depending on various factors, so the great thing of MQ is queuing.


At the very top of my head, I'd think of the following scenarios of how information arrive to me in which ways:

A) Girlfriend likes to have a call-back, left a voice box on queue 'home', 
   Before this, queue has items like &quot;feed dog&quot;, &quot;bring out the trash&quot;, etc

B) Some friends are chatting about the latest news, into queue 'gossip'

C) Football plays are going on, sending me every goal via queue 'sport'.
   

Scenario A) is late-consuming, I'll read queue 'home' when I arrive at home. Sequential retrieval will make sure the dog survives, but not specified in this case

Scenario B) is 'trying to keep up realtime'. Can't look at the chatroom all the time, but when i can, I can read the messages I missed. As long as I'm online, I stay tuned. Sequential retrieval is required for coherency.

Scenario C) is where a stack would be better than a queue: After a while you look at you mobile inbox: 
...
21:32 subje: Madr-Berl  
21:49 subje: Madr-Berl 
21:57 subje: Roma-Live 
22:01 subje: Madr-Berl 
22:10 subje: Roma-Live 

The only two messages you will open and read the body (score) are the two latest ones. That tells you who has the lead right now(!). 
If you're curious you still can consume the earlier messages for historical purposes, or simply drop them. 

Also, while reading the older messages, the next message you consume might also just update you again on Roma-Liverpool.

This would certainly not solve aggregation, but would give the consumer a chance to stay as updated as possible. 

Just some thoughts &amp; Cheers
Josh



-----Urspr&#252;ngliche Nachricht-----
Von: <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">alexis.richardson at gmail.com</A> [mailto:<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">alexis.richardson at gmail.com</A>] Im Auftrag von Alexis Richardson
Gesendet: Dienstag, 3. Mai 2011 07:34
An: Josh Geisser
Cc: <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
Betreff: Re: [rabbitmq-discuss] WG: Message Aggregating Queue

I'd be interested to see what semantics for &quot;update&quot; people on this
list would propose, that would make sense for queues.  Include the
case where messages are routed to multiple queues which have different
sets of consumers.

alexis


On Tue, May 3, 2011 at 6:26 AM, Josh Geisser &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">josh at gebaschtel.ch</A>&gt; wrote:
&gt;<i> Let me quickly try to understand that:
</I>&gt;<i>
</I>&gt;<i> You want to get the most accurate instrument-data. As long as you're not overloaded, the sequential message processing is fine (queue size &lt;=1). The Problem occurs if you can't keep up with the producers (&gt;1). Then you have the case of consuming <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">UBS at 12.3</A> although the very latest information (12.8) is already in the queue, but not yet processed, right?
</I>&gt;<i>
</I>&gt;<i> A na&#239;ve way to overcome that would be a Stack/FILO instead of a queue, not? Instead of consuming the next message, you'd consume the most recent one.
</I>&gt;<i> This way you get 12.8 before 12.3.
</I>&gt;<i>
</I>&gt;<i> Of coarse this imposes that you have to take care of which tick is which (they are time stamped, not?) when you working down the stack.
</I>&gt;<i>
</I>&gt;<i> The further problem of starving messages could be reduced if the broker could kind of match and remove out-dated messages on a same pattern.
</I>&gt;<i>
</I>&gt;<i> afaik not possible with rabbit :(
</I>&gt;<i>
</I>&gt;<i> My 2 cents :)
</I>&gt;<i>
</I>&gt;<i> Cheers
</I>&gt;<i> Josh
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -----Urspr&#252;ngliche Nachricht-----
</I>&gt;<i> Von: <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss-bounces at lists.rabbitmq.com</A> [mailto:<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss-bounces at lists.rabbitmq.com</A>] Im Auftrag von Jason Zaugg
</I>&gt;<i> Gesendet: Donnerstag, 28. April 2011 16:18
</I>&gt;<i> An: Irmo Manie
</I>&gt;<i> Cc: Alexis Richardson; <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> Betreff: Re: [rabbitmq-discuss] Message Aggregating Queue
</I>&gt;<i>
</I>&gt;<i> On Thu, Apr 28, 2011 at 3:44 PM, Irmo Manie &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">irmo.manie at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> The problem is actually a bit more tricky than this. When it comes to
</I>&gt;&gt;<i> market data you would route all the data to a client specific
</I>&gt;&gt;<i> exclusive queue based on a subscription because every client has its
</I>&gt;&gt;<i> own authorization, authentication and quality of service. (real-time,
</I>&gt;&gt;<i> delayed, only eu stocks, tick by tick, tick only every minute, etc,
</I>&gt;&gt;<i> etc).
</I>&gt;<i>
</I>&gt;<i> But each client specific queue could implement the 'obsolete tick'
</I>&gt;<i> discarding in the broker, right?
</I>&gt;<i>
</I>&gt;&gt;<i> So the easy way is still just to have the consumer do the filtering
</I>&gt;&gt;<i> itself by storing all messages in a key value store and empty this
</I>&gt;&gt;<i> based on a ordered queue of ids to process.
</I>&gt;&gt;<i> That way the consumer can 'consume' as fast as it can put the values
</I>&gt;&gt;<i> in the K/V store which probably always is fast enough :-)
</I>&gt;<i>
</I>&gt;<i> I would feel more comfortable knowing that the number of messages in
</I>&gt;<i> the broker is naturally bounded, even if the consumer misbehaves. It
</I>&gt;<i> would also be nice to have the possibility to have a pool of consumers
</I>&gt;<i> processing from a single queue, be able to restart the consumers
</I>&gt;<i> without losing unprocessed messages etc. Anyway, we should discuss
</I>&gt;<i> this some more internally; as always these sort of cats are amenable
</I>&gt;<i> to being skinned in multitude of ways :)
</I>&gt;<i>
</I>&gt;&gt;<i> Only if you can process the data (ticks) independently from each other
</I>&gt;&gt;<i> it makes sense to have this filtering on the broker because then it
</I>&gt;&gt;<i> would be useful for a cluster of consumers apps processing the data.
</I>&gt;&gt;<i> But 9 out of 10 times you need the ticks of more than one instrument
</I>&gt;&gt;<i> to do your business logic so you'd already keep a cache with the last
</I>&gt;&gt;<i> values anyway.
</I>&gt;<i>
</I>&gt;&gt;<i> Still there could be other usecases of course where having this
</I>&gt;&gt;<i> functionality at the broker can be really useful and powerful.
</I>&gt;<i>
</I>&gt;&gt;<i> /2cents
</I>&gt;<i>
</I>&gt;<i> And well worth both of them :)
</I>&gt;<i>
</I>&gt;<i> -jason
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -----Urspr&#252;ngliche Nachricht-----
</I>&gt;<i>
</I>&gt;<i> Among other things, we're using RabbitMQ to distribute market data ticks. The interesting characteristic about this stream of messages is that a new tick for a obsoletes previous, unprocessed, ticks for the same stock.
</I>&gt;<i>
</I>&gt;<i> After a little brainstorming last night with Alvaro Videla, I'm curious to discuss how this could be modeled with an extension to RabbitMQ.
</I>&gt;<i>
</I>&gt;<i> It seems a similar problem to the Queue Based TTL [1], however TTL isn't quite right for this case, as the validity period of a tick depends on the liquidity of the stock. We really just want the
</I>&gt;<i> *latest* tick.
</I>&gt;<i>
</I>&gt;<i> Assume a message stream:
</I>&gt;<i>
</I>&gt;<i> 1. Tick { stock = &quot;UBS&quot;, bid = 12.3 } &#160; RK=&quot;tick.UBS&quot;
</I>&gt;<i> 2. Tick { stock = &quot;ABB&quot;, bid = 15.3 } &#160;RK=&quot;tick.ABB&quot;
</I>&gt;<i> 3. Tick { stock = &quot;UBS&quot;, bid = 12.28 } RK=&quot;tick.UBS&quot;
</I>&gt;<i>
</I>&gt;<i> These are sent to a fanout exchange, and on to a queue(s) for a Consumer(s). Assume that consumer is slow, and the messages are not processed immediately. Rather than just en queuing message #3, I would like to insert it in place of message #1.
</I>&gt;<i>
</I>&gt;<i> This has the nice property that the broker won't overrun with messages if the consumer can't keep up; and that the consumer doesn't do work that is obsolete.
</I>&gt;<i>
</I>&gt;<i> What would be the suitable way to identify that #1 and #3 refer to the same stock? Is the routing key of message #1 retained after it has been en queued?
</I>&gt;<i>
</I>&gt;<i> An generalization of this would be to provide a function that takes the old and new message and combines them into an aggregated message.
</I>&gt;<i> For example, we might want to track the latest, min and max:
</I>&gt;<i>
</I>&gt;<i> &#160;AggregatedTick { stock = &quot;UBS&quot;, latestBid = 12.28 minBid=12.28 maxBid=12.30 }
</I>&gt;<i>
</I>&gt;<i> So, does this sound sensible and possible?
</I>&gt;<i>
</I>&gt;<i> -jason
</I>&gt;<i>
</I>&gt;<i> [1] <A HREF="http://www.rabbitmq.com/extensions.html#queue-ttl">http://www.rabbitmq.com/extensions.html#queue-ttl</A>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I></PRE>
































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013277.html">[rabbitmq-discuss] 2.5.0 stomp ssl Windows 2008R2
</A></li>
	<LI>Next message: <A HREF="013281.html">[rabbitmq-discuss] use rabbit.config file to start multiple nodes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13280">[ date ]</a>
              <a href="thread.html#13280">[ thread ]</a>
              <a href="subject.html#13280">[ subject ]</a>
              <a href="author.html#13280">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
