<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] FW: Multiple consumers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20FW%3A%20Multiple%20consumers&In-Reply-To=269388e30708031136r7a32af53yee5711c684935c89%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000100.html">
   <LINK REL="Next"  HREF="000110.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] FW: Multiple consumers</H1>
    <B>Matthias Radestock</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20FW%3A%20Multiple%20consumers&In-Reply-To=269388e30708031136r7a32af53yee5711c684935c89%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] FW: Multiple consumers">matthias at lshift.net
       </A><BR>
    <I>Mon Aug  6 10:08:12 BST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000100.html">[rabbitmq-discuss] FW: Multiple consumers
</A></li>
        <LI>Next message: <A HREF="000110.html">[rabbitmq-discuss] FW: Multiple consumers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#101">[ date ]</a>
              <a href="thread.html#101">[ thread ]</a>
              <a href="subject.html#101">[ subject ]</a>
              <a href="author.html#101">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ben,

&quot;Ben Hood&quot; &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">0x6e6562 at gmail.com</A>&gt; writes:

&gt;<i> Here's the patch for the 1.1.0 release.
</I>
Some comments:

1)
I am not convinced parameterised modules are the way to go. You can
tell that something isn't quite right by the large number of places
amqp_client has different branches for the network and direct case.

Related to this, your current startup/shutdown sequence is

    AMQPClient = amqp_client:new(amqp_direct_driver),
    {ok, Connection} = AMQPClient:start(User, Password),
    Channel = AMQPClient:open_channel(Connection, ChannelNumber, &quot;&quot;),
    Ticket = AMQPClient:access_request(Channel, Realm),
    ...
    AMQPClient:stop(Channel),
    AMQPClient:stop(Connection).

when I think it should be

    {ok, Connection} = amqp_network_client:start(User, Password),
    Channel = amqp_connection:open_channel(Connection, ChannelNumber, &quot;&quot;),
    Ticket = amqp_channel:access_request(Channel, Realm)
    ...
    amqp_channel:close(Channel),
    amqp_connection:close(Connection).

The module parameterisation and general client module structure is
driven largely by the need to support both the direct and network
client. I reckon we are trying to bite off too much in one go
here, and suggest concentrating on the network client first.

2)
I wonder whether it would make sense to get rid of most of the channel
functions and instead get the user to construct requests
directly. E.g. instead of

    #'queue.declare_ok'{queue = Q1,
                        message_count = MessageCount,
                        consumer_count = ConsumerCount}
                        = AMQPClient:queue_declare(Channel, Ticket, Q)

you'd write

    #'queue.declare_ok'{queue = Q1,
                        message_count = MessageCount,
                        consumer_count = ConsumerCount}
                        = amqp_channel:rpc(
                            #'queue.declare'{ticket = Ticket,
                                             queue = binary(Q)}),

This is more symmetric and takes advantage of Erlang's light-weight
record manipulation syntax. It does however require reasonable
defaults for all the record fields, which isn't the case right now. As
an alternative you could define a bunch of record constants that have
their fields set to reasonable default values and then use record
update to construct the record instances you need.

3)
Why does amqp_client use an ets table instead of a record to record the
username, password etc?

4)
The method reading in rabbit_channel should be refactored so that you
can call it from amqp_receive, rather than duplicating code.

rabbit_reader should be refactored so that amqp_network_driver doesn't
have to duplicate so much code.


I am pleased by how little code there is and how little you had to
change the server modules to support the direct case. That will help
when carrying this code base forward when we tackle AMQP 0-10.


Matthias


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000100.html">[rabbitmq-discuss] FW: Multiple consumers
</A></li>
	<LI>Next message: <A HREF="000110.html">[rabbitmq-discuss] FW: Multiple consumers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#101">[ date ]</a>
              <a href="thread.html#101">[ thread ]</a>
              <a href="subject.html#101">[ subject ]</a>
              <a href="author.html#101">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
