<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Clustering
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Clustering&In-Reply-To=269388e30711010022s42e42ed6u55fc59df9d8e8e9f%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000281.html">
   <LINK REL="Next"  HREF="000287.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Clustering</H1>
    <B>Matthias Radestock</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Clustering&In-Reply-To=269388e30711010022s42e42ed6u55fc59df9d8e8e9f%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Clustering">matthias at lshift.net
       </A><BR>
    <I>Sat Nov  3 10:33:13 GMT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000281.html">[rabbitmq-discuss] Clustering
</A></li>
        <LI>Next message: <A HREF="000287.html">[rabbitmq-discuss] Clustering
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#284">[ date ]</a>
              <a href="thread.html#284">[ thread ]</a>
              <a href="subject.html#284">[ subject ]</a>
              <a href="author.html#284">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Dmitriy,

Ben Hood wrote:
&gt;<i> Dmitriy,
</I>&gt;<i> 
</I>&gt;&gt;<i> I set up a cluster of 2 nodes - <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbit at node1</A> and <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbit at node2.</A>
</I>&gt;&gt;<i> Several producers will connect to either node and send a series of
</I>&gt;&gt;<i> messages with topic hierarchy as routing key (for example,
</I>&gt;&gt;<i> &quot;a.b.c.d.e.f&quot;). Consumers will also connect to either node and will
</I>&gt;&gt;<i> register to receive some subset of what is being sent - in other
</I>&gt;&gt;<i> words, for example, some of them will request &quot;a.#&quot; while others
</I>&gt;&gt;<i> might want to get only &quot;#.e.f&quot;. My goal is to make it happen if at
</I>&gt;&gt;<i> least one of the nodes in the cluster is up and running. Both
</I>&gt;&gt;<i> producers and consumers will know about existence of both cluster
</I>&gt;&gt;<i> nodes, but they need to be able to randomly connect to either.
</I>
&gt;<i> As far as I know, message queues are not yet fully clustered in
</I>&gt;<i> rabbitmq, meaning that you cannot yet transparently failover or
</I>&gt;<i> migrate a queue to a different node in the cluster. These queues are
</I>&gt;<i> visible from any node in the cluster however.
</I>
Ben is right about the (lack of) queue clustering. Whether or not that 
matters depends on what guarantees you expect on message delivery: Can 
you afford to lose messages? Is it ok for a message to be delivered to a 
consumer more than once?

You can guarantee exactly-once delivery if you use transactions, durable 
queues and exchanges, and persistent messages, but only as long as any 
failing node eventually recovers.

If you can afford to lose the odd message then the simplest setup is to 
just have consumers detect when connections goes down, connect to the 
other node and recreate their queues. Similarly, producers just 
re-connect to the second node on failure of the first node, and start 
sending messages to the same exchange as before.

If message loss is bad but duplication is ok then you can could set up 
two parallel routing topologies with producers sending messages to both 
nodes and each consumer consuming from two queues - one on each node.

There are various other options; which one is best really depends on the 
specific requirements of your application.


All this is going to improve significantly in AMQP 0-10, where there is 
a notion of a &quot;session&quot; whose lifecycle is independent from that of the 
transport connection. Sessions can transparently reconnect to other 
nodes and have built-in support for exactly-once delivery. We'd still 
need to add queue clustering to RabbitMQ, but that's on our roadmap 
already anyway.


Regards,

Matthias.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000281.html">[rabbitmq-discuss] Clustering
</A></li>
	<LI>Next message: <A HREF="000287.html">[rabbitmq-discuss] Clustering
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#284">[ date ]</a>
              <a href="thread.html#284">[ thread ]</a>
              <a href="subject.html#284">[ subject ]</a>
              <a href="author.html#284">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
