<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Multithreaded application,	separation of 	connections and channels
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Multithreaded%20application%2C%0A%09separation%20of%20%09connections%20and%20channels&In-Reply-To=4A49BFD5.40505%40lshift.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003934.html">
   <LINK REL="Next"  HREF="003913.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Multithreaded application,	separation of 	connections and channels</H1>
    <B>Matthias Karlsson</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Multithreaded%20application%2C%0A%09separation%20of%20%09connections%20and%20channels&In-Reply-To=4A49BFD5.40505%40lshift.net"
       TITLE="[rabbitmq-discuss] Multithreaded application,	separation of 	connections and channels">matthias at yacc.se
       </A><BR>
    <I>Tue Jun 30 12:27:47 BST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003934.html">[rabbitmq-discuss] Multithreaded application, separation of connections and channels
</A></li>
        <LI>Next message: <A HREF="003913.html">[rabbitmq-discuss] RabbitMQ/Spring integration - help required
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3941">[ date ]</a>
              <a href="thread.html#3941">[ thread ]</a>
              <a href="subject.html#3941">[ subject ]</a>
              <a href="author.html#3941">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Tony,

thanks for your input!

&gt;<i>
</I>&gt;<i> Unless you have a very high number of threads and/or separate VMs, your
</I>&gt;<i> option (1) seems easiest to work with. Suitably abstracted, it can always be
</I>&gt;<i> switched out for one of the others later.
</I>&gt;<i>
</I>
Implementation-wise, this seems to be the easier one to get right and
it'll most likely be the one I'll use when prototyping. There will be
many instances of the same application (so more VMs) though so I will
have to make some careful benchmarking I think.

&gt;<i> Many people have this need. It'd be great if you could share the design (or
</I>&gt;<i> even the implementation!) of what you come up with for this; our java
</I>&gt;<i> library is very much a thin layer atop the protocol, and could definitely
</I>&gt;<i> stand to grow some affordances for the developer.
</I>&gt;<i>
</I>&gt;<i> As a complete aside, since it's not directly relevant to getting something
</I>&gt;<i> working for solving the problem you have, we've been thinking a little bit
</I>&gt;<i> about how best to do reconnection/HA/etc in a language-neutral way. Our
</I>&gt;<i> current thinking is something along the lines of a small, standalone,
</I>&gt;<i> light-weight *client-side* AMQP proxy, accessible from any AMQP-speaking
</I>&gt;<i> language library. The proxy would deal with connection reestablishment and
</I>&gt;<i> message redelivery, making use of the &quot;fate-sharing&quot; notion used in the
</I>&gt;<i> design of TCP. The idea is that it'd be trustworthy because it'd be on the
</I>&gt;<i> same machine as the client itself. Such a proxy could also help with various
</I>&gt;<i> HA and sharding scenarios (by automating and abstracting-out communication
</I>&gt;<i> patterns like N-of-M and deduplication etc).
</I>&gt;<i>
</I>
When I get something up and running (I haven't planned the actual work
until late July however) I can definitely share any information I have
found (ideas, code etc.).

My planned implementation for the fail-safe is to basically take an
existing solution I wrote for when the application communicated over
pure TCP sockets. Basically, each socket (5-10) is associated with a
thread hidden behind a common &quot;output&quot;-interface. This thread is
responsible for delivering messages received, and to (re)establish the
connection when needed. Further more, if messages are recieved when in
disconnected state, messages are queued waiting for the socket to be
reestablished. When the number of queued messages reach a certain
threshold, they are flushed to local disk to avoid an ultimate
OutOfMemoryException (these messages are then of course read back when
the connection is up again).

In this regard, this seems to be along the same lines as your proxy,
though yours is more general and low-level. Have you given any thought
about how to handle messages received when not connected? With proper
callbacks to application code, a developer could himself decide how to
handle messages that couldn't be delivered due to communication
problems, e.g. discard, save to disk locally, queue in memory and so
on. That is, perhaps make the failhandling pluggable with perhaps at
least two obvious implementations available by default, one that
discards messages and one that queues in memory forever waiting for
reconnect.

// Matthias


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003934.html">[rabbitmq-discuss] Multithreaded application, separation of connections and channels
</A></li>
	<LI>Next message: <A HREF="003913.html">[rabbitmq-discuss] RabbitMQ/Spring integration - help required
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3941">[ date ]</a>
              <a href="thread.html#3941">[ thread ]</a>
              <a href="subject.html#3941">[ subject ]</a>
              <a href="author.html#3941">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
