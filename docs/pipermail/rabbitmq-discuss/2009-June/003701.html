<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Fwd:  rabbit MQ high-through put stock quotes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Fwd%3A%20%20rabbit%20MQ%20high-through%20put%20stock%20quotes&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003715.html">
   <LINK REL="Next"  HREF="003883.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Fwd:  rabbit MQ high-through put stock quotes</H1>
    <B>Chuck Remes</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Fwd%3A%20%20rabbit%20MQ%20high-through%20put%20stock%20quotes&In-Reply-To="
       TITLE="[rabbitmq-discuss] Fwd:  rabbit MQ high-through put stock quotes">cremes.devlist at mac.com
       </A><BR>
    <I>Fri Jun  5 15:09:14 BST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="003715.html">[rabbitmq-discuss] Clustering Question
</A></li>
        <LI>Next message: <A HREF="003883.html">[rabbitmq-discuss] Fwd: rabbit MQ high-through put stock quotes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3701">[ date ]</a>
              <a href="thread.html#3701">[ thread ]</a>
              <a href="subject.html#3701">[ subject ]</a>
              <a href="author.html#3701">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Oops, I meant to send this to the ML. Forwarding...

cr

Begin forwarded message:

&gt;<i> From: Chuck Remes &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">cremes.devlist at mac.com</A>&gt;
</I>&gt;<i> Date: June 4, 2009 4:16:17 PM CDT
</I>&gt;<i> To: smittycb10 &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">msmith1638 at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [rabbitmq-discuss] rabbit MQ high-through put stock  
</I>&gt;<i> quotes
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Jun 4, 2009, at 2:48 PM, smittycb10 wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is a follow up to my previous message with some more details  
</I>&gt;&gt;<i> about how I
</I>&gt;&gt;<i> envision using Rabbit MQ.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Currently I have a system where a server takes in all messages from  
</I>&gt;&gt;<i> our data
</I>&gt;&gt;<i> provider and then streams the messages via UDP to a consumer  
</I>&gt;&gt;<i> application.
</I>&gt;&gt;<i> This set up can handle the message load but is proving to be  
</I>&gt;&gt;<i> difficult and
</I>&gt;&gt;<i> costly to scale. One producer to one Consuming server which then  
</I>&gt;&gt;<i> filters
</I>&gt;&gt;<i> data to desktop clients.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My idea for a future system is to have the same server simply push  
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> messages to a rabbit MQ Broker or Brokers and then have all clients  
</I>&gt;&gt;<i> simply
</I>&gt;&gt;<i> listen to whatever queues they need to get there jobs done. I need  
</I>&gt;&gt;<i> to design
</I>&gt;&gt;<i> for 100,000 (one hundred thousand) messages to made available for  
</I>&gt;&gt;<i> consuming
</I>&gt;&gt;<i> per second. Most consumers will only consume a fraction of these  
</I>&gt;&gt;<i> messages,
</I>&gt;&gt;<i> although some of our server pieces may need to subscribe to the whole
</I>&gt;&gt;<i> universe of incoming messages. Messages can and will be batched on  
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> publishing side.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> So the use case would be, one publisher pushing messages to the  
</I>&gt;&gt;<i> &quot;Broker
</I>&gt;&gt;<i> Cloud&quot; many consumers some needing to listen to all messages others  
</I>&gt;&gt;<i> would
</I>&gt;&gt;<i> only be interested in a particular Stock symbol at a time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I will experiment with some fanout experiments next, any advice or  
</I>&gt;&gt;<i> direction
</I>&gt;&gt;<i> you have would be greatly appreciated. In a fanout pattern if say a  
</I>&gt;&gt;<i> quote
</I>&gt;&gt;<i> comes in for IBM how do I distribute only to people interested in  
</I>&gt;&gt;<i> IBM?
</I>&gt;<i>
</I>&gt;<i> Let me take a crack at this. Be forewarned that everything I write  
</I>&gt;<i> here might be wrong. :)
</I>&gt;<i>
</I>&gt;<i> We have 3 kinds of queues to choose from: direct, fanout and topic.
</I>&gt;<i>
</I>&gt;<i> In terms of performance, they behave in the order listed above from  
</I>&gt;<i> fastest to slowest.
</I>&gt;<i>
</I>&gt;<i> For direct exchanges, you bind your queue to it with a specific  
</I>&gt;<i> routing key. Any messages published to that exchange need to include  
</I>&gt;<i> a routing key. If the message's routing key *exactly* matches your  
</I>&gt;<i> binding's routing key, the message is delivered to your queue.
</I>&gt;<i>
</I>&gt;<i> For fanout exchanges, you bind a queue to it without any routing  
</I>&gt;<i> key. Any messages published to it are *unconditionally* delivered to  
</I>&gt;<i> the queue. The reason I didn't mark this as the fastest queue type  
</I>&gt;<i> is because you generally only pick it when you have lots of bound  
</I>&gt;<i> queues so the message needs to be copied to each. (Of course, this  
</I>&gt;<i> is implementation specific and could be very fast or slow; I don't  
</I>&gt;<i> know how Rabbit performs this operation.) If you only have one  
</I>&gt;<i> subscriber, this will be faster than the direct exchange because you  
</I>&gt;<i> skip the routing key comparison.
</I>&gt;<i>
</I>&gt;<i> For topic exchanges, you bind a queue to the exchange with a routing  
</I>&gt;<i> pattern. Any messages published with a key that matches your pattern  
</I>&gt;<i> are delivered to the queue.
</I>&gt;<i>
</I>&gt;<i> With that out of the way, I would suggest a fanout exchange per high- 
</I>&gt;<i> volume symbol. Any interested subscribers can bind a uniquely-named  
</I>&gt;<i> queue to that exchange and get all messages for IBM. Note I said you  
</I>&gt;<i> need a uniquely-named queue per subscriber. If you use a single  
</I>&gt;<i> queue for all subscribers, the subscribers will get messages in a  
</I>&gt;<i> round-robin fashion (usually). So N subscribers would only see an  
</I>&gt;<i> update every N messages which is probably not what you want.
</I>&gt;<i>
</I>&gt;<i> Alternately, you could use a direct exchange for the low-volume  
</I>&gt;<i> stocks. Interested subscribers could bind their (again) uniquely- 
</I>&gt;<i> named queue with a routing key matching the symbol (or some other  
</I>&gt;<i> identifier). Rabbit is smart enough that it will only deliver  
</I>&gt;<i> messages to queues where the keys match exactly. The reason I  
</I>&gt;<i> suggest this is due to potential performance concerns on the server  
</I>&gt;<i> side if it has to handle hundreds or thousands of unique exchanges.  
</I>&gt;<i> I don't know if Rabbit suffers from any performance degradation in  
</I>&gt;<i> this situation, so make sure to benchmark it.
</I>&gt;<i>
</I>&gt;<i> Additionally, you'll want to publish messages with &quot;nowait&quot; and  
</I>&gt;<i> &quot;noack&quot; and &quot;not persistent&quot; and make sure the queues are not  
</I>&gt;<i> &quot;durable.&quot; See the API docs for your chosen library to see how to  
</I>&gt;<i> set those flags. &quot;Nowait&quot; means the client should not wait for a  
</I>&gt;<i> response to the publish method. &quot;No ack&quot; means the message itself  
</I>&gt;<i> doesn't need to be acknowledged as received; the server will &quot;pre- 
</I>&gt;<i> ack&quot; each message pulled from the queue. And the &quot;not persistent&quot;  
</I>&gt;<i> setting interacts with the &quot;durability&quot; setting on the queue.  
</I>&gt;<i> Durable messages (inside durable queues) are stored on disk so that  
</I>&gt;<i> a crash and restart doesn't lose any messages. For transient  
</I>&gt;<i> messages like stock quotes, you don't want them persisted at this  
</I>&gt;<i> level.
</I>&gt;<i>
</I>&gt;<i> Someone else on the list will have to answer your questions about  
</I>&gt;<i> scaling up to 100k/sec. I think Erlang processes are still single- 
</I>&gt;<i> threaded so you probably need to run multiple instances to take  
</I>&gt;<i> advantage of multi-core servers. Perhaps this is Rabbit  
</I>&gt;<i> clustering... I honestly don't know.
</I>&gt;<i>
</I>&gt;<i> FYI, tests on my hardware show that publishing from one process to  
</I>&gt;<i> another on the same box using a direct exchange and the suggestions  
</I>&gt;<i> listed above introduces around 600 microseconds in delivery latency.  
</I>&gt;<i> Pay close attention to your serialization/deserialization code; its  
</I>&gt;<i> performance could be a gating factor.
</I>&gt;<i>
</I>&gt;<i> Let us know how things turn out.
</I>&gt;<i>
</I>&gt;<i> cr
</I>&gt;<i>
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20090605/68069719/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20090605/68069719/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003715.html">[rabbitmq-discuss] Clustering Question
</A></li>
	<LI>Next message: <A HREF="003883.html">[rabbitmq-discuss] Fwd: rabbit MQ high-through put stock quotes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3701">[ date ]</a>
              <a href="thread.html#3701">[ thread ]</a>
              <a href="subject.html#3701">[ subject ]</a>
              <a href="author.html#3701">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
