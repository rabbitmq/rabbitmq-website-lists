<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] [Minimum Air Induction] Introducing Shovel:	An AMQP Relay
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20%5BMinimum%20Air%20Induction%5D%20Introducing%20Shovel%3A%0A%09An%20AMQP%20Relay&In-Reply-To=269388e30809210917x16425b18uddf4daf5b7086c5%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001570.html">
   <LINK REL="Next"  HREF="001556.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] [Minimum Air Induction] Introducing Shovel:	An AMQP Relay</H1>
    <B>Valentino Volonghi</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20%5BMinimum%20Air%20Induction%5D%20Introducing%20Shovel%3A%0A%09An%20AMQP%20Relay&In-Reply-To=269388e30809210917x16425b18uddf4daf5b7086c5%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] [Minimum Air Induction] Introducing Shovel:	An AMQP Relay">dialtone at gmail.com
       </A><BR>
    <I>Sun Sep 21 19:53:21 BST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001570.html">[rabbitmq-discuss] [Minimum Air Induction] Introducing Shovel:	An AMQP Relay
</A></li>
        <LI>Next message: <A HREF="001556.html">[rabbitmq-discuss] Consumer Tags - use case?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1566">[ date ]</a>
              <a href="thread.html#1566">[ thread ]</a>
              <a href="subject.html#1566">[ subject ]</a>
              <a href="author.html#1566">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Sep 21, 2008, at 9:17 AM, Ben Hood wrote:

&gt;<i> Sure, but I think these days people are going for 1.5PC instead of 2PC
</I>&gt;<i> - it's just a cost-benefit comparison.
</I>
Will need to dig into that, seems interesting.

&gt;<i> I shouldn't imagine that this will cost you an order of magnitude -
</I>&gt;<i> the persister is write-optimized after all, though it does have to
</I>&gt;<i> synchronously write to disk.
</I>
I made my measurements and the results are not bad given the test  
platform.

Producer running alone:
Transaction size    -   1K msgs rate
====================================
500                     1538.1 msg/sec
1000                    1919.1 msg/sec
1500                    2145.8 msg/sec
2000                    2390.2 msg/sec
2500                    2459.5 msg/sec
5000                    2740.6 msg/sec
10000                   3014.7 msg/sec
20000                   3075.2 msg/sec

Producer running alone with delivery_mode=0 and 20000 transaction size:
3419.17693154 msg/sec

Producer running alone with delivery_mode=0 and 500 transaction size:
3372.17693154 msg/sec

Consumer running alone:
2734.8 msg/sec

Considering that I'm using an old and slow macbook pro on 10.5.5 I  
think those
numbers are basically what I wanted to see. Transactions without  
persistent
messages are a lot cheaper of course.

Running alone means that the producer/consumer was running only with  
rabbitmq
and nothing else on the other side, the reason for this is to reduce  
the bottleneck
caused by having 2 python processes running (producer and consumer).

So basically this is enough proof for me that this is fast enough for  
what I need.
(attached are the 2 test programs I used).

One thing I noticed is the following errors:

The following on rabbitmq:

=INFO REPORT==== 21-Sep-2008::11:14:37 ===
Rolling persister log to &quot;/Users/dialtone/dev/mnesia/ 
rabbit_persister.LOG.previous&quot;

=ERROR REPORT==== 21-Sep-2008::11:14:42 ===
connection &lt;0.297.0&gt; (running), channel 1 - error:
{commit_failed,
     [{exit,
          {timeout,
              {gen_server,call,[&lt;0.131.0&gt;,{commit,{{26,&lt;0.303.0&gt;}, 
1003}}]}}}]}

=ERROR REPORT==== 21-Sep-2008::11:14:42 ===
Non-AMQP exit reason '{commit_failed,
                           [{exit,
                                {timeout,
                                    {gen_server,call,
                                        [&lt;0.131.0&gt;,
                                         {commit,{{26,&lt;0.303.0&gt;}, 
1003}}]}}}]}'

And this on the client side:

Traceback (most recent call last):
   File &quot;my_send.py&quot;, line 34, in &lt;module&gt;
     main()
   File &quot;my_send.py&quot;, line 23, in main
     ch.tx_commit()
   File &quot;/Users/dialtone/dev/py-amqplib/amqplib/client_0_8.py&quot;, line  
3336, in tx_commit
     (90, 21),    # Channel.tx_commit_ok
   File &quot;/Users/dialtone/dev/py-amqplib/amqplib/client_0_8.py&quot;, line  
183, in wait
     frame_type, payload = self._next_frame()
   File &quot;/Users/dialtone/dev/py-amqplib/amqplib/client_0_8.py&quot;, line  
123, in _next_frame
     return self.connection._wait_channel(self.channel_id)
   File &quot;/Users/dialtone/dev/py-amqplib/amqplib/client_0_8.py&quot;, line  
430, in _wait_channel
     self.wait()
   File &quot;/Users/dialtone/dev/py-amqplib/amqplib/client_0_8.py&quot;, line  
203, in wait
     return self._dispatch(method_sig, args, content)
   File &quot;/Users/dialtone/dev/py-amqplib/amqplib/client_0_8.py&quot;, line  
115, in _dispatch
     return amqp_method(self, args)
   File &quot;/Users/dialtone/dev/py-amqplib/amqplib/client_0_8.py&quot;, line  
563, in _close
     raise AMQPConnectionException(reply_code, reply_text, (class_id,  
method_id))
amqplib.client_0_8.AMQPConnectionException: (541, u'INTERNAL_ERROR',  
(0, 0), '')


Sometimes (happened twice) transactions failed with this error output  
and another weird
thing is that message order is changed during rolling. The test  
programs always sent 20001
messages but sometimes I would receive only 19802 before the 'quit'  
message (usually
the last one) and then after restarting the receiver another 199  
messages (that sum
to 20001 so it's fine anyway).

For my usecase message order has absolutely no importance but I guess  
for something
else like real time data it is.

&gt;&gt;<i> They look OK in the sense that even persistent messages can reach  
</I>&gt;&gt;<i> those
</I>&gt;&gt;<i> rates?
</I>&gt;<i>
</I>&gt;<i> I guess the IO bandwidth of your filesystem would be an important
</I>&gt;<i> factor in this equation.
</I>
Yeah, absolutely.

Hope this measurements where useful for you :)

Here are the 2 scripts, can be used like this:

python my_send.py MESSAGES_NUMBER TRANSACTION_SIZE
python my_receive_direct.py QUEUE_NAME


# my_send.py
#!/usr/bin/env python
import sys
import time

import amqplib.client_0_8 as amqp

MAX = int(sys.argv[1])

def main():
     msg_body = '0'*1000 # 1k

     conn = amqp.Connection(&quot;localhost&quot;, userid=&quot;guest&quot;,  
password=&quot;guest&quot;)
     ch = conn.channel()
     ch.access_request('/data', active=True, write=True)
     ch.exchange_declare('X', type='direct', auto_delete=True)

     msg = amqp.Message(msg_body)

     t = time.time()
     ch.tx_select()
     interval = (int(sys.argv[2]) or MAX-1)
     for i in xrange(MAX):
         if i % interval == 0:
             ch.tx_commit()
             ch.tx_select()
         ch.basic_publish(msg, 'X')
     ch.basic_publish(amqp.Message('quit'), 'X')
     ch.tx_commit()
     ch.close()
     conn.close()

     print MAX/(time.time()-t), &quot;KB/sec (or msg/sec)&quot;

if __name__ == '__main__':
     main()
# end my_send.py

# my_receive_direct.py
#!/usr/bin/env python
import time
import sys
import amqplib.client_0_8 as amqp

counter = 0

def callback(msg):
     global counter
     counter += 1
     msg.channel.basic_ack(msg.delivery_tag)
     if msg.body == 'quit':
         msg.channel.basic_cancel(msg.consumer_tag)
     if counter % 100 == 0:
         sys.stdout.write(&quot;.&quot;)
         sys.stdout.flush()
     if counter % 1000 == 0:
         sys.stdout.write(str(counter))
         sys.stdout.flush()

def main():
     realm = '/data'
     exchange = 'X'
     queue = sys.argv[1]
     conn = amqp.Connection(&quot;localhost&quot;, userid=&quot;guest&quot;,  
password=&quot;guest&quot;)

     ch = conn.channel()
     ch.access_request(realm, active=True, passive=True, read=True)
     ch.exchange_declare(exchange, type='direct', durable=True,  
auto_delete=False)
     qname, _, _ = ch.queue_declare(queue, durable=True,  
auto_delete=False)
     ch.queue_bind(queue, exchange)
     ch.basic_consume(queue, callback=callback)

     try:
         t = time.time()
         while ch.callbacks:
             ch.wait()
     except:
         import traceback
         print traceback.format_exc()
     finally:
         #ch.queue_delete(qname)
         ch.close()
         conn.close()

     print
     print &quot;Total Messages:&quot;, counter
     print counter / (time.time() - t), &quot;KB/sec (or msg/sec)&quot;


if __name__ == '__main__':
     main()
# end my_receive_direct.py

- --
Valentino Volonghi aka Dialtone
Now running MacOS X 10.5
Home Page: <A HREF="http://www.twisted.it">http://www.twisted.it</A>
<A HREF="http://www.adroll.com">http://www.adroll.com</A>

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (Darwin)

iEYEARECAAYFAkjWmCEACgkQ9Llz28widGX2yQCcCQtB5/eZIUf16cLVarCtxsmo
sIEAoMerWqfI6ljsuXW0lfXtY716CtTd
=7wug
-----END PGP SIGNATURE-----


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001570.html">[rabbitmq-discuss] [Minimum Air Induction] Introducing Shovel:	An AMQP Relay
</A></li>
	<LI>Next message: <A HREF="001556.html">[rabbitmq-discuss] Consumer Tags - use case?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1566">[ date ]</a>
              <a href="thread.html#1566">[ thread ]</a>
              <a href="subject.html#1566">[ subject ]</a>
              <a href="author.html#1566">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
