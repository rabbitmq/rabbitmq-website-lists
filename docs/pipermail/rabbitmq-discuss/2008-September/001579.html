<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Publish won't work without transaction?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Publish%20won%27t%20work%20without%20transaction%3F&In-Reply-To=84fb38e30809221613r35fac041v4e214efc20d37274%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001578.html">
   <LINK REL="Next"  HREF="001585.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Publish won't work without transaction?</H1>
    <B>Edwin Fine</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Publish%20won%27t%20work%20without%20transaction%3F&In-Reply-To=84fb38e30809221613r35fac041v4e214efc20d37274%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Publish won't work without transaction?">rabbitmq-discuss_efine at usa.net
       </A><BR>
    <I>Tue Sep 23 00:54:02 BST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001578.html">[rabbitmq-discuss] Publish won't work without transaction?
</A></li>
        <LI>Next message: <A HREF="001585.html">[rabbitmq-discuss] Publish won't work without transaction?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1579">[ date ]</a>
              <a href="thread.html#1579">[ thread ]</a>
              <a href="subject.html#1579">[ subject ]</a>
              <a href="author.html#1579">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Tsuraan,

I am using durable, non-auto-deleting queues and exchanges with persistent
messages. I'm using the Erlang client in network mode, and not using AMQP
transactions. Every message that I basic.publish makes it to the queue, even
if there is no consumer on the other side draining the queue. No messages
are dropped. I have similar hardware to yours except my disks aren't as fast
:<i>)
</I>
Here are my exchange parameters:
:<i>
</I>ExchangeDeclare = #'exchange.declare'{ticket = Ticket, exchange = Exchange,
type = &lt;&lt;&quot;direct&quot;&gt;&gt;,
        passive = false, durable = true, auto_delete = false, internal =
false,
        nowait = false, arguments = []}

Here are the queue declare parameters:

    QueueDeclare = #'queue.declare'{
        ticket = Ticket,
        queue = Q,
        passive = false,        % This is a real creation request, not a
status check
        durable = true,         % Messages must be persistent and survive
server restart
        exclusive = false,
        auto_delete = false,    % Don't auto-delete the queue when released
by channel
        nowait = false,         % Wait for a queue.declare_ok response from
the server
        arguments = []},

And the queue bind:

#'queue.bind'{ticket = Ticket, queue = Q1, exchange = X,
                              routing_key = Q1, nowait = false, arguments =
[]}

Here is the basic.publish setup:

#publish{
        routing_key = RoutingKey,
        queue = Q,
        exchange = X,
        bind_key = _BindKey,
        payload = Payload,
        mandatory = false,  % If true, server sends Return if msg
unroutable, else silently drops msg
        immediate = false   % If true, server sends Return if msg cannot be
delivered immediately, else queues msg
    }

On a different topic, if you are expecting to queue millions of persistent
messages to replace a filesystem-based queuing mechanism, you need to be
aware that at present, RabbitMQ keeps all undelivered messages in memory. If
they are persistent, then they are also saved on disk, but my understanding
is that every message is also kept in memory. There is therefore a memory
constraint and you can't just happily enqueue messages without draining the
queues until the disk is full, without risking memory exhaustion and
resultant Erlang node crash. I understand there are plans to implement an
&quot;overflow to disk&quot; mechanism, but the ETA is unknown to me. Ben can say more
about this.

Hope this helps.

On Mon, Sep 22, 2008 at 7:13 PM, tsuraan &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">tsuraan at gmail.com</A>&gt; wrote:

&gt;<i> &gt; So how do you know whether they're enqueued or not?
</I>&gt;<i>
</I>&gt;<i> When the program's done running, I do a passive queue_declare, and the
</I>&gt;<i> message count has increased by ~400 each time the program has run.
</I>&gt;<i> It's actually more like 300 the first time and 500 the second time,
</I>&gt;<i> but it seems like overall, I get about 400 per run.
</I>&gt;<i>
</I>&gt;<i> &gt;&gt; Is there a way that I can tell whether the message I sent was dropped
</I>&gt;<i> &gt;&gt; by the server?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; You can run rabbit_amqqueue:stat_all() in the shell.
</I>&gt;<i>
</I>&gt;<i> Ok, so there isn't a return code from basic_publish that will tell me
</I>&gt;<i> it was dropped?
</I>&gt;<i>
</I>&gt;<i> &gt; That shouldn't take a minute even with a TX per message and logging to
</I>&gt;<i> disk.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I think something may not be quite right with your setup.
</I>&gt;<i>
</I>&gt;<i> I'd be willing to believe that.  When running with one transaction per
</I>&gt;<i> message, my system is almost idle.  python's taking 2-3% of the cpu,
</I>&gt;<i> beam.smp is taking less than that, and my IO is a few KB/s.  Do you
</I>&gt;<i> have any advice for figuring out what's going on?  My system is a
</I>&gt;<i> core2 duo with a pair of raptor10k drives in RAID1 on a 3ware 9650; I
</I>&gt;<i> shouldn't be too starved for cpu, io, or memory with this setup, so
</I>&gt;<i> any advice for where to start would be much appreciated.
</I>&gt;<i>
</I>&gt;<i> &gt; Either with a transaction or by setting up a return handler (and
</I>&gt;<i> &gt; setting the mandatory flag).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; BTW, when I run this code:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; #!/usr/bin/python2.5
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; import sys
</I>&gt;<i> &gt; from time import time
</I>&gt;<i> &gt; import amqplib.client_0_8 as A
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; q = &quot;q-%d&quot; % int(time())
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; conn = A.Connection(&quot;127.0.0.1&quot;, &quot;guest&quot;, &quot;guest&quot;)
</I>&gt;<i> &gt; chan = conn.channel()
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; chan.queue_declare(queue=q, auto_delete=True, durable=False)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; for i in range(1000):
</I>&gt;<i> &gt;    print i
</I>&gt;<i> &gt;    m = A.Message(str(i), delivery_mode=1)
</I>&gt;<i> &gt;    print chan.basic_publish(m, &quot;&quot;, q, mandatory=True, immediate=False)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; and then in the shell
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbit at xlr8</A>)3&gt; rabbit_amqqueue:stat_all().
</I>&gt;<i> &gt; [{ok,{resource,&lt;&lt;&quot;/&quot;&gt;&gt;,queue,&lt;&lt;&quot;q-1222121318&quot;&gt;&gt;},1000,0}]
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; which would indicate that 1000 messages got enqueued.
</I>&gt;<i>
</I>&gt;<i> Is the difference then that my queues are persistent?  I'm using a
</I>&gt;<i> topic exchange with just one persistent, non-autodelete queue.  Does
</I>&gt;<i> that change things?
</I>&gt;<i>
</I>&gt;<i> &gt; And maybe this is a stupid question, but why are you enqueuing stuff?
</I>&gt;<i> &gt; Don't you want it to be delivered?
</I>&gt;<i>
</I>&gt;<i> Isn't enqueuing a necessary step before delivery?  The system I'm
</I>&gt;<i> working on processes a lot of files, and as files are processed new
</I>&gt;<i> files or database rows are created that have to be processed
</I>&gt;<i> downstream.  Sometimes the programs doing the processing get hung up
</I>&gt;<i> on invalid data, or get flooded with more data than they can process
</I>&gt;<i> in a timely manner, so the workloads get really badly backed up.  I've
</I>&gt;<i> seen programs that have millions of tasks in their job queues more
</I>&gt;<i> than a few times.
</I>&gt;<i>
</I>&gt;<i> We currently have a &quot;message queue&quot; system that is just files written
</I>&gt;<i> to the hard drive; different directories are the job queues for
</I>&gt;<i> different actors, and the files in them are just identifiers for
</I>&gt;<i> database or file-based workloads.  I want to replace that with real
</I>&gt;<i> message queue system for all sorts of reasons, so I'm just
</I>&gt;<i> experimenting with RabbitMQ to see if it does what I need, and to see
</I>&gt;<i> how good the performance and stability are.
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20080922/a3523210/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20080922/a3523210/attachment.htm</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001578.html">[rabbitmq-discuss] Publish won't work without transaction?
</A></li>
	<LI>Next message: <A HREF="001585.html">[rabbitmq-discuss] Publish won't work without transaction?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1579">[ date ]</a>
              <a href="thread.html#1579">[ thread ]</a>
              <a href="subject.html#1579">[ subject ]</a>
              <a href="author.html#1579">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
