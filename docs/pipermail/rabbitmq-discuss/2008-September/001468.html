<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] RabbitMQ memory management
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20RabbitMQ%20memory%20management&In-Reply-To=6c2563b20809111831s2fa2d4cag3e1e624fd8c2d48c%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001464.html">
   <LINK REL="Next"  HREF="001469.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] RabbitMQ memory management</H1>
    <B>Ben Hood</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20RabbitMQ%20memory%20management&In-Reply-To=6c2563b20809111831s2fa2d4cag3e1e624fd8c2d48c%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] RabbitMQ memory management">0x6e6562 at gmail.com
       </A><BR>
    <I>Fri Sep 12 17:27:40 BST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001464.html">[rabbitmq-discuss] RabbitMQ memory management
</A></li>
        <LI>Next message: <A HREF="001469.html">[rabbitmq-discuss] RabbitMQ memory management
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1468">[ date ]</a>
              <a href="thread.html#1468">[ thread ]</a>
              <a href="subject.html#1468">[ subject ]</a>
              <a href="author.html#1468">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Edwin,

On Fri, Sep 12, 2008 at 2:31 AM, Edwin Fine
&lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss_efine at usa.net</A>&gt; wrote:
&gt;<i> I think you misunderstood my message. I was saying RabbitMQ should be able
</I>&gt;<i> to store a non-memory-limited number of persistent messages in the absence
</I>&gt;<i> of a consumer draining the queue. So to be exact, these would be
</I>&gt;<i> non-transactional persistent messages. You replied to me about
</I>&gt;<i> non-persistent messages, which I know are memory-limited. I am confused,
</I>&gt;<i> because I was at one time (when I was doing my due diligence) convinced that
</I>&gt;<i> RabbitMQ had no practical limit (other than any set by Mnesia and hard disk
</I>&gt;<i> space) for storing non-transactional persistent messages. I am simply
</I>&gt;<i> concerned that perhaps I was mistaken and was asking you to elaborate.
</I>
Thanks for the clarification.

The status quo is that irrespective of whether we are talking about
persistent or non-persistent messages, messages are queued up in
memory until they are drained. The difference between persistent and
non-persistent is that with persistent messages a replica of each
message is written to disk. This disk copy will only be used in a
recovery situation for messages that have not been acknowledged.

Obviously the limit to which you carry on queuing messages without
draining them depends on the physical resources available to the
Erlang VM and how virtual memory is utilized, which in turn depends on
your OS and production setup.

So to draw a line in the sand, you could go through and calibrate your
setup wrt to the point at which it cannot allocate any more memory. By
doing so, you've worked out approximately what your absolute bottom
line will be. If, for example, your expected capacity is a small
fraction of this known limit for your particular setup, and that in
practice, you would notice undrained messages long before you hit the
limit, you *might* decide that for all intents and purposes this is a
acceptable and manageable risk.

Whilst doing your testing, you may not have encountered any problems,
because you may not have pushed it to the limit. All I am saying is
that in doing stress testing for the scalability improvements I am
working on, I have pushed Rabbit to its limits at various stages and
am just informing you of the current theoretical worse case scenario -
ATM queue depth is bounded by memory and there is no overflow
facility.

However, you may be more risk averse and not want to entertain the
possibility of exhausting your system resources, ever.

In that case, as you have rightfully pointed out, an obvious
improvement to Rabbit is to overflow to disk when a certain queue
depth is reached.

This could apply to persistent and non-persistent messages alike.

I'll take this down as an enhancement suggestion which may factored in
the work that we have planned to make queues pluggable. An alternative
is to incorporate this into the current queue implementation, but
whether we do this would basically depend on what resources we have
available and how acute it is time wise.

Another related improvement includes implementing message expiry.

Please let us what your time scales are for when you absolutely need
this in production.

HTH,

Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001464.html">[rabbitmq-discuss] RabbitMQ memory management
</A></li>
	<LI>Next message: <A HREF="001469.html">[rabbitmq-discuss] RabbitMQ memory management
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1468">[ date ]</a>
              <a href="thread.html#1468">[ thread ]</a>
              <a href="subject.html#1468">[ subject ]</a>
              <a href="author.html#1468">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
