<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] performance
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20performance&In-Reply-To=6c2563b20808301431qcc1c63cp8c36c790ed539ec9%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001286.html">
   <LINK REL="Next"  HREF="001290.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] performance</H1>
    <B>Matthias Radestock</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20performance&In-Reply-To=6c2563b20808301431qcc1c63cp8c36c790ed539ec9%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] performance">matthias at lshift.net
       </A><BR>
    <I>Mon Sep  1 13:01:57 BST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001286.html">[rabbitmq-discuss] Urgently Need help to get RabbitMQ publishing to	Flex-based subscriber
</A></li>
        <LI>Next message: <A HREF="001290.html">[rabbitmq-discuss] performance
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1287">[ date ]</a>
              <a href="thread.html#1287">[ thread ]</a>
              <a href="subject.html#1287">[ subject ]</a>
              <a href="author.html#1287">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Edwin,

Edwin Fine wrote:
&gt;<i> 
</I>&gt;<i>     Some testing we did in the past indicates that generally a clustered
</I>&gt;<i>     broker - with one node per core and smp disabled for the Erlang VM -
</I>&gt;<i>     performs significantly better than a single smp-enabled node.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Now /that/ is very interesting. I have seen the same kind of thing in 
</I>&gt;<i> some ad-hoc (non-RabbitMQ related) experiments I did some time back 
</I>&gt;<i> (better performance from multiple VMs, each in single-cpu configuration, 
</I>&gt;<i> on a multi-core system) and thought it was my imagination because SMP 
</I>&gt;<i> was supposed to be the way to go. I haven't seen much discussion on this 
</I>&gt;<i> on the erlang-questions mailing lists, and quite frankly, I'm not going 
</I>&gt;<i> to start one without some solid, repeatable evidence. If you have seen 
</I>&gt;<i> this behavior, have you brought it up with the Erlang gurus, and if so, 
</I>&gt;<i> have they said anything enlightening about it?
</I>
I have mentioned our observations to a few folks, but, as you say, there 
is no point in pursuing this further until we have solid, repeatable 
evidence. Now, our results *are* repeatable, but they are all in the 
context of RabbitMQ. To start a fruitful discussion on the Erlang list / 
with the Erlang gurus we'd need to construct a simpler, standalone test 
exhibiting the same behaviour. In the process we may well discover the 
root cause of the problem ourselves.

Btw, one issue with performance testing of RabbitMQ is that it is really 
difficult to measure the maximum throughput. RabbitMQ is a message 
*queuing* system, and any test setup will have several message buffers 
at various levels - the OS's network stack at the test client and 
RabbitMQ server, various process message queues at the server and 
buffers in the test client, and the queue processes at the server. 
Optimum throughput is achieved when all these buffers contain just the 
right amount of data so that the processing hanging off them never has 
to wait for data and yet no data is buffered unnecessarily. There are 
lots of tweakable parameters that affect buffering in the OS, the 
Erlang/Java VM, and the client/server apps. Furthermore, due to jit-ing 
and variations in scheduling decisions (by the VMs and the OS) the 
optimal settings shift over time.

As others have discovered, if a test just blasts messages at RabbitMQ, 
the broker will likely start queuing up most of them, consume increasing 
amounts of memory, and eventually grind to a halt. To get a sensible max 
throughput measurement a more sophisticated approach is required that 
controls and adapts the sending rate to the prevailing conditions.

We'd love to get the help of the community to put together a really 
simple &quot;run this and it will report the maximum throughput&quot; test 
program. Initially this can be for just the simplest (and fastest) 
routing scenario - single producer, single consumer (running in the same 
OS process if that is convenient), single queue, direct exchange, 
auto-ack basic.consume.

Note that this test app would work against all AMQP brokers, not just 
RabbitMQ, so could be used for performance comparison.

Any takers?


Matthias.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001286.html">[rabbitmq-discuss] Urgently Need help to get RabbitMQ publishing to	Flex-based subscriber
</A></li>
	<LI>Next message: <A HREF="001290.html">[rabbitmq-discuss] performance
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1287">[ date ]</a>
              <a href="thread.html#1287">[ thread ]</a>
              <a href="subject.html#1287">[ subject ]</a>
              <a href="author.html#1287">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
