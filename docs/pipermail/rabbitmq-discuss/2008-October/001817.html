<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Erlang client: function_clause error
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Erlang%20client%3A%20function_clause%20error&In-Reply-To=269388e30810280431u520f7d87sf977744eb9bbd430%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001810.html">
   <LINK REL="Next"  HREF="001829.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Erlang client: function_clause error</H1>
    <B>Valentino Volonghi</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Erlang%20client%3A%20function_clause%20error&In-Reply-To=269388e30810280431u520f7d87sf977744eb9bbd430%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Erlang client: function_clause error">dialtone at gmail.com
       </A><BR>
    <I>Tue Oct 28 18:53:17 GMT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001810.html">[rabbitmq-discuss] Erlang client: function_clause error
</A></li>
        <LI>Next message: <A HREF="001829.html">[rabbitmq-discuss] Erlang client: function_clause error
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1817">[ date ]</a>
              <a href="thread.html#1817">[ thread ]</a>
              <a href="subject.html#1817">[ subject ]</a>
              <a href="author.html#1817">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Oct 28, 2008, at 4:31 AM, Ben Hood wrote:

&gt;<i> In general, you can help by either contributing code yourself or by
</I>&gt;<i> financing the reprioritization of the roadmap.
</I>&gt;<i>
</I>&gt;<i> Disk overflow or queue paging is on the mid term roadmap as something
</I>&gt;<i> we are going to do, but we still need to gather requirements.
</I>&gt;<i>
</I>&gt;<i> Here are a few examples:
</I>&gt;<i>
</I>&gt;<i> - When do you decide to page things to disk?
</I>
I'd say memory high watermark reached or, if reached before, a number
of messages in the queue.

&gt;<i> - Is it done on memory consumption or queue depth?
</I>
Both. Depends on which one is reached first, I can see use cases for
both of these triggers.

&gt;<i> - Is this configurable per queue or across the broker?
</I>
Across the broker, other AMQP implementation have a 'maximum number
of messages in a queue' as a per broker option.

&gt;<i> - What are sensible defaults so that people who haven't even though
</I>&gt;<i>  about paging don't get affected by overly-agressive defaults?
</I>
If a user was not affected before it won't be affected even after  
because
he won't need to overflow to disk anyway. In case the limit hit is the  
number
of messages then simply set it to infinite when no different is  
specified. Then
it will only use memory watermark and this would give them more  
robustness
going from simply crashing the erlang VM because memory is finished to
slowing down because you are now reading from disk.

&gt;<i> - When and how do you swap back in - is this automatic or manual?
</I>
When the buffer in the disk is empty then rabbitmq can stop using it,  
I expect
it to deliver messages in order so once the buffer kicks in I'd queue  
stuff on
disk immediately.

&gt;<i> - How do you decide when the low water mark has been reached after
</I>&gt;<i>  having commenced the page-in? Do you resume flow control at this  
</I>&gt;<i> point?
</I>
When the disk buffer is empty. And you simply resume working without it.

&gt;<i> - If you do page, are you interested in last image caching?
</I>
I'm not sure what this means but looks like an optimization, it's  
probably
interesting to have but caching can come when the system can resist
prolonged consumer downtimes.

Anyway being an optimization in the queue process it should be fairly
isolated in it. I can totally see keeping the current page always in  
memory
(if this is the optimization we are talking about), the big problem is  
keeping
everything in memory.

&gt;<i> - Do you want to apply application level heuristics to selectively  
</I>&gt;<i> purge
</I>&gt;<i>  overflowed queues?
</I>
ActiveMQ offers basically 3 different ways to deal with the problem:
kill the queue, drop all new messages, drop old messages.

This can be taken care of in the publish command of rabbitmq.

&gt;<i> - What role do TTLs play in this scenario?
</I>
It's not the role of the message broker to kill single messages, it's  
an application
level decision. I can see a configuration option in the queue though  
that together
with the 3 options above can provide a 'kill all the messages older  
than X seconds'.

This can be taken care inside the queue itself when getting the top of  
the queue.

&gt;<i> - Furthermore, we do already have a fast message persister - it's just
</I>&gt;<i>  that it's geared to write as quickly as possible, not read.
</I>
And this is a great to me.

&gt;<i> - Ask yourself, if we implement paging, is are we potentially  
</I>&gt;<i> reinventing
</I>&gt;<i>  a wheel that the OS has already invented?
</I>
Well, sure. But erlang fails before when it cannot malloc memory.

&gt;<i> - And as always, what do you do when your SAN fills up?
</I>
If a 500-600GB disk fills up it means I had at least ~80 times more  
time to
fix the problem somehow, given an average of 8GB of memory in a  
webserver.
So if with 8GB of memory I had 10 hours to fix it, with a disk I have  
30 days to
fix it, and I can even add new disks with a good disk array or  
filesystem to buy
me more time.

&gt;<i> One suggestion to kick things off is to begin a more structured
</I>&gt;<i> analysis of the whole problem on the wiki and start a dedicated
</I>&gt;<i> discussion thread around this. For example, one could start a document
</I>&gt;<i> highlighting the motivation and requirements and let interested
</I>&gt;<i> parties comment on this.
</I>
Good, I'm all for this. And I'm starting with this reply.

&gt;<i> Having said that, whilst it may be straight forward to do a hello
</I>&gt;<i> world overflow, the devil is in the detail of all of the moving parts
</I>&gt;<i> and different scenarios that you have to account for whilst maintaing
</I>&gt;<i> the clarity of the code base. And testing it of course.
</I>

Yep, this is just right.

-- 
Valentino Volonghi aka Dialtone
Now running MacOS X 10.5
Home Page: <A HREF="http://www.twisted.it">http://www.twisted.it</A>
<A HREF="http://www.adroll.com">http://www.adroll.com</A>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20081028/59ef4692/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20081028/59ef4692/attachment.htm</A> 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PGP.sig
Type: application/pgp-signature
Size: 194 bytes
Desc: This is a digitally signed message part
Url : <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20081028/59ef4692/attachment.pgp">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20081028/59ef4692/attachment.pgp</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001810.html">[rabbitmq-discuss] Erlang client: function_clause error
</A></li>
	<LI>Next message: <A HREF="001829.html">[rabbitmq-discuss] Erlang client: function_clause error
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1817">[ date ]</a>
              <a href="thread.html#1817">[ thread ]</a>
              <a href="subject.html#1817">[ subject ]</a>
              <a href="author.html#1817">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
