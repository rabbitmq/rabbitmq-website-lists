<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Redelivery of unacknowledged messages
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Redelivery%20of%20unacknowledged%20messages&In-Reply-To=4cc167ca0810031023i3b0d3dd7t822066682837b896%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001679.html">
   <LINK REL="Next"  HREF="001683.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Redelivery of unacknowledged messages</H1>
    <B>Ben Hood</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Redelivery%20of%20unacknowledged%20messages&In-Reply-To=4cc167ca0810031023i3b0d3dd7t822066682837b896%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Redelivery of unacknowledged messages">0x6e6562 at gmail.com
       </A><BR>
    <I>Fri Oct  3 18:57:58 BST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001679.html">[rabbitmq-discuss] RabbitMQ erlang broker problem
</A></li>
        <LI>Next message: <A HREF="001683.html">[rabbitmq-discuss] Improved queue status
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1682">[ date ]</a>
              <a href="thread.html#1682">[ thread ]</a>
              <a href="subject.html#1682">[ subject ]</a>
              <a href="author.html#1682">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jonatan,

On Fri, Oct 3, 2008 at 6:23 PM, Jonatan Kallus &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">jonatan.kallus at gmail.com</A>&gt; wrote:
&gt;<i> The system around the queue involves a few web servers using php to enqueue
</I>&gt;<i> messages at almost every page load and a single java application that
</I>&gt;<i> subscribes to the queue and makes one http request to another site for each
</I>&gt;<i> message. (To take load off from the web servers and to make their flow
</I>&gt;<i> asynchronous, in opposite to when they made the http request themselves.)
</I>&gt;<i> The http request usually takes around 50 ms, but sometimes more and
</I>&gt;<i> sometimes they fail or timeout after 60 s. We are using a number of
</I>&gt;<i> concurrent connections for the http client, not to let a single http request
</I>&gt;<i> timing out block the queue. The RabbitMQ subscriber starts threads that
</I>&gt;<i> handles the http requests as long as there are available http connections,
</I>&gt;<i> if there are no available http connections, the handleDelivery method waits
</I>&gt;<i> (while-loop) for a free connection, thus blocking from receiving more
</I>&gt;<i> messages until there is time to handle them.
</I>&gt;<i>
</I>&gt;<i> Currently I acknowledge messages that results in a successful http request,
</I>&gt;<i> but any message that fails due to issues outside of our system (timeouts
</I>&gt;<i> etc.) does not get acknowledged, since we want them to be delivered again
</I>&gt;<i> later.
</I>

So if I understand you correctly, the problem that may arise is not an
issue with the message per se, but one of the availability of the
downstream system.

In which case it may be an idea to retry the downstream system,
potentially n times.

After n retries, you might decide that it's pointless to continue, so
you just end the channel (unacked messages get requeued) and tell your
friendly sysad that something is wrong with the other system.

In this case, it wouldn't help to be able to reject the message,
since, if I understand you correctly, the next message may also have a
reasonable chance of failing as well.

In this particular scenario, message rejection as an exception
management strategy is too fine grained, because the actual root cause
of the errors is very coarse grained - the downstream system has
barfed. Hence you might want to reflect this situation by ceasing to
try to send it anything at all.

After the issue with the downstream system is resolved, restart the
consumer(s) and resume processing.

Basic.Reject is a fine grained mechanism - it is sent by a particular
consumer to the broker with a &quot;don't send me this one again&quot;
sentiment.

It is also an academic mechanism in RabbitMQ, because it isn't implemented :-(

HTH,

Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001679.html">[rabbitmq-discuss] RabbitMQ erlang broker problem
</A></li>
	<LI>Next message: <A HREF="001683.html">[rabbitmq-discuss] Improved queue status
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1682">[ date ]</a>
              <a href="thread.html#1682">[ thread ]</a>
              <a href="subject.html#1682">[ subject ]</a>
              <a href="author.html#1682">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
