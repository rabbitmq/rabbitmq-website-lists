<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Exchanges, Routing, and AMQP
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Exchanges%2C%20Routing%2C%20and%20AMQP&In-Reply-To=8f10a9e00810210940x2991d29fidd942b75af333947%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001795.html">
   <LINK REL="Next"  HREF="001750.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Exchanges, Routing, and AMQP</H1>
    <B>Ben Hood</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Exchanges%2C%20Routing%2C%20and%20AMQP&In-Reply-To=8f10a9e00810210940x2991d29fidd942b75af333947%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Exchanges, Routing, and AMQP">0x6e6562 at gmail.com
       </A><BR>
    <I>Fri Oct 24 14:50:50 BST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001795.html">[rabbitmq-discuss] Exchanges, Routing, and AMQP
</A></li>
        <LI>Next message: <A HREF="001750.html">[rabbitmq-discuss] jms support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1793">[ date ]</a>
              <a href="thread.html#1793">[ thread ]</a>
              <a href="subject.html#1793">[ subject ]</a>
              <a href="author.html#1793">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Kirk,

On Tue, Oct 21, 2008 at 5:40 PM, Kirk Wylie &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">kirk at kirkwylie.com</A>&gt; wrote:
&gt;<i> Well, no, actually, that's not true. That's only true of a naive
</I>&gt;<i> implementation of a binding-based system. The RabbitMQ-based
</I>&gt;<i> implementation where you're modelling all the primitive AMQP concepts
</I>&gt;<i> as direct Erlang processes would definitely suffer from this problem,
</I>&gt;<i> but I'm sure you could work out a system where invoking a binding
</I>&gt;<i> dynamically modifies the routing table of the exchange.
</I>
Don't get me wrong, the thing I that I would love the most is to be
proven wrong on this point.

The reason why I say this is because I have an interest in pushing
back the boundaries with Rabbit so I would quite humbly accept the
suggestion of an algorithm that allows you to match routes in
sublinear time over an arbitrarily large routing table whilst
deferring the specification of the algorithm to the bindings.

So if you really think that I do not possess the level of abstraction
required to think beyond the implementation I am currently working on,
please set me straight.

And lets set a few things straight, lest untruths manifest themselves
as technical arguments :-)

- Rabbit does not model every AMQP concept as a process - bindings or
routes are not modeled as processes;
- What do you mean excatly by &quot;invoking a binding&quot;?
- The routing table is dynamically modified by issuing the Bind and
Unbind commands to the broker.

Setting the rebuttal aside now to concentrate on the real design and
engineering concerns, do you think you can come up with a simple model
on paper for this?

Here's a suggestion of where one *may* start (requires a fixed width font):

                        -----------
                        | Message |
                        | key = x |
                        -----------
                             |
                             |
                        ------------
                        | Exchange |
                        | name = y |
                        ------------
                             |
        ------------------------------------------
        |                    |                   |
------------------  ------------------  ------------------
|<i> Binding        |  | Binding        |  | Binding        |
</I>|<i> key = foo      |  | key = bar      |  | key = baz      |
</I>|<i> algorithm = A1 |  | algorithm = A2 |  | algorithm = A3 |
</I>------------------  ------------------  ------------------

My point is that by deferring the algorithm to the bindings you are
removing any potential of using root metadata in when you compute the
routing graph.

Although this is slightly OT, this is reminiscent of the way that svn
stores metadata on a per-directory basis as opposed to storing it in
the root - the difference being the ease to which you can compute the
transitive closure of the graph.

&gt;&gt;<i> Furthermore, you can bring the consumer driven-ness into the realm of
</I>&gt;&gt;<i> your app by having a convention that prevents a producer from
</I>&gt;&gt;<i> declaring exchanges - if the exchange doesn't exist, then the producer
</I>&gt;&gt;<i> will not be able to send messages to it.
</I>&gt;<i>
</I>&gt;<i> Then the &quot;createExchange&quot; call shouldn't be an assertion, it should
</I>&gt;<i> check for a pre-defined configuration point.
</I>
You can currently use the passive flag to achieve this.

Ben


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001795.html">[rabbitmq-discuss] Exchanges, Routing, and AMQP
</A></li>
	<LI>Next message: <A HREF="001750.html">[rabbitmq-discuss] jms support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1793">[ date ]</a>
              <a href="thread.html#1793">[ thread ]</a>
              <a href="subject.html#1793">[ subject ]</a>
              <a href="author.html#1793">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
