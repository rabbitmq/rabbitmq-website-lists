<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Weird Crash - Recovery logic for durable messages/queues/exchanges?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Weird%20Crash%20-%20Recovery%20logic%20for%20durable%0A%20messages/queues/exchanges%3F&In-Reply-To=50c8ffe90908062239o25ef8110wad353a2f744f625a%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Weird Crash - Recovery logic for durable messages/queues/exchanges?</H1>
    <B>Matthias Radestock</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Weird%20Crash%20-%20Recovery%20logic%20for%20durable%0A%20messages/queues/exchanges%3F&In-Reply-To=50c8ffe90908062239o25ef8110wad353a2f744f625a%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Weird Crash - Recovery logic for durable messages/queues/exchanges?">matthias at lshift.net
       </A><BR>
    <I>Fri Aug  7 11:05:12 BST 2009</I>
    <P><UL>
        
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4416">[ date ]</a>
              <a href="thread.html#4416">[ thread ]</a>
              <a href="subject.html#4416">[ subject ]</a>
              <a href="author.html#4416">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Darien,

Darien Kindlund wrote:
&gt;<i> Okay, your wording is a little vague, so I want to be crystal clear.
</I>&gt;<i> Assume we have a single RabbitMQ server, with 3 consumers, where all 3
</I>&gt;<i> are consuming messages off the same durable queue (with durable
</I>&gt;<i> messages).
</I>
(minor quibble on terminology) resources can be made *durable*, messages 
can be made *persistent*.

&gt;<i> When all 3 start processing their respective messages RabbitMQ marks
</I>&gt;<i> all 3 durable messages as 'unacknowledged'.  Then, let's assume
</I>&gt;<i> RabbitMQ crashes (for some reason or another).  *STICKING POINT: Upon
</I>&gt;<i> crash, all 3 consumers channels and connections have terminated -- I
</I>&gt;<i> assume there's no way for any of the consumers to &quot;reuse&quot; their
</I>&gt;<i> existing channels/connections because RabbitMQ server died.*
</I>
Correct.

&gt;<i> Therefore, when a sysadmin restarts RabbitMQ and the persister is
</I>&gt;<i> recovered, will all 3 messages be marked 'ready' ?  Or will all 3 be
</I>&gt;<i> marked 'unacknowledged' ?   Sorry to be pedantic, but your original
</I>&gt;<i> reply was slightly unclear about this.
</I>
They will be marked as ready, unless some consumers have managed to 
connect again already and the messages have been sent out to them, in 
which case they are counted as 'unacknowledged'.

&gt;&gt;<i> So what you are seeing is rather strange. Are you sure there aren't any
</I>&gt;&gt;<i> connected consumers?
</I>&gt;<i> 
</I>&gt;<i> I'm sure there are no connected consumers -- although I assume that
</I>&gt;<i> when RabbitMQ crashes, all consumer channels/connections are
</I>&gt;<i> terminated as well.  For good measure, I also had to terminate and
</I>&gt;<i> restart epmd... otherwise, RabbitMQ would not start up properly via
</I>&gt;<i> '/etc/init.d/rabbitmq start'.  FYI, this is on a stock Ubuntu
</I>&gt;<i> distribution.
</I>
Your consumers aren't by any chance containing some reconnecting logic 
that tries to connect to the server again whenever a connection has been 
dropped? I seem to recall reports that, for example, the ruby client 
does something like that. Please check the server log to be sure - it 
contains a record of all connects/disconnects.

&gt;<i> As an interesting side case, is there any way to manually reset
</I>&gt;<i> un-ack'd messages back into the ready state while RabbitMQ is running
</I>&gt;<i> (and consumers/producers are active?).
</I>
Once the server has delivered a message to a consumer, it will only 
become available again to other consumers when then recipients 
channel/connection is closed.

&gt;<i> I'm trying to avoid having to shutdown the RabbitMQ server and
</I>&gt;<i> obliterate the nmesia persister log in order to clear out these
</I>&gt;<i> messages.
</I>
That would remove all messages completely, rather than just making the 
unacknowledged messages available to other consumers again. If the 
former is really what you want then the 'queue.purge' command is your 
friend.


Regards,

Matthias.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4416">[ date ]</a>
              <a href="thread.html#4416">[ thread ]</a>
              <a href="subject.html#4416">[ subject ]</a>
              <a href="author.html#4416">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
