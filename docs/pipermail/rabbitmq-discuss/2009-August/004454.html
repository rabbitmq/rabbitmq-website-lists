<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Weird%20Crash%20%2891MB%20message%20over%20STOMP%29%0A%09%5BReproducible%5D&In-Reply-To=50c8ffe90908091252qeabe2d1pcc1d9abe329a5979%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004452.html">
   <LINK REL="Next"  HREF="004476.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]</H1>
    <B>Matthias Radestock</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Weird%20Crash%20%2891MB%20message%20over%20STOMP%29%0A%09%5BReproducible%5D&In-Reply-To=50c8ffe90908091252qeabe2d1pcc1d9abe329a5979%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]">matthias at lshift.net
       </A><BR>
    <I>Sun Aug  9 23:56:29 BST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="004452.html">[rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]
</A></li>
        <LI>Next message: <A HREF="004476.html">[rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4454">[ date ]</a>
              <a href="thread.html#4454">[ thread ]</a>
              <a href="subject.html#4454">[ subject ]</a>
              <a href="author.html#4454">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Darien,

Darien Kindlund wrote:
&gt;<i> This particular bug makes me wonder about a much larger issue: In
</I>&gt;<i> general, how *should* RabbitMQ behave when it's fed an astronomically
</I>&gt;<i> large message size?
</I>&gt;<i> 
</I>&gt;<i> Let's say that RabbitMQ is smart, in that if the message is to big to
</I>&gt;<i> fit into RAM, it will attempt to page the rest of the message onto
</I>&gt;<i> disk ... but what happens when the disk is completely full and there's
</I>&gt;<i> simply no space left?
</I>&gt;<i> 
</I>&gt;<i> Ideally, I'm thinking (in this scenario) RabbitMQ should gracefully
</I>&gt;<i> return an error message to the producer, discard the message, and
</I>&gt;<i> somehow terminate the producer's send operation.  I'm not sure if this
</I>&gt;<i> is exactly how it's handled already -- or if this behavior is
</I>&gt;<i> consistent across all the different connector transports (e.g., HTTP,
</I>&gt;<i> STOMP).
</I>&gt;<i> 
</I>&gt;<i> I'm not an AMQP spec expert, but if the AMQP spec requires that all
</I>&gt;<i> producers supply the message size in the header (ahead of time), then
</I>&gt;<i> RabbitMQ could easily perform sanity checks on the maximum allowable
</I>&gt;<i> message size.  A RabbitMQ admin could specify this configuration
</I>&gt;<i> option in the /etc/rabbitmq/rabbitmq.conf file... or RabbitMQ could
</I>&gt;<i> approximate a maximal message size by looking at the total RAM + a
</I>&gt;<i> portion of the unused swap.  That way RabbitMQ could inspect the
</I>&gt;<i> message size and pre-emptively reject the producer's message before
</I>&gt;<i> running into the out-of-RAM/diskspace issue.
</I>
In theory that's all possible in AMQP, which requires the content-length 
to be transmitted at the beginning, an even STOMP, as long as producers 
include the optional content-length header there.

One complication is that not all messages do in fact need to be stored - 
there may be no queues to send the message to, or the queues may have 
only auto-ack consumers (in which case the message could in theory be 
&quot;streamed through&quot;).

RabbitMQ doesn't implement anything fancy here; if a message doesn't fit 
into available virtual memory then the broker will die.

RabbitMQ can still transmit large messages though. The way to do that is 
to get the producer to chop up the original message into smaller ones, 
and for the consumer to reassemble them. This has the added advantage of 
making it easier to deal with failures by performing partial 
retransmissions - something that isn't possible if messages are treated 
as indivisible entities.


Regards,

Matthias.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004452.html">[rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]
</A></li>
	<LI>Next message: <A HREF="004476.html">[rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4454">[ date ]</a>
              <a href="thread.html#4454">[ thread ]</a>
              <a href="subject.html#4454">[ subject ]</a>
              <a href="author.html#4454">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
