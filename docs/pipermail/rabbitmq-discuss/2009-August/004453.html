<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] building chat
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20building%20chat&In-Reply-To=b0200d7f0908080628g233cd1f9i70e2171f876a505c%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004445.html">
   <LINK REL="Next"  HREF="004459.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] building chat</H1>
    <B>Alexis Richardson</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20building%20chat&In-Reply-To=b0200d7f0908080628g233cd1f9i70e2171f876a505c%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] building chat">alexis.richardson at gmail.com
       </A><BR>
    <I>Sun Aug  9 22:25:48 BST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="004445.html">[rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]
</A></li>
        <LI>Next message: <A HREF="004459.html">[rabbitmq-discuss] building chat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4453">[ date ]</a>
              <a href="thread.html#4453">[ thread ]</a>
              <a href="subject.html#4453">[ subject ]</a>
              <a href="author.html#4453">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ben,


On Sat, Aug 8, 2009 at 2:28 PM, Ben Browitt&lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">ben.browitt at gmail.com</A>&gt; wrote:
&gt;&gt;<i>
</I>&gt;&gt;<i> Do you want to do MUC or IM?
</I>&gt;<i>
</I>&gt;<i> I'm not actually building it.
</I>&gt;<i> I keep hearing about AMQP and RabbitMQ so I read the spec and the server
</I>&gt;<i> docs.
</I>&gt;<i> I couldn't find use cases on the web so I thought I'll try to fit the
</I>&gt;<i> protocol to a fun application.
</I>
Cool - understood.



&gt;&gt;<i> In fact, you can use a single approach to both.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> One approach is to have one queue per consumer 'chat window' and one
</I>&gt;&gt;<i> exchange per 'chat room'. &#160;The queue is bound to the exchange when the
</I>&gt;&gt;<i> user is in the chatroom. &#160;Then, IM is a special case of MUC - it is a
</I>&gt;&gt;<i> chatroom with two participants.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Another approach would be to have one queue per consumer, and have
</I>&gt;&gt;<i> that queue bound to the exchange(s) N times, where N is the number of
</I>&gt;&gt;<i> chatrooms (or IMs) which the consumer is currently in. &#160;In this
</I>&gt;&gt;<i> approach, you will need to identify which message came from which
</I>&gt;&gt;<i> room, before you show the messages to the user. &#160;That's easy but it's
</I>&gt;&gt;<i> extra work and data to carry around.
</I>&gt;<i>
</I>&gt;<i> When a client sends a message to another client he usually doesn't create a
</I>&gt;<i> chatroom for two,
</I>&gt;<i> he just sends the message and the server routes it. With your suggestion the
</I>&gt;<i> server will create
</I>&gt;<i> the room if it doesn't exists when it needs to route a message.
</I>
What I am suggesting is that the solution for IM can use queues.  In
AMQP you can also think of queues as buffers with configurable
properties including routing rules based on AMQP's &quot;bindings&quot; and QoS
eg durability.  So, for an IM example you could have each user
consuming a message stream of 'what the other user said' through that
user's queue.  So, yes, when the queue doesn't exist, and is needed,
it should be created.  It can be deleted later, or kept around -
depending on what you want to achieve.




&gt;<i> When all the users leaves a MUC room if it is not persistent the server
</I>&gt;<i> destroys it.
</I>
You could set up an AMQP MUC system to do that if you liked.  Or, you
could set it up to make the queues durable and therefore not destroyed
in this case.




&gt;<i> What will be the case with a chatroom with two participants?
</I>
It's up to you.

I would suggest deleting the queues used for the IM once the IM has completed.

Separately, you might want to add the feature &quot;being able to send
messages when the other user is offline.  For this, you would want the
queue lifecycle to be independent of the user's connections.



&gt;<i> Maybe the server will destroy it when both users are offline?
</I>
It comes down to how you set up your system.  AMQP is very flexible,
eg allowing both the cases (a) destroy queues, (b) keep queues.


&gt;<i> Is there a way to destroy an exchange if it is not active for several
</I>&gt;<i> minutes to save memory?
</I>
You can destroy exchanges whenever you like.  How you monitor activity
is up to you.

There isn't a 'built in' functions for 'delete an unused exchange
after time T'.  Some of the ideas Paul was talking about could be
helpful here - using presence to manage internal broker lifecycle.

Direct and fanout exchanges are 'lightweight' lookup tables so you
might want to manage memory by monitoring overall memory use and user
activity.


&gt;<i> Can you use a standard XMPP client with this setup?
</I>
You can use an XMPP client if you run RabbitMQ with the XMPP adaptor.



&gt;&gt;<i> Let me know if you want more detail on either of the above, eg which
</I>&gt;&gt;<i> exchange type to use.
</I>&gt;<i>
</I>&gt;<i> I thought of a non durable exchange. One exchange per chatroom and one queue
</I>&gt;<i> per user.
</I>
That seems like a good approach.  In this case you would use a
'fanout' exchange.

Another approach would be to use just one 'direct' exchange and bind
all user queues to it using the routing keys corresponding to the
chatrooms the users are in.

If you haven't yet seen it, the 'rabbits and warrens' intro article
linked to here is good: <A HREF="http://www.rabbitmq.com/how.html">http://www.rabbitmq.com/how.html</A>



&gt;&gt;<i> &gt; I read the xmpp gateway
</I>&gt;&gt;<i> &gt; docs and have some questions.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; In a chat we want to be able to get presence from users on our
</I>&gt;&gt;<i> &gt; friend-list,
</I>&gt;&gt;<i> &gt; send them messages
</I>&gt;&gt;<i> &gt; and send subscription request and messages to users not yet on our
</I>&gt;&gt;<i> &gt; friend-list.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Do you only want to enable chat when both users are online and have a
</I>&gt;&gt;<i> 'friend' relationship?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; One possibility is that each user will have an exchange and a queue with
</I>&gt;&gt;<i> &gt; binding to his own exchange.
</I>&gt;&gt;<i> &gt; When user1 wants to send a message to user2 he send it directly to the
</I>&gt;&gt;<i> &gt; exchange of user2.
</I>&gt;&gt;<i> &gt; There is a problem with presence updates. If user1 changes his presence,
</I>&gt;&gt;<i> &gt; he'll have to&#160;sends the update
</I>&gt;&gt;<i> &gt; to the exchange of all the users&#160;on his friend-list. With this design we
</I>&gt;&gt;<i> &gt; move the logic to the client rather then use the AMQP features.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> One approach to presence is to broadcast changes using the pubsub
</I>&gt;&gt;<i> system. &#160;Changes could include:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> * User goes online / offline
</I>&gt;&gt;<i> * User changes their 'status message'
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> All I know is that there are queues exchanges and bindings.
</I>&gt;<i> What do you mean by the pubsub system?
</I>
By 'the pubsub system' I mean the RabbitMQ broker, and how you have
configured the queues by binding them to the exchange(s).

For example you can do 'pubsub' by binding queues to a direct
exchange.  Take a look at slides 20-22 from the presentation linked to
from this page:
<A HREF="http://skillsmatter.com/podcast/erlang/alexis-richardson-introduction-to-rabbitmq">http://skillsmatter.com/podcast/erlang/alexis-richardson-introduction-to-rabbitmq</A>
 This shows how a queue can use one or more bindings to 'subscribe' to
what producers ('publishers') are saying.

So there is nothing stopping you using the same mechanism to publish
presence information.  Suppose that whenever a user's presence
changes, a message is sent to a direct exchange on the broker with key
'username' and content 'presence_update_info'.  Then, anyone who cares
about that user's presence just has to bind a queue with the key
'username'.  I suggest you try and implement this pattern - it should
be very straightforward.


&gt;&gt;<i> &gt; Another option is that when a user logs in he'll create a binding to the
</I>&gt;&gt;<i> &gt; exchanges of all the users on his friend-list.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You can do this but it creates quite a lot of churn on the exchange
</I>&gt;&gt;<i> layer. &#160;Paul's suggestion is one way to prevent that. &#160;Another is to
</I>&gt;&gt;<i> use exchange-exchange bindings, which we are also looking at.
</I>&gt;<i>
</I>&gt;<i> I meant to create bindings to all your online friends.
</I>
Yes I understand that.


&gt;<i> Can you explain how Paul's suggestion or exchange-exchange bindings solve or
</I>&gt;<i> improve it?
</I>
Mostly they are performance optimisations that I would ignore for now,
not least because they are under investigation and not implemented yet
:<i>-)
</I>
When you create a binding, this action adds information to the routing
tables (ie the exchange).  This carries a (very small) computational
cost that you may not want to pay (if under heavy load, say).
Additionally if you are running in a multi-machine cluster, RabbitMQ
will copy the bindings to other machines, so that the routing table
info is shared across the cluster.  This additional copying carries a
(higher) computational cost.  To avoid paying this cost, you might
want to optimise how much binding and unbinding takes place.  Using
exchange-exchange bindings would mean, for example, that you could
store N bindings persistently on one exchange, corresponding to a
user's N friends, and have one binding between exchanges which gets
destroyed when that user is offline, and recreated whenever they come
online.  This would save you from having to make N bindings every time
a user came online.




&gt;&gt;<i> &gt; When user1 want to send a private message or a presence update to user2
</I>&gt;&gt;<i> &gt; he'll send it to his own exchange and it'll be directed to user2. The
</I>&gt;&gt;<i> &gt; problem with this design is that users without mutual presence
</I>&gt;&gt;<i> &gt; subscription
</I>&gt;&gt;<i> &gt; can't send private message to each other and can't send subscription
</I>&gt;&gt;<i> &gt; requests.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You can decouple presence, which is about status updates, from
</I>&gt;&gt;<i> friendship. &#160;If you like, you could have a set up where one user can
</I>&gt;&gt;<i> DM another, provided they are mutual friends, regardless of who is
</I>&gt;&gt;<i> online. &#160;Do you want that?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Subscription requests could also be implemented using a queue - one
</I>&gt;&gt;<i> per user. &#160;Whenever a new user wishes to request mutual friendship
</I>&gt;&gt;<i> with user A, then user A could be notified of this via a queue.
</I>&gt;<i>
</I>&gt;<i> In that case will the server send the friendship request directly to the
</I>&gt;<i> queue?
</I>
Yes.

&gt;<i> Do you need another queue per user just for friendship requests or can you
</I>&gt;<i> use the same queue from above?
</I>
It's up to you, but I would have, for each user, a special queue for
messages from people they are not following yet.

Is this helping?

alexis





&gt;&gt;<i> &gt; Can you please share your thoughts on the two options and maybe other
</I>&gt;&gt;<i> &gt; design
</I>&gt;&gt;<i> &gt; options?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I've tried to shed some light on some of the issues above. &#160;Feel free
</I>&gt;&gt;<i> to elaborate on your needs and ask more questions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> alexis
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; Thanks
</I>&gt;&gt;<i> &gt; _______________________________________________
</I>&gt;&gt;<i> &gt; rabbitmq-discuss mailing list
</I>&gt;&gt;<i> &gt; <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;&gt;<i> &gt; <A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004445.html">[rabbitmq-discuss] Weird Crash (91MB message over STOMP)	[Reproducible]
</A></li>
	<LI>Next message: <A HREF="004459.html">[rabbitmq-discuss] building chat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4453">[ date ]</a>
              <a href="thread.html#4453">[ thread ]</a>
              <a href="subject.html#4453">[ subject ]</a>
              <a href="author.html#4453">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
