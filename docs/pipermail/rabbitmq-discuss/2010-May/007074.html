<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] request for help!
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20request%20for%20help%21&In-Reply-To=4BE2A943.6070305%40250bpm.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007071.html">
   <LINK REL="Next"  HREF="007077.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] request for help!</H1>
    <B>Robert Godfrey</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20request%20for%20help%21&In-Reply-To=4BE2A943.6070305%40250bpm.com"
       TITLE="[rabbitmq-discuss] request for help!">rob.j.godfrey at gmail.com
       </A><BR>
    <I>Thu May  6 13:51:08 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="007071.html">[rabbitmq-discuss] request for help!
</A></li>
        <LI>Next message: <A HREF="007077.html">[rabbitmq-discuss] request for help!
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7074">[ date ]</a>
              <a href="thread.html#7074">[ thread ]</a>
              <a href="subject.html#7074">[ subject ]</a>
              <a href="author.html#7074">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for your reply - comments inline below

On 6 May 2010 13:34, Martin Sustrik &lt;<A HREF="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">sustrik at 250bpm.com</A>&gt; wrote:

&gt;<i> Hi Rob,
</I>&gt;<i>
</I>&gt;<i> First of all I would like to define what's MQ and what's DB. It'll be
</I>&gt;<i> helpful to get the discussion more focused IMO:
</I>&gt;<i>
</I>&gt;<i> With DB data are long-lived while queries are transient one-off events.
</I>&gt;<i>
</I>&gt;<i>
</I>I think this is a slight over-simplification.  AMQP aims to provide store
and forward messaging where &quot;store&quot; is an important part of that equation.
The storage may be transitory or it may be relatively long lived (I've just
been dealing with a situation where messages had been sitting in a queue for
several weeks, quite legitimately).  Any notion of &quot;queuing&quot; is implicitly
going to rely on some sort of storage: the queue.  Some use cases of
Messaging (in particular low-latency data distribution) may want to avoid
queuing and simply drop messages that cannot be consumed immediately.  While
this is not the use case AMQP is designed for, it can conceivably still be
used in this way.  not that it is not a requirement for every node to
support every distribution mode - moreover


&gt;<i> With MQ data are transient one-off events while queries are stable
</I>&gt;<i> long-lived entities.
</I>&gt;<i>
</I>&gt;<i> Terminology:
</I>&gt;<i>
</I>&gt;<i> Data = record (DB) = message (MQ)
</I>&gt;<i> Query = SQL statement (DB) = subscription (MQ)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  It's wider than ordering alone. Node with unordered messages is basically
</I>&gt;&gt;&gt;<i> a
</I>&gt;&gt;&gt;<i> database table.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A Node with unordered messages would be some sort of Bag I would
</I>&gt;&gt;<i> think... Unlike a DB table there would be no natural notion of a
</I>&gt;&gt;<i> primary key, or necessarily any notion of a way to select the messages
</I>&gt;&gt;<i> (though I guess the node *may* support certain AMQP1-0 filter types).
</I>&gt;&gt;<i> Again, there is no requirement on implementers to write such a Node
</I>&gt;&gt;<i> type (unless Michael has secretly put that in the document he is
</I>&gt;&gt;<i> currently writing ;-) )... All that the core spec is doing is saying
</I>&gt;&gt;<i> is &quot;it's perfectly valid to have nodes that give FIFO ordering, LIFO
</I>&gt;&gt;<i> ordering, or any other (non-)ordering you like&quot;.  This is actually
</I>&gt;&gt;<i> removing a burden on implementers rather than adding one (although the
</I>&gt;&gt;<i> requirement for the same sort of pseudo-FIFO that 0-x requires will
</I>&gt;&gt;<i> probably also be a requirement for AMQP 1-0 *Brokers*).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yes. Explicitly not defining how the messages are stored and leaving it to
</I>&gt;<i> layer above is perfectly valid approach. However, it should be done more
</I>&gt;<i> consistently, see below...
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  However, there are also other DB concepts in the spec. Say a concept of
</I>&gt;&gt;&gt;<i> non-destructive link -- which boils down to a SELECT statement. Or, say,
</I>&gt;&gt;&gt;<i> it seems implied that a message cannot silently disappear from a node
</I>&gt;&gt;&gt;<i> same way as record cannot silently disappear from a DB table.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There is absolutely no intent to prevent a node from silently
</I>&gt;&gt;<i> &quot;disappearing&quot; a message that it is holding.  All that
</I>&gt;&gt;<i> &quot;non-destructive&quot; means is that the act of sending the message to the
</I>&gt;&gt;<i> receiver does not in itself cause the message to be &quot;disappeared&quot;.
</I>&gt;&gt;<i> The two major use cases this functionality is designed for are Queue
</I>&gt;&gt;<i> &quot;browsing&quot; (i.e. the ability to look at what is in your queue without
</I>&gt;&gt;<i> consuming the messages) and the ability to implement &quot;Topics&quot; as a
</I>&gt;&gt;<i> single entity (rather than the AMQP 0-x way of having a queue per
</I>&gt;&gt;<i> consumer).  The Topic case is potentially more interesting as a Topic
</I>&gt;&gt;<i> node would have a policy that says &quot;when all connected consumers have
</I>&gt;&gt;<i> moved beyond a message in the *ordered* Topic, then the message may be
</I>&gt;&gt;<i> deleted&quot;.  This obviously requires some notion of ordering at the
</I>&gt;&gt;<i> (Topic) node.  Having implemented this functionality elsewhere, it
</I>&gt;&gt;<i> certainly doesn't require a database table like data-structure - all
</I>&gt;&gt;<i> it requires is that you hold pointers into the queue.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Let me give you just one example of what problems we are facing here:
</I>&gt;<i> Destructive vs. non-destructive semantics break &quot;stability&quot; of message
</I>&gt;<i> dispatch algorithm. In other words, which messages you get is not fully
</I>&gt;<i> determined by your subscription, rather it depends on ordering of
</I>&gt;<i> subscriptions in the broker. If destructive subscription is matched first,
</I>&gt;<i> non-destructive subscription won't get the message. If they are matched in
</I>&gt;<i> reverse order, both get the message. You do expect such behaviour with DB
</I>&gt;<i> system -- ordering of SQL statements effects the results -- however, you
</I>&gt;<i> don't want it to happen with MQ system.
</I>&gt;<i>
</I>&gt;<i>
</I>If you use destructive links at all then obviously (and correctly) which
messages are sent to which consumers will depend completely on the order in
which the node offers the messages to the links.  This is the epected
behaviour for queues.  For instance a shared work queue Q with consumers A,
B and C ... when a message M enters the queue it is the choice of the node
which of the A, B, or C it offers the message to - the other two will never
see it.  So I disagree that this is not expected behaviour in Messaging.
What you seem to be describing above is &quot;routing&quot; where there is no storage
capability.


&gt;<i>
</I>&gt;<i> My suggestion would be to stretch the abstraction of ignoring the internal
</I>&gt;<i> node state/algorithms to fully cover the node behaviour:
</I>&gt;<i>
</I>&gt;<i> 1. Node is a named endpoint for links and that's it.
</I>&gt;<i>
</I>&gt;<i> 2. There's no concept of message being resident on a node.
</I>&gt;<i>
</I>&gt;<i> 3. There's no message ordering defined. This follows from the above.
</I>&gt;<i>
</I>&gt;<i> 4. There's no message state machine. This follows from 2.
</I>&gt;<i>
</I>&gt;<i> 3. There are no destructive/non-destructive links, just &quot;links&quot;.
</I>&gt;<i>
</I>&gt;<i>
</I>I believe the spec already separates out these concerns into separate layers
in a way which I think generally matches your categorization.  Each Book in
the spec represents an independent layer (with the exception of the first
book which is there to provide a gentle introduction to the concepts).

To the Transport Layer (Book III) links are between link endpoints - there
is no concept of message residence, ordering, or a state machine.  This is
what you are describing above I think.

Book IV, the Messaging Layer defines a particular form for describing the
link endpoints.  This defines a scheme for identifying whether you wish to
take the messages from the sender (acquire/destructive) or simply look at
the messages with taking them (browse/non-destructive).  This is also the
layer where we define how to request durability of the message, allow for
the assigning of priorities, etc.  This behaviour should be common to more
than just &quot;brokers&quot; but also available in other AMQP intermediaries
respecting the same Messaging layer.



&gt;<i> Adopting the points above would make core specification much cleaner. The
</I>&gt;<i> burden of defining storage/ordering/routing etc. is left to &quot;broker
</I>&gt;<i> behaviour&quot; specification.
</I>&gt;<i>
</I>&gt;<i>
</I>Broker Behaviour will define a concrete set of capabilities that something
calling itself an &quot;AMQP Broker&quot; MUST provide.  In effect it is documenting
constraints on the implementer as to the minimum features they must provide
through the Messaging Layer.

Even within a container which implements the Messaging Layer as described in
Book IV, not every node need support all the options - it is expected that
each node will support only certain messaging patterns.  For example a node
that implements only &quot;routing&quot; and not storage of any kind (something a bit
like an 0-x Exchange) would not support mixing distribution modes I imagine
- either it would only allow non-destructive distribution (acting as a
fanout- every message goes to every consumer) or only allow destructive
distribution (acting as a switch - each message goes to the first/only
consumer that can take it... or is dropped if there is no such consumer).

As an aside, the names destructive/non-destructive could probably be
improved upon 9as they don't really properly capture the implied meaning) -
but no-one has yet come up with terms that can be universally agreed upon
:<i>-)
</I>
Hope this is making things a bit clearer

-- Rob
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100506/f4f5614d/attachment-0001.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20100506/f4f5614d/attachment-0001.htm</A> 
</PRE>


















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007071.html">[rabbitmq-discuss] request for help!
</A></li>
	<LI>Next message: <A HREF="007077.html">[rabbitmq-discuss] request for help!
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7074">[ date ]</a>
              <a href="thread.html#7074">[ thread ]</a>
              <a href="subject.html#7074">[ subject ]</a>
              <a href="author.html#7074">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
