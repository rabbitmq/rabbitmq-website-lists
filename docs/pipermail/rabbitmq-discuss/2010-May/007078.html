<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] request for help!
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20request%20for%20help%21&In-Reply-To=4BE2C191.5030402%40250bpm.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007077.html">
   <LINK REL="Next"  HREF="007079.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] request for help!</H1>
    <B>Michael Bridgen</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20request%20for%20help%21&In-Reply-To=4BE2C191.5030402%40250bpm.com"
       TITLE="[rabbitmq-discuss] request for help!">mikeb at lshift.net
       </A><BR>
    <I>Thu May  6 15:03:21 BST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="007077.html">[rabbitmq-discuss] request for help!
</A></li>
        <LI>Next message: <A HREF="007079.html">[rabbitmq-discuss] request for help!
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7078">[ date ]</a>
              <a href="thread.html#7078">[ thread ]</a>
              <a href="subject.html#7078">[ subject ]</a>
              <a href="author.html#7078">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;&gt;<i>     Let me give you just one example of what problems we are facing
</I>&gt;&gt;<i>     here: Destructive vs. non-destructive semantics break &quot;stability&quot; of
</I>&gt;&gt;<i>     message dispatch algorithm. In other words, which messages you get
</I>&gt;&gt;<i>     is not fully determined by your subscription, rather it depends on
</I>&gt;&gt;<i>     ordering of subscriptions in the broker. If destructive subscription
</I>&gt;&gt;<i>     is matched first, non-destructive subscription won't get the
</I>&gt;&gt;<i>     message. If they are matched in reverse order, both get the message.
</I>&gt;&gt;<i>     You do expect such behaviour with DB system -- ordering of SQL
</I>&gt;&gt;<i>     statements effects the results -- however, you don't want it to
</I>&gt;&gt;<i>     happen with MQ system.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you use destructive links at all then obviously (and correctly) which 
</I>&gt;&gt;<i> messages are sent to which consumers will depend completely on the order 
</I>&gt;&gt;<i> in which the node offers the messages to the links.  This is the epected 
</I>&gt;&gt;<i> behaviour for queues.  For instance a shared work queue Q with consumers 
</I>&gt;&gt;<i> A, B and C ... when a message M enters the queue it is the choice of the 
</I>&gt;&gt;<i> node which of the A, B, or C it offers the message to - the other two 
</I>&gt;&gt;<i> will never see it.  So I disagree that this is not expected behaviour in 
</I>&gt;&gt;<i> Messaging.  What you seem to be describing above is &quot;routing&quot; where 
</I>&gt;&gt;<i> there is no storage capability.
</I>&gt;<i> 
</I>&gt;<i> Let me give an example:
</I>&gt;<i> 
</I>&gt;<i> Say you have a non-destructive an destructive links attached to a node. 
</I>&gt;<i> When you process a message at the node, the non-destructive link gets 
</I>&gt;<i> either all the messages (if the matching for the destructive link is 
</I>&gt;<i> done after matching for the non-destructive one), or no messages (if the 
</I>&gt;<i> matching for the destructive link is done before matching for the 
</I>&gt;<i> non-destructive one) or random subset of messages (if some form of 
</I>&gt;<i> load-balancing among links is done). All in all, client has no guarantee 
</I>&gt;<i> of which messages it'll get or whether it'll get at least some messages.
</I>&gt;<i> 
</I>&gt;<i> In other words, one misbehaved client can render all the other clients 
</I>&gt;<i> non-functional.
</I>
I understand that there's a desire to accommodate e.g., JMS-like 
semantics (which I can see may have been a motivating force for 
&quot;distribution mode&quot;).  But I think the core spec can leave room for 
those, without taking a position otherwise.

What the spec does at the minute is to have a model that tries to 
encompass all possibilities, where it ought to be silent.

The main problem with the &quot;all possibilities&quot; approach is that it 
infects other layers.

For example, the distribution modes and message state model make flow 
control, transactions, responsibility transfer and reliable delivery all 
interdependent.  In my opinion these can be teased apart; specifically 
(but probably not exclusively), by distinguishing between delivery 
acknowledgement and transfer of responsibility.

(Conflating those causes problems in 0-9-1 too by the way -- there's a 
rather fraught, unresolved question in RabbitMQ's bugzilla about the 
interaction between flow control and transactional acks.  The last 
comment says &quot;In conclusion, after discussion, acks are overloaded, and 
mean two things - 1. I've seen the msg; 2. forget about the msg. ...&quot;)


Michael.

</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007077.html">[rabbitmq-discuss] request for help!
</A></li>
	<LI>Next message: <A HREF="007079.html">[rabbitmq-discuss] request for help!
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7078">[ date ]</a>
              <a href="thread.html#7078">[ thread ]</a>
              <a href="subject.html#7078">[ subject ]</a>
              <a href="author.html#7078">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
