<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Confirm consistent hash exchange behavior
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Confirm%20consistent%20hash%20exchange%20behavior&In-Reply-To=%3CCAMcAHLWJRRSDOH3gL8_Vsgk-HYoePe7iWkp1cQxPTmy%2BW%3DD%2Byw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025943.html">
   <LINK REL="Next"  HREF="025947.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Confirm consistent hash exchange behavior</H1>
    <B>Alvaro Videla</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20Confirm%20consistent%20hash%20exchange%20behavior&In-Reply-To=%3CCAMcAHLWJRRSDOH3gL8_Vsgk-HYoePe7iWkp1cQxPTmy%2BW%3DD%2Byw%40mail.gmail.com%3E"
       TITLE="[rabbitmq-discuss] Confirm consistent hash exchange behavior">videlalvaro at gmail.com
       </A><BR>
    <I>Fri Mar 15 21:56:52 GMT 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="025943.html">[rabbitmq-discuss] Confirm consistent hash exchange behavior
</A></li>
        <LI>Next message: <A HREF="025947.html">[rabbitmq-discuss] Confirm consistent hash exchange behavior
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25945">[ date ]</a>
              <a href="thread.html#25945">[ thread ]</a>
              <a href="subject.html#25945">[ subject ]</a>
              <a href="author.html#25945">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

I think this solution can address your problem:

- Create queues 1, 2, .... N
- Bind queues to the CHX
- publish the queue names to a queue called &quot;lock&quot; for example.

Start consumer A, and make it consume _just one message_ from queue &quot;lock&quot;,
in ack mode. That message will contain the queue name from where that
consumer needs to get messages.

Then you can start consumer B and do the same, so you get the name of the
next queue where to get the messages.

Because you are using the CH exchange, messages witch certain routing key
will always end up in the same queue. Therefore you can also process
messages in order.

If you need to stop one of those consumers, they need to
basic_reject(requeue=true) the message they first got from the &quot;lock&quot; queue
so another consumer can use that queue. If one of those consumers crashes
then the message with the queue name will get requeued. NOTE: you never ack
any message from the &quot;lock&quot; queue.

Does this help?

Regards,

Alvaro



On Fri, Mar 15, 2013 at 4:46 PM, SteveO &lt;<A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">steveolivier22 at gmail.com</A>&gt; wrote:

&gt;<i> Subsequent bindings would have no affect on routing keys that have already
</I>&gt;<i> been seen. When a message with a new routing key arrives, new bindings (or
</I>&gt;<i> even existing ones) could be used for the new routing key.
</I>&gt;<i>
</I>&gt;<i> Once I looked beyond the specific requirements of our application, and
</I>&gt;<i> thinking about distribution, I completely realize the behavior I seek
</I>&gt;<i> breaks
</I>&gt;<i> the nature of the CHX. I understand why it's not doing what I want. So I
</I>&gt;<i> guess what I am looking at is some crazy feature or a completely different
</I>&gt;<i> exchange altogether.
</I>&gt;<i>
</I>&gt;<i> Here are the high level requirements:
</I>&gt;<i> 1. Need to scale
</I>&gt;<i> 2. Need to process messages with the same routing key in order
</I>&gt;<i>
</I>&gt;<i> Here is what is highly desired:
</I>&gt;<i> 1. Elastic scaling of queues
</I>&gt;<i> 2. No back-channel consumer/producer communication
</I>&gt;<i>
</I>&gt;<i> A single queue with multiple consumers gives me req1, but not req2. A
</I>&gt;<i> single
</I>&gt;<i> queue with a single consumer gives me req2, but not req1. By way of a CHX,
</I>&gt;<i> multiple queues and multiple consumers gets me both req1 and req2. However
</I>&gt;<i> with the CHX, if I accomplish scaling up by adding another queue and
</I>&gt;<i> consumer, I can run into situations where I can't guarantee req2. That's
</I>&gt;<i> because I can get messages with the same routing key in more than one
</I>&gt;<i> queue.
</I>&gt;<i> For an alternative method of scale, I can accomplish req1 and req2 by
</I>&gt;<i> adding
</I>&gt;<i> another CHX. However, with our application that would require some
</I>&gt;<i> back-channel communication between producers and consumers which is highly
</I>&gt;<i> undesirable.
</I>&gt;<i>
</I>&gt;<i> A type of &quot;pick and stick&quot; method could work well for us. Our application
</I>&gt;<i> is
</I>&gt;<i> processing messages for events that span a finite duration of time. These
</I>&gt;<i> events could last a few minutes, a few hours or a few days. Messages
</I>&gt;<i> pertaining to a specific event are signified by a GUID in the routing key.
</I>&gt;<i> Once the event is done, messages are consumed and processed, the routing
</I>&gt;<i> key
</I>&gt;<i> for that event is never seen again. I just can't trust the timeliness of my
</I>&gt;<i> consumers, and I have to guarantee message processing order. That's why I
</I>&gt;<i> have to ensure that messages with the same routing key only exist in one
</I>&gt;<i> queue at a time.
</I>&gt;<i>
</I>&gt;<i> I suspect I could have discussed this situation much better if had simply
</I>&gt;<i> stated that rather than questioning the CHX : )
</I>&gt;<i>
</I>&gt;<i> Is this a crazy feature request for a switch to turn this on in the CHX?
</I>&gt;<i> Am I looking at a custom exchange?
</I>&gt;<i> Something else?
</I>&gt;<i>
</I>&gt;<i> Thanks again.
</I>&gt;<i>
</I>&gt;<i> s
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> View this message in context:
</I>&gt;<i> <A HREF="http://rabbitmq.1065348.n5.nabble.com/Confirm-consistent-hash-exchange-behavior-tp25458p25471.html">http://rabbitmq.1065348.n5.nabble.com/Confirm-consistent-hash-exchange-behavior-tp25458p25471.html</A>
</I>&gt;<i> Sent from the RabbitMQ mailing list archive at Nabble.com.
</I>&gt;<i> _______________________________________________
</I>&gt;<i> rabbitmq-discuss mailing list
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">rabbitmq-discuss at lists.rabbitmq.com</A>
</I>&gt;<i> <A HREF="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss</A>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130315/57182ffe/attachment.htm">http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/attachments/20130315/57182ffe/attachment.htm</A>&gt;
</PRE>




























































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025943.html">[rabbitmq-discuss] Confirm consistent hash exchange behavior
</A></li>
	<LI>Next message: <A HREF="025947.html">[rabbitmq-discuss] Confirm consistent hash exchange behavior
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25945">[ date ]</a>
              <a href="thread.html#25945">[ thread ]</a>
              <a href="subject.html#25945">[ subject ]</a>
              <a href="author.html#25945">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
