<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Fwd: Client-connection failover workarounds (ruby)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Fwd%3A%20Client-connection%20failover%20workarounds%0A%20%28ruby%29&In-Reply-To=670a00381002080722r17eff34ak885ab3ab172841c7%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006240.html">
   <LINK REL="Next"  HREF="006162.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Fwd: Client-connection failover workarounds (ruby)</H1>
    <B>Matthew Sackman</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Fwd%3A%20Client-connection%20failover%20workarounds%0A%20%28ruby%29&In-Reply-To=670a00381002080722r17eff34ak885ab3ab172841c7%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Fwd: Client-connection failover workarounds (ruby)">matthew at lshift.net
       </A><BR>
    <I>Mon Feb  8 15:49:07 GMT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="006240.html">[rabbitmq-discuss] Fwd: Client-connection failover workarounds	(ruby)
</A></li>
        <LI>Next message: <A HREF="006162.html">[rabbitmq-discuss] EC2 clustering issue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6241">[ date ]</a>
              <a href="thread.html#6241">[ thread ]</a>
              <a href="subject.html#6241">[ subject ]</a>
              <a href="author.html#6241">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, Feb 08, 2010 at 09:22:32AM -0600, Peter Fitzgibbons wrote:
&gt;<i> &gt; Nope. To use your terminology, if you have rabbitP, which is local to
</I>&gt;<i> &gt; producerP, then you then have the option to run the shovel inside
</I>&gt;<i> &gt; rabbitP. This is configured to know about rabbitA, rabbitB&#8230; and so if
</I>&gt;<i> &gt; any of those rabbits go down, the shovel will automatically try to
</I>&gt;<i> &gt; reconnect, trying all the rabbits it knows about until it finds one that
</I>&gt;<i> &gt; works. Whilst the shovel is trying to find a rabbit to connect to,
</I>&gt;<i> &gt; messages queue up inside rabbitP, from producerP, in the normal way -
</I>&gt;<i> &gt; the interruption is totally invisible to producerP.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; How is this different from configuring a rabbit cluster that includes my
</I>&gt;<i> &quot;local&quot; node?
</I>&gt;<i> Matthias warned me that this is a degenerate case, where the cluster will
</I>&gt;<i> struggle to support 10's (100's in a farm) of clustered servers.
</I>
Clustering Rabbit achieves scalability, not reliability. With a cluster,
queues are not replicated, whilst the meta data associated with queues,
exchanges and bindings are shared across all nodes of the cluster.

It's rather tricky, at the moment, to do any sort of high availability,
active/passive fail-over type stuff with clusters.

&gt;<i> To extend my understanding (and offer an opportunity to correct my
</I>&gt;<i> understanding),
</I>&gt;<i> Shovel is preferred because the local rabbitP is not clustered, does not
</I>&gt;<i> have to be &quot;aware&quot; of the cluster, and shovel has the proper failover
</I>&gt;<i> routines to handle it when times get tough.
</I>
Yes. In general, the lower the coupling and higher the independence, the
better, from the pov of resiliance and availability.

&gt;<i> What about consumerA, consumerB, etc?  Are these theoretically expected to
</I>&gt;<i> be &quot;protected&quot; from harm?  I think this question is pointing toward my
</I>&gt;<i> potential misunderstanding of how consumer push or pull is handled.
</I>
Err, well, I don't see from your past emails how you think the consumers
are connected in. Again, you could do a local rabbit to each of the
consumers, again with a shovel, if you wanted to. Or wire the consumers
themselves with knowledge of which central servers you have to connect
to. Or stick a TCP load balancer between the consumers and the central
servers. It all depends on how you provision the central servers - if
it's known that a certain messages will be sent to a particular server
(or set of servers, given an HA setup) then it's sufficient to wire the
consumers to continually try to connect to those servers. If you need more
dynamic control over where the consumers connect to to find the messages
they're interested in, then dynamic DNS, or a TCP load balancer, or even
things like IP or MAC -address stealing may be more appropriate.

Matthew


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006240.html">[rabbitmq-discuss] Fwd: Client-connection failover workarounds	(ruby)
</A></li>
	<LI>Next message: <A HREF="006162.html">[rabbitmq-discuss] EC2 clustering issue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6241">[ date ]</a>
              <a href="thread.html#6241">[ thread ]</a>
              <a href="subject.html#6241">[ subject ]</a>
              <a href="author.html#6241">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
