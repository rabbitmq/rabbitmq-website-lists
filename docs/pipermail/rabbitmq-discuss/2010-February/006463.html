<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] Is rabbitmq appropriate for messaging to	thousands of transient clients?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Is%20rabbitmq%20appropriate%20for%20messaging%0A%20to%09thousands%20of%20transient%20clients%3F&In-Reply-To=5704921d1002232219h597c34c3n6f12f49bd5383ceb%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006460.html">
   <LINK REL="Next"  HREF="006461.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] Is rabbitmq appropriate for messaging to	thousands of transient clients?</H1>
    <B>Tony Garnock-Jones</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20Is%20rabbitmq%20appropriate%20for%20messaging%0A%20to%09thousands%20of%20transient%20clients%3F&In-Reply-To=5704921d1002232219h597c34c3n6f12f49bd5383ceb%40mail.gmail.com"
       TITLE="[rabbitmq-discuss] Is rabbitmq appropriate for messaging to	thousands of transient clients?">tonyg at lshift.net
       </A><BR>
    <I>Thu Feb 25 05:05:00 GMT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="006460.html">[rabbitmq-discuss] Is rabbitmq appropriate for messaging to	thousands of transient clients?
</A></li>
        <LI>Next message: <A HREF="006461.html">[rabbitmq-discuss] rabbitMQ/Beam only using one core.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6463">[ date ]</a>
              <a href="thread.html#6463">[ thread ]</a>
              <a href="subject.html#6463">[ subject ]</a>
              <a href="author.html#6463">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Josh,

Josh Gruenberg wrote:
&gt;<i> Is this a good idea?
</I>
OK, so we're looking at peaks of 10000 clients, each talking about once
a second. That message rate is fine, but you'll have to do the usual
kind of C10K tuning and tweaking to get your kernel and Erlang VM able
to accept that many connections at once.

&gt;<i> 1. The intuitive implementation would involve creating a private queue
</I>&gt;<i> for each client to receive messages.  This would imply 10k
</I>&gt;<i> client-specific queues and 10k connections.  Any concerns there?
</I>
Not on the queues front, and on the connections front, it should just be
down to kernel and erlang VM tuning. Should. If there are problems, we
definitely need to know so that they can be fixed! Your scale of
deployment is something Rabbit squarely aims to cover, IMO.

&gt;<i> 2. Mobile gaming sessions are typically short-lived; current
</I>&gt;<i> projections suggest we may sometimes see 10 sessions starting/ending
</I>&gt;<i> per second (implying 10 connections and queues being created and
</I>&gt;<i> destroyed per sec, with several associated bindings each).  Will this
</I>&gt;<i> thrashing be sustainable?
</I>
Oo. OK, that's interesting. It *should* be ok... but I haven't tried it
myself.

&gt;<i> Will AMQP/rabbit help with
</I>&gt;<i> this, or would we need to implement our own deduplication logic?
</I>
Currently, deduplication is a pure client-side issue. We do support the
AMQP &quot;redelivered&quot; flag, though which

 - is guaranteed false if this is known by the server to be the very
   first time this message has been sent out from a queue to a consumer
   or getter

 - is guaranteed true if there's any doubt, that is, if there's even
   the slightest possibility a receiving client may have seen the
   message before

This lets you avoid any dedup buffer lookups for messages that are
guaranteed first-time deliveries.

&gt;<i> 4. Security is obviously a concern. We've brainstormed the following strategy:
</I>&gt;<i>     - provision temporary credentials for each client session to
</I>&gt;<i> authorize access to the shared vhost (revoked upon session expiry)
</I>&gt;<i>     - create each client queue from the server, sending its name to the client
</I>&gt;<i>     - manage all queue bindings from the server in response to client requests
</I>&gt;<i> This way, all routing configuration would be handled by the server,
</I>&gt;<i> and clients would only know the name of their one queue (and a few
</I>&gt;<i> exchanges for messaging specific server-side actors.)  Is this wise?
</I>
It seems reasonable. Others may have more detailed comments. ;-)

&gt;<i> Do these characteristics spell trouble?  Are there existing real-world
</I>&gt;<i> installations that successfully connect large client-bases directly to
</I>&gt;<i> rabbitmq?
</I>
I believe so, but others can confirm or deny for sure.

Another approach you could take, given the high disconnect/reconnect
load you anticipate, and the custom security requirements you have, is
to hack your existing TCP transport so that it backs into the AMQP
routing, queueing and delivery model. That way you get to reuse the core
of RabbitMQ, and all of the careful design of AMQP, with a
lighter-weight and more domain-focussed wire protocol. How's your
Erlang? ;-) (See, e.g., the STOMP adapter for an example of how this
might be done.)

Regards,
  Tony


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006460.html">[rabbitmq-discuss] Is rabbitmq appropriate for messaging to	thousands of transient clients?
</A></li>
	<LI>Next message: <A HREF="006461.html">[rabbitmq-discuss] rabbitMQ/Beam only using one core.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6463">[ date ]</a>
              <a href="thread.html#6463">[ thread ]</a>
              <a href="subject.html#6463">[ subject ]</a>
              <a href="author.html#6463">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
