<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] RabbitMQ performance tips, collected with sweat and blood
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20RabbitMQ%20performance%20tips%2C%0A%20collected%20with%20sweat%20and%20blood&In-Reply-To=%3C20110812081310.GB14591%40wellquite.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014511.html">
   <LINK REL="Next"  HREF="014522.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] RabbitMQ performance tips, collected with sweat and blood</H1>
    <B>Matthew Sackman</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=Re%3A%20%5Brabbitmq-discuss%5D%20RabbitMQ%20performance%20tips%2C%0A%20collected%20with%20sweat%20and%20blood&In-Reply-To=%3C20110812081310.GB14591%40wellquite.org%3E"
       TITLE="[rabbitmq-discuss] RabbitMQ performance tips, collected with sweat and blood">matthew at rabbitmq.com
       </A><BR>
    <I>Fri Aug 12 09:13:10 BST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="014511.html">[rabbitmq-discuss] RabbitMQ performance tips,	collected with sweat and blood
</A></li>
        <LI>Next message: <A HREF="014522.html">[rabbitmq-discuss] RabbitMQ performance tips, collected with sweat and blood
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14513">[ date ]</a>
              <a href="thread.html#14513">[ thread ]</a>
              <a href="subject.html#14513">[ subject ]</a>
              <a href="author.html#14513">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, Aug 11, 2011 at 09:47:40PM -0700, Eugene Kirpichov wrote:
&gt;<i> * Turn on prefetch. Large is good, small is better than nothing. You
</I>&gt;<i> can try a trick &quot;reject a prefetched message if we didn't actually
</I>&gt;<i> need it for a few seconds/minutes&quot;. Consider prefetch individually for
</I>&gt;<i> each queue; e.g. it may be that you cannot turn it on for tasks, but
</I>&gt;<i> can for results.
</I>
I don't know what you mean by prefetch. If you mean basic.qos then
you're a little mistaken - basic.qos is a per channel thing, and not per
consumer. Thus setting basic.qos affects every queue from which you're
consuming within the same channel. Using basic.qos with non-zero values
is known to have a fairly large negative impact on performance.

&gt;<i> * Turn on autoAck
</I>
autoAck and basic.qos are mutually exclusive.

&gt;<i> * In a cluster, always communicate with a queue only through the
</I>&gt;<i> broker that first declared it
</I>
Why do you say that?

&gt;<i> * Avoid frequently doing these things, esp. on a cluster: establishing
</I>&gt;<i> a connection, BasicConsume, QueueDeclare etc. If you do them often
</I>&gt;<i> (dozens/hundreds of times per second), you're completely screwed. And
</I>&gt;<i> conversely, if you're completely screwed, the first place to look is
</I>&gt;<i> whether you're doing these things too frequently, and if you're not,
</I>&gt;<i> look again.
</I>
Connection establishment certainly can be a little expensive but you
should be able to do a few hundred a second fairly easily. Things that
hit queues when those queues are already busy can take some time
depending on the loading present on the queue. This is something we're
aware of and are trying to figure out how to solve.

&gt;<i> * Increase erlang process limit
</I>
We do that by default, but certainly for large installations raising
that further may be necessary.

&gt;<i> * Split one queue into many, as a queue can only utilize 1 core -
</I>&gt;<i> across a cluster or not (either will give some benefit); publish in
</I>&gt;<i> roundrobin (between those sub-queues that aren't overloaded acc. to
</I>&gt;<i> publisher confirmations); consume all simultaneously.
</I>
Yeah, the problem with that is that your message stream may require some
sort of ordering guarantees and by publishing round-robin, you're going
to lose that. For some use cases though, this can be an effective
approach.

Matthew
</PRE>

































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014511.html">[rabbitmq-discuss] RabbitMQ performance tips,	collected with sweat and blood
</A></li>
	<LI>Next message: <A HREF="014522.html">[rabbitmq-discuss] RabbitMQ performance tips, collected with sweat and blood
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14513">[ date ]</a>
              <a href="thread.html#14513">[ thread ]</a>
              <a href="subject.html#14513">[ subject ]</a>
              <a href="author.html#14513">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
