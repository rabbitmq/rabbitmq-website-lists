<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [rabbitmq-discuss] RabbitMQ erlang client documentation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20RabbitMQ%20erlang%20client%20documentation&In-Reply-To=4B182C76.9070704%40lshift.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005603.html">
   <LINK REL="Next"  HREF="005607.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[rabbitmq-discuss] RabbitMQ erlang client documentation</H1>
    <B>Sylvain Hellegouarch</B> 
    <A HREF="mailto:rabbitmq-discuss%40lists.rabbitmq.com?Subject=%5Brabbitmq-discuss%5D%20RabbitMQ%20erlang%20client%20documentation&In-Reply-To=4B182C76.9070704%40lshift.net"
       TITLE="[rabbitmq-discuss] RabbitMQ erlang client documentation">sh at defuze.org
       </A><BR>
    <I>Fri Dec  4 08:08:43 GMT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="005603.html">[rabbitmq-discuss] RabbitMQ erlang client documentation
</A></li>
        <LI>Next message: <A HREF="005607.html">[rabbitmq-discuss] RabbitMQ erlang client documentation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5604">[ date ]</a>
              <a href="thread.html#5604">[ thread ]</a>
              <a href="subject.html#5604">[ subject ]</a>
              <a href="author.html#5604">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Vlad,

&gt;&gt;<i> Should channels be on per process basis? Say I create a channel, can I
</I>&gt;&gt;<i> publish more than once without having to wait for each ack? Or is
</I>&gt;&gt;<i> there a sequential constraint so that the channel knows where to
</I>&gt;&gt;<i> propagate the potential ack from the server
</I>&gt;<i> You can use a channel from more than one process. The channel process
</I>&gt;<i> queues up the calls and sends them to the server one by one (sends one,
</I>&gt;<i> waits for reply, sends the next, waits for reply etc). While a call is
</I>&gt;<i> in the queue to be sent to the server, the (user) process which
</I>&gt;<i> initiated the call is blocked while the methods in front in the queue
</I>&gt;<i> are processed plus the time for our actual call.
</I>&gt;<i> So the channel takes care of serializing the methods and remembers which
</I>&gt;<i> process sent which method so it can reply (return value) to user
</I>&gt;<i> processes accordingly.
</I>&gt;<i> However, due to the synchronous nature of this mechanism, just one
</I>&gt;<i> channel will not utilize the entire bandwidth available (e.g. while the
</I>&gt;<i> channel is waiting for the reply, it does not send the next call). For
</I>&gt;<i> this reason, it is advisable to split tasks that have no relation to
</I>&gt;<i> each other (the order of the events does not matter between tasks) so
</I>&gt;<i> that they use separate channels.
</I>&gt;<i>
</I>&gt;<i> All the above applies to synchronous methods (like basic.get for example).
</I>&gt;<i> Asynchronous methods (like basic.publish) are not queued up. They are
</I>&gt;<i> sent immediately no matter what is in the queue (a call may end up after
</I>&gt;<i> a cast at the server even though the call was made before the cast, if
</I>&gt;<i> the call has to wait in line).
</I>&gt;<i>
</I>&gt;<i> You can use amqp_channel:call/{2,3} for both sync and async methods
</I>&gt;<i> (async methods return 'ok' immediately) and amqp_channel:cast/{2,3} only
</I>&gt;<i> for async methods.
</I>&gt;<i>
</I>&gt;<i>
</I>

Thanks for all of this. There is one point I'm uncertain about. In my use
case I'm using mochiweb to push HTTP body requests into AMQP. I've looked
at the rabbitmq-mochiweb project but I couldn't find any point in the
source where they would actually be calling AMQP at all (as teh doc says
it's mainly a placeholder project).

Anyway, currently I have one single connection and I'm opening a channel
for each HTTP request, publishing and immediatly closing that channel. Is
that the most efficient usage of the erlang lib? If not, any hints to
improve it if you don't mind?

Cheers again,
- Sylvain
-- 
Sylvain Hellegouarch
<A HREF="http://www.defuze.org">http://www.defuze.org</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005603.html">[rabbitmq-discuss] RabbitMQ erlang client documentation
</A></li>
	<LI>Next message: <A HREF="005607.html">[rabbitmq-discuss] RabbitMQ erlang client documentation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5604">[ date ]</a>
              <a href="thread.html#5604">[ thread ]</a>
              <a href="subject.html#5604">[ subject ]</a>
              <a href="author.html#5604">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo/rabbitmq-discuss">More information about the rabbitmq-discuss
mailing list</a><br>
</body></html>
